<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyPocket - Web Reader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #ee5a24;
            --secondary-color: #667eea;
            --background: #f8f9fa;
            --surface: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --border: #e9ecef;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        /* Enhanced Dark mode with better contrast */
        [data-theme="dark"] {
            --primary-color: #ff6b35;
            --secondary-color: #7b88f7;
            --background: #0d1117;
            --surface: #161b22;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --border: #30363d;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.6);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.8);
        }

        /* Dark mode specific improvements */
        [data-theme="dark"] .article-card {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .article-card:hover {
            border-color: #484f58;
            transform: translateY(-2px) scale(1.02);
        }

        [data-theme="dark"] .search-input {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .search-input:focus {
            border-color: var(--primary-color);
            background: var(--surface);
        }

        [data-theme="dark"] .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.8;
        }

        [data-theme="dark"] .search-close-btn:hover {
            background: #21262d;
            color: var(--text-primary);
        }

        [data-theme="dark"] .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border-color: var(--border);
        }

        [data-theme="dark"] .btn-secondary:hover {
            background: #21262d;
            border-color: #484f58;
            color: var(--text-primary);
        }

        [data-theme="dark"] .action-btn {
            background: rgba(22, 27, 34, 0.95);
            border-color: var(--border);
            color: var(--text-primary);
            backdrop-filter: blur(10px);
        }

        [data-theme="dark"] .action-btn:hover {
            background: rgba(33, 38, 45, 0.95);
            border-color: #484f58;
        }

        [data-theme="dark"] .read-btn:hover {
            background: rgba(13, 110, 253, 0.2);
            border-color: #0d6efd;
            color: #58a6ff;
        }

        [data-theme="dark"] .export-btn:hover {
            background: rgba(25, 135, 84, 0.2);
            border-color: #198754;
            color: #3fb950;
        }

        [data-theme="dark"] .refresh-image-btn:hover {
            background: rgba(255, 152, 0, 0.2);
            border-color: #ff9800;
            color: #ffb74d;
        }

        [data-theme="dark"] .delete-btn:hover {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #f85149;
        }

        [data-theme="dark"] .reader-container {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .reader-header {
            background: var(--background);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .reader-content {
            color: var(--text-primary);
        }

        [data-theme="dark"] .reader-content h1,
        [data-theme="dark"] .reader-content h2,
        [data-theme="dark"] .reader-content h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .reader-content blockquote {
            background: var(--background);
            border-left-color: var(--primary-color);
        }

        [data-theme="dark"] .close-reader {
            background: var(--primary-color);
        }

        [data-theme="dark"] .empty-state {
            color: var(--text-secondary);
        }

        [data-theme="dark"] .empty-state h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .connection-status.connected {
            background: rgba(25, 135, 84, 0.2);
            border-color: #198754;
            color: #3fb950;
        }

        [data-theme="dark"] .connection-status.disconnected {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #f85149;
        }

        /* NEW: Enhanced dark mode styles for cache indicators */
        [data-theme="dark"] .cache-indicator.synced {
            background: rgba(76, 175, 80, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.fallback {
            background: rgba(255, 152, 0, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.metadata {
            background: rgba(103, 58, 183, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.error {
            background: rgba(244, 67, 54, 0.9);
            color: white;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--background);
            margin: 0;
            display: flex;
            min-height: 100vh;
        }

        /* Sidebar Navigation */
        .sidebar {
            width: 280px;
            background: var(--surface);
            border-right: 1px solid var(--border);
            box-shadow: var(--shadow);
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            z-index: 100;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            color: white;
        }

        .sidebar-logo {
            font-size: 1.4em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .connection-status {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
        }

        .sidebar-nav {
            padding: 20px 0;
        }

        .nav-section {
            margin-bottom: 30px;
        }

        .nav-section-title {
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin: 0 20px 12px;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            color: var(--text-primary);
            text-decoration: none;
            transition: all 0.2s ease;
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 14px;
            border-left: 3px solid transparent;
        }

        .nav-item:hover {
            background: var(--background);
            border-left-color: var(--primary-color);
        }

        .nav-item.active {
            background: var(--background);
            border-left-color: var(--primary-color);
            color: var(--primary-color);
            font-weight: 500;
        }

        .nav-item .icon {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }

        .nav-item .label {
            flex: 1;
        }

        .nav-item .badge {
            background: var(--primary-color);
            color: white;
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 8px;
            min-width: 16px;
            text-align: center;
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            margin-left: 280px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header - simplified */
        .header {
            background: var(--surface);
            color: var(--text-primary);
            padding: 20px 0;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 90;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-title {
            font-size: 1.5em;
            font-weight: 600;
            color: var(--text-primary);
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Dark mode sidebar */
        [data-theme="dark"] .sidebar {
            background: var(--surface);
            border-right-color: var(--border);
        }

        [data-theme="dark"] .sidebar-header {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
        }

        [data-theme="dark"] .nav-item {
            color: var(--text-primary);
        }

        [data-theme="dark"] .nav-item:hover {
            background: var(--background);
        }

        [data-theme="dark"] .nav-item.active {
            background: var(--background);
            color: var(--primary-color);
        }

        /* Mobile responsive - hide sidebar on small screens */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }

            .sidebar.mobile-open {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
            }

            .mobile-menu-btn {
                display: block !important;
            }
            
            /* Mobile overlay backdrop */
            .mobile-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 150;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s ease;
            }
            
            .mobile-overlay.active {
                opacity: 1;
                visibility: visible;
            }
        }

        .mobile-menu-btn {
            display: none;
            background: none;
            border: none;
            font-size: 18px;
            color: var(--text-primary);
            cursor: pointer;
            padding: 8px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
            transform: translateY(-1px);
        }

        /* Search Toggle Animation */
        .search-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 90;
            padding: 30px 0;
        }

        .search-container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .search-container.hidden {
            opacity: 0;
            transform: translateY(-10px);
        }

        /* Category Filter Styles */
        .category-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 89;
            padding: 20px 0;
        }

        .category-container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .category-container.hidden {
            opacity: 0;
            transform: translateY(-10px);
        }

        .category-filter {
            max-width: 800px;
            margin: 0 auto;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .category-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.2em;
        }

        .category-close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .category-close-btn:hover {
            background: var(--border);
            color: var(--text-primary);
            transform: scale(1.1);
        }

        .category-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .category-chip {
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
        }

        .category-chip:hover {
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: white;
            transform: translateY(-2px);
        }

        .category-chip.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        .category-chip.show-all {
            background: var(--secondary-color);
            border-color: var(--secondary-color);
            color: white;
            font-weight: 600;
        }

        .category-chip.show-all:hover {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .category-count {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .category-chip:not(.active) .category-count {
            background: var(--border);
            color: var(--text-secondary);
        }

        /* Article Category Badge - HIDDEN by default */
        .article-category {
            display: none !important;
        }

        /* Dark mode category styles */
        [data-theme="dark"] .category-container {
            background: var(--surface);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .category-header h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .category-close-btn:hover {
            background: #21262d;
            color: var(--text-primary);
        }

        [data-theme="dark"] .category-chip {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .category-chip:hover {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        [data-theme="dark"] .category-chip.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        [data-theme="dark"] .category-chip:not(.active) .category-count {
            background: var(--border);
            color: var(--text-secondary);
        }

        .search-box {
            position: relative;
            max-width: 600px;
            margin: 0 auto;
        }

        .search-input {
            width: 100%;
            padding: 15px 50px 15px 20px;
            border: 2px solid var(--border);
            border-radius: 25px;
            font-size: 16px;
            background: var(--background);
            transition: border-color 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .search-close-btn {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .search-close-btn:hover {
            background: var(--border);
            color: var(--text-primary);
            transform: translateY(-50%) scale(1.1);
        }

        /* Status */
        .status {
            padding: 20px 0;
            text-align: center;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .status.loading {
            color: var(--secondary-color);
        }

        .status.error {
            color: #e74c3c;
        }

        .status.success {
            color: #27ae60;
        }

        /* Articles Grid - SMALLER TILES */
        .articles-section {
            padding: 40px 0;
            min-height: 60vh;
        }

        .articles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            /* REDUCED from 290px to 220px */
            gap: 18px;
            /* REDUCED from 24px to 18px */
            margin-top: 20px;
        }

        /* ORGANIC SHAPED TILES - SMALLER VERSION */
        .article-card {
            background: var(--surface);
            /* Organic rounded shape - different for each nth-child */
            border-radius: 32px 24px 32px 24px;
            overflow: visible;
            box-shadow: var(--shadow);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border: 1px solid var(--border);
            position: relative;
            display: flex;
            flex-direction: column;
            transform-origin: center center;
        }

        /* Varying organic shapes for visual interest */
        .article-card:nth-child(3n+1) {
            border-radius: 28px 36px 28px 36px;
        }

        .article-card:nth-child(3n+2) {
            border-radius: 35px 25px 35px 25px;
        }

        .article-card:nth-child(3n+3) {
            border-radius: 30px 30px 40px 20px;
        }

        .article-card:nth-child(4n+1) {
            border-radius: 40px 20px 30px 30px;
        }

        .article-card:nth-child(5n+1) {
            border-radius: 25px 35px 25px 35px;
        }

        .article-card:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-8px) scale(1.02) rotate(1deg);
            border-color: var(--primary-color);
        }

        .article-card:nth-child(even):hover {
            transform: translateY(-8px) scale(1.02) rotate(-1deg);
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
        }

        /* Organic shaped image area - SMALLER */
        .article-image {
            width: 100%;
            height: 100px;
            /* REDUCED from 140px to 100px */
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            /* REDUCED from 2em to 1.5em */
            color: white;
            position: relative;
            overflow: hidden;
            /* Inherit the card's organic border radius for top corners */
            border-radius: inherit;
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 16px;
        }

        .article-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.4s ease, opacity 0.3s ease;
        }

        .article-image:hover img {
            transform: scale(1.08);
        }

        /* Compact content area with organic feel - SMALLER */
        .article-content {
            padding: 15px;
            /* REDUCED from 20px to 15px */
            flex: 1;
            cursor: pointer;
            border-radius: 0 0 inherit inherit;
        }

        .article-title {
            font-size: 1em;
            /* REDUCED from 1.1em to 1em */
            font-weight: 600;
            margin-bottom: 6px;
            /* REDUCED from 8px to 6px */
            line-height: 1.3;
            color: var(--text-primary);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-excerpt {
            color: var(--text-secondary);
            font-size: 0.8em;
            /* REDUCED from 0.9em to 0.8em */
            line-height: 1.4;
            margin-bottom: 10px;
            /* REDUCED from 12px to 10px */
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
            /* REDUCED from 8px to 6px */
            color: var(--text-secondary);
            font-size: 0.75em;
            /* REDUCED from 0.8em to 0.75em */
            margin-bottom: 6px;
            /* REDUCED from 8px to 6px */
        }

        .article-domain {
            font-weight: 500;
        }

        .article-date {
            opacity: 0.8;
        }

        .article-stats {
            display: flex;
            gap: 10px;
            /* REDUCED from 12px to 10px */
            font-size: 0.7em;
            /* REDUCED from 0.75em to 0.7em */
            color: var(--text-secondary);
        }

        /* Floating organic action buttons - SMALLER */
        .article-actions {
            position: absolute;
            top: 10px;
            /* REDUCED from 15px to 10px */
            right: 10px;
            /* REDUCED from 15px to 10px */
            display: flex;
            gap: 6px;
            /* REDUCED from 8px to 6px */
            opacity: 0 !important;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid var(--border);
            border-radius: 50%;
            /* Circular buttons for organic feel */
            padding: 8px;
            /* REDUCED from 12px to 8px */
            cursor: pointer;
            font-size: 14px;
            /* REDUCED from 16px to 14px */
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            min-width: 36px;
            /* REDUCED from 44px to 36px */
            height: 36px;
            /* REDUCED from 44px to 36px */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn:hover {
            transform: translateY(-4px) scale(1.15);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
            border-radius: 40% 60% 70% 30%;
        }

        .read-btn:hover {
            background: #e3f2fd;
            border-color: #2196f3;
            border-radius: 60% 40% 30% 70%;
        }

        .export-btn:hover {
            background: #e8f5e8;
            border-color: #4caf50;
            border-radius: 30% 70% 60% 40%;
        }

        .refresh-image-btn:hover {
            background: #fff3e0;
            border-color: #ff9800;
            border-radius: 40% 60% 40% 60%;
        }

        .delete-btn {
            color: #f44336;
        }

        .delete-btn:hover {
            background: #ffebee;
            border-color: #f44336;
            color: #d32f2f;
            border-radius: 70% 30% 40% 60%;
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
        }

        body.test-mode .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
            background: rgba(255, 255, 0, 0.1);
            border: 2px dashed #ff9800;
            border-radius: 20px;
            padding: 5px;
        }

        .article-actions:hover {
            opacity: 1 !important;
            visibility: visible !important;
        }

        /* Reader View */
        .reader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            overflow-y: auto;
        }

        .reader-overlay.active {
            display: block;
        }

        .reader-container {
            max-width: 800px;
            margin: 40px auto;
            background: var(--surface);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.3);
        }

        .reader-header {
            padding: 30px;
            border-bottom: 1px solid var(--border);
            background: var(--background);
        }

        .reader-title {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 15px;
            line-height: 1.3;
        }

        .reader-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .reader-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .reader-content {
            padding: 40px;
            font-size: 1.1em;
            line-height: 1.8;
            max-width: none;
        }

        .reader-content h1,
        .reader-content h2,
        .reader-content h3 {
            margin: 30px 0 15px;
            color: var(--text-primary);
        }

        .reader-content p {
            margin-bottom: 20px;
        }

        .reader-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
        }

        .reader-content blockquote {
            border-left: 4px solid var(--primary-color);
            margin: 20px 0;
            padding: 15px 20px;
            background: var(--background);
            font-style: italic;
        }

        .close-reader {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-reader:hover {
            border-radius: 30% 70% 70% 30%;
            transform: scale(1.1);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Cache indicator */
        .cache-indicator {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            z-index: 5;
        }

        .cache-indicator.cached {
            background: rgba(39, 174, 96, 0.8);
        }

        .cache-indicator.fresh {
            background: rgba(52, 152, 219, 0.8);
        }

        /* NEW: Enhanced cache indicator styles */
        .cache-indicator.synced {
            background: rgba(76, 175, 80, 0.8);
            color: white;
        }

        .cache-indicator.fallback {
            background: rgba(255, 152, 0, 0.8);
            color: white;
        }

        .cache-indicator.metadata {
            background: rgba(103, 58, 183, 0.8);
            color: white;
        }

        .cache-indicator.error {
            background: rgba(244, 67, 54, 0.8);
            color: white;
        }

        /* Enhanced Mobile Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 0 12px;
            }

            /* Sidebar mobile styles */
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 200;
            }

            .sidebar.mobile-open {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
            }

            .mobile-menu-btn {
                display: block !important;
            }

            /* Header improvements for mobile */
            .header {
                padding: 15px 0;
            }

            .header-title {
                font-size: 1.3em;
            }

            .btn {
                padding: 8px 16px;
                font-size: 13px;
                border-radius: 20px;
            }

            /* Search improvements */
            .search-container {
                padding: 20px 0;
            }

            .search-input {
                font-size: 16px !important;
                /* Prevent zoom */
                padding: 12px 45px 12px 16px;
                border-radius: 20px;
            }

            .search-close-btn {
                right: 12px;
                width: 28px;
                height: 28px;
                font-size: 16px;
            }

            /* Category Filter Mobile */
            .category-container {
                padding: 15px 0;
            }

            .category-header h3 {
                font-size: 1.1em;
            }

            .category-chips {
                gap: 8px;
            }

            .category-chip {
                padding: 6px 12px;
                font-size: 0.8em;
                border-radius: 16px;
            }

            .category-count {
                font-size: 0.7em;
                padding: 1px 4px;
            }

            /* Status bar */
            .status {
                padding: 15px 0;
                font-size: 14px;
                line-height: 1.4;
            }

            /* MAJOR MOBILE GRID FIX */
            .articles-section {
                padding: 20px 0;
            }

            .articles-grid {
                display: block;
                /* Use block layout instead of grid for better mobile performance */
                margin-top: 15px;
            }

            /* COMPLETELY REDESIGNED MOBILE CARDS */
            .article-card {
                display: block !important;
                width: 100% !important;
                margin-bottom: 20px !important;
                border-radius: 20px !important;
                overflow: hidden;
                background: var(--surface);
                border: 1px solid var(--border);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                transform: none !important;
                animation: none !important;
            }

            .article-card:hover {
                transform: none !important;
                box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
            }

            /* LARGER MOBILE IMAGE */
            .article-image {
                width: 100% !important;
                height: 140px !important;
                /* Increased from 100px */
                border-radius: 20px 20px 0 0 !important;
                position: relative;
            }

            /* MUCH LARGER TEXT ON MOBILE */
            .article-content {
                padding: 20px !important;
                cursor: pointer;
            }

            .article-title {
                font-size: 1.25em !important;
                /* Much larger - was 1em */
                font-weight: 600;
                margin-bottom: 10px !important;
                line-height: 1.4 !important;
                color: var(--text-primary);
                display: block !important;
                /* Remove text clamping on mobile */
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-excerpt {
                font-size: 1em !important;
                /* Much larger - was 0.8em */
                line-height: 1.5 !important;
                margin-bottom: 15px !important;
                color: var(--text-secondary);
                display: block !important;
                /* Remove text clamping on mobile */
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-meta {
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-wrap: wrap;
                gap: 8px;
                color: var(--text-secondary);
                font-size: 0.9em !important;
                /* Larger - was 0.75em */
                margin-bottom: 10px;
            }

            .article-stats {
                display: flex;
                gap: 15px;
                font-size: 0.85em !important;
                /* Larger - was 0.7em */
                color: var(--text-secondary);
                margin-bottom: 10px;
            }

            /* MOBILE-OPTIMIZED ACTION BUTTONS */
            .article-actions {
                position: static !important;
                opacity: 1 !important;
                visibility: visible !important;
                display: flex !important;
                justify-content: center;
                gap: 12px;
                padding: 15px 20px;
                background: var(--background);
                border-radius: 0;
                margin: 0;
                border-top: 1px solid var(--border);
            }

            .action-btn {
                min-width: 45px !important;
                height: 45px !important;
                font-size: 18px !important;
                border-radius: 50% !important;
                padding: 0;
                background: var(--surface);
                border: 2px solid var(--border);
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .action-btn:hover,
            .action-btn:active {
                border-radius: 50% !important;
                transform: scale(1.05);
                background: var(--primary-color);
                color: white;
                border-color: var(--primary-color);
            }

            /* MOBILE READER IMPROVEMENTS */
            .reader-overlay {
                padding: 0;
            }

            .reader-container {
                margin: 0 !important;
                border-radius: 0 !important;
                height: 100vh;
                max-width: none;
                display: flex;
                flex-direction: column;
            }

            .reader-header {
                padding: 20px;
                border-radius: 0;
                flex-shrink: 0;
            }

            .reader-title {
                font-size: 1.4em !important;
                line-height: 1.3;
                margin-bottom: 15px;
            }

            .reader-meta {
                font-size: 0.9em;
                gap: 15px;
            }

            .reader-content {
                padding: 20px;
                font-size: 1.1em !important;
                /* Larger reading text */
                line-height: 1.7 !important;
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                /* Smooth scrolling on iOS */
            }

            .close-reader {
                top: 15px;
                right: 15px;
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            /* MOBILE SEARCH */
            .search-input {
                font-size: 16px !important;
                /* Prevent zoom */
                padding: 14px 50px 14px 18px;
            }

            /* EMPTY STATE */
            .empty-state {
                padding: 40px 20px;
            }

            .empty-state-icon {
                font-size: 3em;
                margin-bottom: 15px;
            }

            .empty-state h3 {
                font-size: 1.3em;
                margin-bottom: 8px;
            }

            .empty-state p {
                font-size: 1em;
                line-height: 1.5;
            }
        }

        /* Extra small screens (very small phones) */
        @media (max-width: 480px) {
            .article-title {
                font-size: 1.15em !important;
            }

            .article-excerpt {
                font-size: 0.95em !important;
            }

            .article-content {
                padding: 16px !important;
            }

            .header-actions {
                gap: 6px;
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        /* Firefox Mobile Specific Fixes */
        @-moz-document url-prefix() {
            @media (max-width: 768px) {
                .article-card {
                    will-change: auto;
                    /* Improve performance on Firefox mobile */
                }

                .articles-grid {
                    transform: translateZ(0);
                    /* Force hardware acceleration */
                }

                .search-input {
                    -moz-appearance: none;
                    /* Remove Firefox mobile styling */
                }

                .btn {
                    -moz-appearance: none;
                }
            }
        }

        /* Connection Status */
        .connection-status {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 15px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .connection-status.connected {
            border-color: #27ae60;
            background: #d4edda;
        }

        .connection-status.disconnected {
            border-color: #e74c3c;
            background: #f8d7da;
        }

        /* Additional organic elements */
        @keyframes float {

            0%,
            100% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-6px);
            }
        }

        /* Background pattern animation for generated placeholders */
        @keyframes floatPattern {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        /* Shimmer animation for loading placeholders */
        @keyframes shimmer {
            0% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.6;
            }
        }

        .article-card:nth-child(7n+1) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 0s;
        }

        .article-card:nth-child(7n+2) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 0.5s;
        }

        .article-card:nth-child(7n+3) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 1s;
        }

        /* Organic gradient backgrounds for images */
        .article-image:nth-child(odd) {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .article-image:nth-child(3n+1) {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .article-image:nth-child(3n+2) {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .article-image:nth-child(3n+3) {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }

        .article-image:nth-child(5n+1) {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }
    </style>
</head>

<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    üìö MyPocket Web Reader
                </div>
                <div class="header-actions">
                    <button id="connectBtn" class="btn btn-primary">
                        <span id="connectIcon">üîê</span>
                        <span id="connectText">Secure Connect</span>
                    </button>
                    <button id="refreshBtn" class="btn btn-secondary" style="display: none;">
                        <span>üîÑ</span> Refresh
                    </button>
                    <button id="searchToggleBtn" class="btn btn-secondary" onclick="webReader.toggleSearch()">
                        <span>üîç</span> Search
                    </button>
                    <button id="categoriesBtn" class="btn btn-secondary" onclick="webReader.toggleCategoryFilter()">
                        <span>üè∑Ô∏è</span> Categories
                    </button>
                    <button id="clearCacheBtn" class="btn btn-secondary" onclick="webReader.clearImageCache()">
                        <span>üóëÔ∏è</span> Clear Cache
                    </button>
                    <button id="syncBtn" class="btn btn-secondary" onclick="webReader.forceSyncImages()"
                        style="display: none;">
                        <span>üîÑ</span> Sync Images
                    </button>
                    <button id="retryFailedBtn" class="btn btn-secondary" onclick="webReader.retryFailedImages()"
                        style="display: none;">
                        <span>üîÑ</span> Retry Failed
                    </button>
                    <button id="helpBtn" class="btn btn-secondary" onclick="webReader.showImageHelp()">
                        <span>‚ùì</span> Image Help
                    </button>
                    <button id="debugBtn" class="btn btn-secondary" onclick="webReader.showDebugInfo()">
                        <span>üîß</span> Debug
                    </button>
                    <button id="testBtn" class="btn btn-secondary" onclick="webReader.toggleTestMode()">
                        <span>üëÅÔ∏è</span> Show Buttons
                    </button>
                    <button id="darkModeBtn" class="btn btn-secondary" onclick="webReader.toggleDarkMode()">
                        <span>üåô</span> Dark Mode
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Search (Initially Hidden) -->
    <section class="search-container" id="searchContainer" style="display: none;">
        <div class="container">
            <div class="search-box">
                <input type="text" id="searchInput" class="search-input" placeholder="Search your saved articles..."
                    autocomplete="off">
                <button class="search-close-btn" onclick="webReader.toggleSearch()" title="Close search">‚úï</button>
            </div>
        </div>
    </section>

    <!-- Enhanced AI Category Filter (Initially Hidden) -->
    <section class="category-container" id="categoryContainer" style="display: none;">
        <div class="container">
            <div class="category-filter">
                <div class="category-header">
                    <h3>üìÇ Filter by Category</h3>
                    <button class="category-close-btn" onclick="webReader.toggleCategoryFilter()"
                        title="Close categories">‚úï</button>
                </div>
                <div class="category-chips" id="categoryChips">
                    <!-- AI-generated categories will be populated here -->
                </div>
            </div>
        </div>
    </section>

    <!-- Status -->
    <div class="status" id="status">
        Connect to OneDrive to view your saved articles
    </div>

    <!-- Articles -->
    <section class="articles-section">
        <div class="container">
            <div id="articlesContainer">
                <div class="empty-state">
                    <div class="empty-state-icon">ü§ñ</div>
                    <h3>Welcome to MyPocket AI Reader</h3>
                    <p>Connect to OneDrive to access your saved articles with intelligent AI categorization!</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Reader Overlay -->
    <div class="reader-overlay" id="readerOverlay">
        <div class="reader-container">
            <button class="close-reader" id="closeReader">‚úï</button>
            <div class="reader-header">
                <h1 class="reader-title" id="readerTitle">Article Title</h1>
                <div class="reader-meta" id="readerMeta">
                    <span>üìÖ <span id="readerDate">Date</span></span>
                    <span>üåê <span id="readerDomain">Domain</span></span>
                    <span>‚è±Ô∏è <span id="readerTime">5 min read</span></span>
                </div>
                <div class="reader-actions">
                    <button class="btn btn-secondary" id="openOriginal">
                        üîó Open Original
                    </button>
                </div>
            </div>
            <div class="reader-content" id="readerContent">
                Article content will appear here...
            </div>
        </div>
    </div>

    <script>
        class MyPocketWebReader {
            constructor() {
                this.clientId = '436e8796-8c40-47c3-9ad5-b8882f3ef7f7';
                this.redirectUri = this.getRedirectUri();
                console.log('üîµ Redirect URI:', this.redirectUri);

                this.accessToken = null;
                this.articles = [];
                this.currentArticle = null;
                this.currentDisplayedArticles = []; // Track what's currently displayed
                this.failedImages = new Set(); // Track articles with failed images

                // Enhanced AI-powered categorization system
                this.categories = new Map(); // Store category counts
                this.activeCategory = null; // Currently selected category filter
                this.dynamicCategories = new Map(); // AI-discovered categories
                this.categoryKeywords = this.initializeCategoryKeywords();
                this.stopWords = this.initializeStopWords();
                
                // AI categorization settings
                this.enableDynamicCategories = true;
                this.minCategoryConfidence = 40; // Increased threshold for better accuracy
                this.maxCategories = 15;

                // Image cache system
                this.imageCache = new Map();
                this.cacheKey = 'mypocket_image_cache';
                this.cacheExpiryDays = 7; // Cache images for 7 days

                // Cross-device image storage
                this.storeImagesInBackup = true; // Enable cross-device image storage
                this.maxImageSizeKB = 500; // Limit to prevent huge backups
                this.cacheSaveTimeout = null; // For debounced saves

                // PKCE-specific properties
                this.codeVerifier = null;
                this.codeChallenge = null;
                this.state = null;

                this.init();
            }

            getRedirectUri() {
                const currentUrl = window.location.href;
                const baseUrl = currentUrl.split('#')[0].split('?')[0]; // Remove both fragment and query

                if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {
                    return baseUrl;
                } else {
                    return window.location.origin + window.location.pathname;
                }
            }

            // ===== ENHANCED AI CATEGORIZATION SYSTEM =====

            // Initialize stop words for better text analysis
            initializeStopWords() {
                return new Set([
                    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
                    'how', 'what', 'why', 'when', 'where', 'who', 'which', 'this', 'that', 'these', 'those',
                    'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did',
                    'will', 'would', 'could', 'should', 'may', 'might', 'can', 'must', 'shall', 'here', 'there',
                    'up', 'down', 'out', 'off', 'over', 'under', 'again', 'further', 'then', 'once', 'now',
                    'very', 'too', 'just', 'only', 'own', 'same', 'so', 'than', 'too', 'any', 'some', 'all',
                    'each', 'more', 'most', 'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than',
                    'into', 'from', 'they', 'them', 'their', 'we', 'us', 'our', 'you', 'your', 'he', 'him',
                    'his', 'she', 'her', 'it', 'its', 'me', 'my', 'i', 'get', 'got', 'make', 'made', 'take',
                    'took', 'see', 'saw', 'go', 'went', 'come', 'came', 'know', 'knew', 'think', 'thought',
                    'say', 'said', 'tell', 'told', 'ask', 'asked', 'give', 'gave', 'find', 'found', 'work',
                    'worked', 'call', 'called', 'try', 'tried', 'need', 'needed', 'feel', 'felt', 'become',
                    'became', 'leave', 'left', 'put', 'putting', 'mean', 'meant', 'keep', 'kept', 'let',
                    'begin', 'began', 'seem', 'seemed', 'help', 'helped', 'talk', 'talked', 'turn', 'turned',
                    'start', 'started', 'show', 'showed', 'hear', 'heard', 'play', 'played', 'run', 'ran',
                    'move', 'moved', 'live', 'lived', 'believe', 'believed', 'bring', 'brought', 'happen',
                    'happened', 'write', 'wrote', 'provide', 'provided', 'sit', 'sat', 'stand', 'stood',
                    'lose', 'lost', 'pay', 'paid', 'meet', 'met', 'include', 'included', 'continue', 'continued',
                    'set', 'follow', 'followed', 'around', 'between', 'during', 'before', 'after', 'above',
                    'below', 'against', 'through', 'while', 'without', 'within', 'along', 'among', 'across',
                    'behind', 'beyond', 'since', 'until', 'unless', 'although', 'because', 'however',
                    'therefore', 'moreover', 'furthermore', 'nevertheless', 'meanwhile', 'otherwise',
                    'article', 'articles', 'post', 'posts', 'blog', 'blogs', 'page', 'pages', 'website',
                    'site', 'link', 'links', 'read', 'reading', 'content', 'text', 'information', 'info'
                ]);
            }

            // Enhanced category keywords with semantic understanding
            initializeCategoryKeywords() {
                return {
                    'Technology': {
                        icon: 'üíª',
                        priority: 'high',
                        keywords: [
                            'programming', 'code', 'coding', 'development', 'developer', 'software', 'algorithm',
                            'javascript', 'python', 'java', 'react', 'nodejs', 'api', 'database', 'sql',
                            'frontend', 'backend', 'fullstack', 'framework', 'library', 'github', 'git',
                            'open source', 'debugging', 'testing', 'deployment', 'devops', 'cloud',
                            'artificial intelligence', 'machine learning', 'ai', 'ml', 'blockchain',
                            'cryptocurrency', 'bitcoin', 'ethereum', 'nft', 'metaverse', 'vr', 'ar',
                            'virtual reality', 'augmented reality', 'iot', 'internet of things',
                            'mobile', 'android', 'ios', 'web development', 'responsive', 'pwa',
                            'app development', 'xamarin', 'flutter', 'react native', 'tech', 'digital'
                        ],
                        domains: ['github.com', 'stackoverflow.com', 'dev.to', 'techcrunch.com', 'theverge.com', 
                                'arstechnica.com', 'wired.com', 'hacker-news.firebaseio.com', 'news.ycombinator.com',
                                'medium.com/tag/technology', 'freecodecamp.org', 'codepen.io']
                    },
                    'Politics': {
                        icon: 'üèõÔ∏è',
                        priority: 'high',
                        keywords: [
                            'politics', 'political', 'government', 'election', 'voting', 'democracy', 'republican',
                            'democratic', 'congress', 'senate', 'house', 'president', 'prime minister', 'minister',
                            'policy', 'legislation', 'law', 'bill', 'campaign', 'candidate', 'politician',
                            'parliament', 'capitol', 'white house', 'administration', 'cabinet', 'supreme court',
                            'judicial', 'executive', 'legislative', 'impeachment', 'scandal', 'corruption',
                            'debate', 'rally', 'protest', 'activism', 'conservative', 'liberal', 'progressive',
                            'libertarian', 'socialist', 'communist', 'fascist', 'authoritarian', 'totalitarian',
                            'diplomatic', 'diplomacy', 'international relations', 'foreign policy', 'treaty',
                            'sanctions', 'embargo', 'summit', 'nato', 'un', 'united nations', 'eu', 'brexit'
                        ],
                        domains: ['politico.com', 'washingtonpost.com/politics', 'cnn.com/politics', 
                                'foxnews.com/politics', 'bbc.com/news/politics', 'reuters.com/politics',
                                'apnews.com/politics', 'npr.org/politics', 'thehill.com', 'rollcall.com']
                    },
                    'Business': {
                        icon: 'üíº',
                        priority: 'high',
                        keywords: [
                            'business', 'startup', 'entrepreneur', 'entrepreneurship', 'finance', 'investment',
                            'venture capital', 'vc', 'funding', 'ipo', 'stock market', 'trading', 'economics',
                            'marketing', 'sales', 'strategy', 'management', 'leadership', 'ceo', 'founder',
                            'company', 'corporation', 'revenue', 'profit', 'growth', 'market share',
                            'branding', 'advertising', 'digital marketing', 'seo', 'sem', 'social media marketing',
                            'customer acquisition', 'retention', 'conversion', 'analytics', 'metrics',
                            'productivity', 'workflow', 'automation', 'efficiency', 'remote work',
                            'team management', 'project management', 'agile', 'scrum', 'collaboration'
                        ],
                        domains: ['linkedin.com', 'forbes.com', 'bloomberg.com', 'businessinsider.com', 
                                'harvard.business.review', 'wsj.com', 'ft.com', 'entrepreneur.com',
                                'inc.com', 'fastcompany.com', 'techcrunch.com', 'crunchbase.com']
                    },
                    'Science': {
                        icon: 'üî¨',
                        priority: 'high',
                        keywords: [
                            'science', 'research', 'study', 'experiment', 'discovery', 'theory', 'hypothesis',
                            'biology', 'chemistry', 'physics', 'mathematics', 'statistics', 'data science',
                            'medicine', 'medical', 'clinical', 'pharmaceutical', 'drug', 'vaccine',
                            'climate', 'environment', 'sustainability', 'renewable energy', 'solar', 'wind',
                            'space', 'astronomy', 'nasa', 'spacex', 'mars', 'rocket', 'satellite',
                            'genetics', 'dna', 'genome', 'crispr', 'biotechnology', 'biotech',
                            'neuroscience', 'brain', 'psychology', 'cognitive', 'mental health',
                            'quantum', 'particle', 'energy', 'nuclear', 'microscopy', 'telescope'
                        ],
                        domains: ['arxiv.org', 'nature.com', 'science.org', 'plos.org', 'pubmed.ncbi.nlm.nih.gov',
                                'scientificamerican.com', 'newscientist.com', 'sciencedaily.com', 'cell.com']
                    },
                    'Design': {
                        icon: 'üé®',
                        priority: 'medium',
                        keywords: [
                            'design', 'ui', 'ux', 'user experience', 'user interface', 'visual design',
                            'graphic design', 'web design', 'product design', 'interaction design',
                            'creative', 'art', 'illustration', 'typography', 'font', 'color', 'palette',
                            'layout', 'composition', 'grid', 'wireframe', 'prototype', 'mockup',
                            'figma', 'sketch', 'adobe', 'photoshop', 'illustrator', 'indesign',
                            'branding', 'logo', 'identity', 'brand', 'aesthetic', 'minimalism',
                            'accessibility', 'usability', 'human centered', 'design thinking',
                            'portfolio', 'dribbble', 'behance', 'awwwards'
                        ],
                        domains: ['dribbble.com', 'behance.net', 'medium.com/tag/design', 'uxdesign.cc',
                                'smashingmagazine.com', 'designmodo.com', 'awwwards.com', 'uxplanet.org']
                    },
                    'News': {
                        icon: 'üì∞',
                        priority: 'medium',
                        keywords: [
                            'news', 'breaking news', 'current events', 'journalism', 'reporter', 'media',
                            'international', 'global', 'world', 'country', 'nation', 'crisis', 'conflict', 
                            'war', 'peace', 'security', 'terrorism', 'social', 'society', 'culture', 
                            'community', 'public', 'civil rights', 'breaking', 'latest', 'update', 'report'
                        ],
                        domains: ['bbc.com', 'cnn.com', 'nytimes.com', 'washingtonpost.com', 'guardian.co.uk',
                                'reuters.com', 'ap.org', 'npr.org', 'wsj.com', 'ft.com', 'economist.com']
                    },
                    'Health & Fitness': {
                        icon: 'üè•',
                        priority: 'high',
                        keywords: [
                            'health', 'healthy', 'wellness', 'fitness', 'exercise', 'workout', 'training',
                            'nutrition', 'diet', 'food', 'eating', 'weight loss', 'muscle', 'strength',
                            'cardio', 'running', 'yoga', 'meditation', 'mindfulness', 'mental health',
                            'medical', 'medicine', 'doctor', 'physician', 'patient', 'treatment',
                            'therapy', 'rehabilitation', 'recovery', 'surgery', 'hospital', 'clinic',
                            'disease', 'illness', 'symptoms', 'diagnosis', 'prevention', 'immune',
                            'vitamin', 'supplement', 'organic', 'natural', 'holistic', 'alternative'
                        ],
                        domains: ['mayoclinic.org', 'webmd.com', 'healthline.com', 'nih.gov', 'who.int',
                                'medicalnewstoday.com', 'everydayhealth.com', 'health.com', 'myfitnesspal.com']
                    },
                    'Education': {
                        icon: 'üéì',
                        priority: 'medium',
                        keywords: [
                            'education', 'learning', 'teaching', 'teacher', 'student', 'school', 'university',
                            'college', 'course', 'class', 'lesson', 'tutorial', 'training', 'workshop',
                            'academic', 'academia', 'research', 'study', 'exam', 'test', 'grade',
                            'degree', 'diploma', 'certificate', 'certification', 'skill', 'knowledge',
                            'online learning', 'elearning', 'mooc', 'distance learning', 'homeschool',
                            'curriculum', 'pedagogy', 'educational technology', 'edtech'
                        ],
                        domains: ['coursera.org', 'edx.org', 'khanacademy.org', 'udemy.com', 'wikipedia.org',
                                'mit.edu', 'stanford.edu', 'harvard.edu', 'yale.edu', 'oxford.ac.uk']
                    },
                    'Entertainment': {
                        icon: 'üé¨',
                        priority: 'medium',
                        keywords: [
                            'entertainment', 'movie', 'film', 'cinema', 'tv', 'television', 'show', 'series',
                            'streaming', 'netflix', 'disney', 'hulu', 'amazon prime', 'hbo', 'youtube',
                            'music', 'song', 'album', 'artist', 'musician', 'concert', 'festival',
                            'spotify', 'apple music', 'podcast', 'gaming', 'video game', 'game',
                            'esports', 'twitch', 'steam', 'playstation', 'xbox', 'nintendo',
                            'celebrity', 'actor', 'actress', 'director', 'producer', 'hollywood',
                            'review', 'rating', 'critic', 'trailer', 'release', 'box office'
                        ],
                        domains: ['youtube.com', 'netflix.com', 'spotify.com', 'imdb.com', 'ign.com',
                                'gamespot.com', 'polygon.com', 'variety.com', 'hollywoodreporter.com']
                    },
                    'Travel': {
                        icon: '‚úàÔ∏è',
                        priority: 'medium',
                        keywords: [
                            'travel', 'traveling', 'trip', 'vacation', 'holiday', 'journey', 'adventure',
                            'tourism', 'tourist', 'destination', 'explore', 'exploration', 'discovery',
                            'flight', 'airline', 'airport', 'hotel', 'accommodation', 'booking',
                            'backpacking', 'solo travel', 'family travel', 'business travel',
                            'culture', 'cultural', 'local', 'tradition', 'heritage', 'history',
                            'guide', 'guidebook', 'itinerary', 'recommendation', 'review',
                            'country', 'city', 'region', 'continent', 'international', 'domestic'
                        ],
                        domains: ['tripadvisor.com', 'booking.com', 'airbnb.com', 'lonelyplanet.com',
                                'expedia.com', 'kayak.com', 'skyscanner.com', 'nationalgeographic.com']
                    },
                    'Food & Cooking': {
                        icon: 'üç≥',
                        priority: 'medium',
                        keywords: [
                            'food', 'cooking', 'recipe', 'chef', 'cuisine', 'culinary', 'kitchen',
                            'ingredient', 'meal', 'dish', 'restaurant', 'dining', 'eat', 'eating',
                            'baking', 'pastry', 'dessert', 'cake', 'bread', 'healthy eating',
                            'vegan', 'vegetarian', 'gluten free', 'organic', 'farm to table',
                            'wine', 'beer', 'cocktail', 'beverage', 'drink', 'coffee', 'tea',
                            'taste', 'flavor', 'spice', 'herb', 'seasoning', 'sauce', 'marinade'
                        ],
                        domains: ['allrecipes.com', 'foodnetwork.com', 'epicurious.com', 'bonappetit.com',
                                'seriouseats.com', 'tasteofhome.com', 'food.com', 'yummly.com']
                    },
                    'Sports': {
                        icon: '‚öΩ',
                        priority: 'medium',
                        keywords: [
                            'sports', 'sport', 'football', 'soccer', 'basketball', 'baseball', 'tennis',
                            'golf', 'hockey', 'olympics', 'athletic', 'athlete', 'team', 'player',
                            'game', 'match', 'tournament', 'championship', 'league', 'season',
                            'fitness', 'training', 'workout', 'exercise', 'competition', 'competitive',
                            'coaching', 'strategy', 'performance', 'statistics', 'score', 'win', 'loss'
                        ],
                        domains: ['espn.com', 'sports.com', 'bleacherreport.com', 'nfl.com', 'nba.com',
                                'mlb.com', 'nhl.com', 'fifa.com', 'olympic.org', 'si.com']
                    },
                    'Finance': {
                        icon: 'üí∞',
                        priority: 'high',
                        keywords: [
                            'finance', 'financial', 'money', 'investment', 'investing', 'investor',
                            'stock', 'bond', 'portfolio', 'trading', 'cryptocurrency', 'bitcoin',
                            'blockchain', 'fintech', 'banking', 'bank', 'credit', 'debt', 'loan',
                            'mortgage', 'insurance', 'retirement', '401k', 'ira', 'pension',
                            'budget', 'budgeting', 'saving', 'spending', 'tax', 'taxes',
                            'wealth', 'rich', 'millionaire', 'financial planning', 'advisor'
                        ],
                        domains: ['bloomberg.com', 'reuters.com', 'marketwatch.com', 'yahoo.finance',
                                'wsj.com', 'ft.com', 'cnbc.com', 'thestreet.com', 'morningstar.com']
                    }
                };
            }

            // Advanced AI-powered categorization
            categorizeArticle(article) {
                const title = (article.title || '').toLowerCase();
                const excerpt = (article.excerpt || '').toLowerCase();
                const url = (article.url || '').toLowerCase();
                const domain = this.getDomain(article.url).toLowerCase();
                const content = this.getArticleContentForAnalysis(article).toLowerCase();

                // Combine all text for analysis
                const fullText = `${title} ${excerpt} ${content}`.substring(0, 5000);
                
                console.log(`ü§ñ Auto-categorizing: "${article.title.substring(0, 50)}..."`);

                // Extract keywords using TF-IDF-like algorithm
                const extractedKeywords = this.extractKeywords(fullText);
                
                // Score categories using multiple algorithms
                const categoryScores = this.calculateCategoryScores(article, fullText, extractedKeywords, domain, url);
                
                // Find best category with confidence score
                const result = this.selectBestCategory(categoryScores);
                
                // Store results
                article.category = result.category;
                article.categoryScore = result.score;
                article.categoryConfidence = result.confidence;
                article.extractedKeywords = extractedKeywords.slice(0, 10); // Store top keywords
                
                console.log(`üéØ Result: "${result.category}" (confidence: ${result.confidence}, score: ${Math.round(result.score)})`);
                
                return result.category;
            }

            // Extract meaningful keywords using frequency analysis
            extractKeywords(text) {
                const words = text.toLowerCase()
                    .replace(/[^\w\s]/g, ' ')
                    .split(/\s+/)
                    .filter(word => word.length > 3 && !this.stopWords.has(word));

                const wordFreq = {};
                words.forEach(word => {
                    wordFreq[word] = (wordFreq[word] || 0) + 1;
                });

                // Calculate TF-IDF-like score (simplified)
                const totalWords = words.length;
                const keywordScores = [];

                Object.entries(wordFreq).forEach(([word, freq]) => {
                    // Simple TF score
                    const tf = freq / totalWords;
                    
                    // Boost score for longer, more specific words
                    const lengthBoost = Math.min(word.length / 8, 2);
                    
                    // Boost technical terms and proper nouns
                    const techBoost = this.isTechnicalTerm(word) ? 1.5 : 1;
                    
                    const score = tf * lengthBoost * techBoost * freq;
                    
                    if (score > 0.001 && freq > 1) {
                        keywordScores.push({ word, score, freq });
                    }
                });

                return keywordScores
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 20)
                    .map(item => item.word);
            }

            // Check if a word is technical/important
            isTechnicalTerm(word) {
                const technicalPatterns = [
                    /^[a-z]+ing$/, // -ing words (programming, learning, etc.)
                    /^[a-z]+tion$/, // -tion words (education, information, etc.)
                    /^[a-z]+ment$/, // -ment words (development, management, etc.)
                    /^[a-z]+ness$/, // -ness words (business, fitness, etc.)
                    /^[a-z]+ity$/, // -ity words (security, quality, etc.)
                    /^[a-z]+ology$/, // -ology words (technology, psychology, etc.)
                ];

                return technicalPatterns.some(pattern => pattern.test(word)) ||
                       word.includes('tech') || word.includes('science') || word.includes('digital');
            }

            // Calculate sophisticated category scores with improved accuracy
            calculateCategoryScores(article, fullText, extractedKeywords, domain, url) {
                const scores = new Map();
                const title = article.title.toLowerCase();

                for (const [categoryName, categoryData] of Object.entries(this.categoryKeywords)) {
                    let score = 0;
                    let matches = [];

                    // 1. Domain matching (highest weight - 150 points)
                    if (categoryData.domains.some(d => domain.includes(d))) {
                        score += 150;
                        matches.push(`domain:${domain}`);
                    }

                    // 2. Title exact word matching (very high weight - 100 points per match)
                    const titleWords = title.split(/\s+/);
                    for (const keyword of categoryData.keywords) {
                        const keywordLower = keyword.toLowerCase();
                        
                        // Exact title word match
                        if (titleWords.includes(keywordLower)) {
                            score += 100;
                            matches.push(`title-exact:${keyword}`);
                        }
                        // Title contains keyword
                        else if (title.includes(keywordLower)) {
                            score += 60;
                            matches.push(`title-contains:${keyword}`);
                        }
                    }

                    // 3. Direct keyword matching in extracted keywords (high weight - 80 points)
                    for (const keyword of categoryData.keywords) {
                        if (extractedKeywords.includes(keyword.toLowerCase())) {
                            score += 80;
                            matches.push(`extracted:${keyword}`);
                        }
                    }

                    // 4. Content matching with frequency weighting (medium weight - 5-30 points)
                    for (const keyword of categoryData.keywords) {
                        const regex = new RegExp(`\\b${keyword.toLowerCase()}\\b`, 'gi');
                        const contentMatches = fullText.match(regex);
                        if (contentMatches) {
                            // Diminishing returns for multiple matches
                            const contextScore = Math.min(contentMatches.length * 5, 30);
                            score += contextScore;
                            matches.push(`content:${keyword}(${contentMatches.length}x)`);
                        }
                    }

                    // 5. URL path analysis (low weight - 10 points)
                    for (const keyword of categoryData.keywords) {
                        if (url.includes(keyword.toLowerCase())) {
                            score += 10;
                            matches.push(`url:${keyword}`);
                        }
                    }

                    // 6. Compound keyword bonus for exact phrase matches
                    const compoundKeywords = categoryData.keywords.filter(k => k.includes(' '));
                    for (const compound of compoundKeywords) {
                        if (title.includes(compound.toLowerCase())) {
                            score += 120; // Big bonus for exact phrase in title
                            matches.push(`compound-title:${compound}`);
                        } else if (fullText.includes(compound.toLowerCase())) {
                            score += 60; // Medium bonus for exact phrase in content
                            matches.push(`compound-content:${compound}`);
                        }
                    }

                    // 7. Category priority boost
                    if (categoryData.priority === 'high') {
                        score *= 1.05; // Small boost for important categories
                    }

                    // 8. Anti-spam: Penalize if article seems too generic
                    if (matches.length === 0 && score < 20) {
                        score = 0; // Clear weak matches
                    }

                    scores.set(categoryName, { score, matches });
                }

                return scores;
            }

            // Select the best category with improved confidence calculation
            selectBestCategory(categoryScores) {
                let bestCategory = 'Other';
                let bestScore = 0;
                let secondBestScore = 0;

                const sortedScores = Array.from(categoryScores.entries())
                    .sort((a, b) => b[1].score - a[1].score);

                if (sortedScores.length > 0) {
                    bestScore = sortedScores[0][1].score;
                    if (bestScore >= this.minCategoryConfidence) {
                        bestCategory = sortedScores[0][0];
                    }
                }

                if (sortedScores.length > 1) {
                    secondBestScore = sortedScores[1][1].score;
                }

                // Calculate confidence with stricter thresholds
                let confidence = 'low';
                const scoreDifference = bestScore - secondBestScore;
                
                if (bestScore >= 120 && scoreDifference >= 40) {
                    confidence = 'high';
                } else if (bestScore >= 80 && scoreDifference >= 25) {
                    confidence = 'medium';
                } else if (bestScore >= this.minCategoryConfidence && scoreDifference >= 15) {
                    confidence = 'low';
                } else {
                    // Not confident enough, use "Other"
                    bestCategory = 'Other';
                    confidence = 'low';
                }

                return {
                    category: bestCategory,
                    score: bestScore,
                    confidence: confidence,
                    scoreDifference: scoreDifference,
                    allScores: sortedScores.slice(0, 3) // Keep top 3 for debugging
                };
            }

            // Discover dynamic categories from content
            discoverDynamicCategories() {
                if (!this.enableDynamicCategories || this.articles.length < 10) return;

                console.log('üîç Discovering dynamic categories from content...');
                
                const allKeywords = new Map();
                const keywordArticles = new Map();

                // Extract keywords from all articles
                for (const article of this.articles) {
                    if (article.extractedKeywords) {
                        article.extractedKeywords.forEach(keyword => {
                            allKeywords.set(keyword, (allKeywords.get(keyword) || 0) + 1);
                            
                            if (!keywordArticles.has(keyword)) {
                                keywordArticles.set(keyword, []);
                            }
                            keywordArticles.get(keyword).push(article);
                        });
                    }
                }

                // Find potential new categories
                const potentialCategories = [];
                for (const [keyword, count] of allKeywords.entries()) {
                    if (count >= 3 && keyword.length > 4) { // Minimum 3 articles, meaningful length
                        const articles = keywordArticles.get(keyword);
                        const uniqueDomains = new Set(articles.map(a => this.getDomain(a.url))).size;
                        
                        // Quality check: must span multiple domains
                        if (uniqueDomains >= 2) {
                            potentialCategories.push({
                                name: this.formatCategoryName(keyword),
                                keyword: keyword,
                                count: count,
                                articles: articles,
                                score: count * uniqueDomains
                            });
                        }
                    }
                }

                // Add top dynamic categories
                const topCategories = potentialCategories
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 5);

                topCategories.forEach(cat => {
                    this.dynamicCategories.set(cat.name, {
                        icon: this.guessIconForCategory(cat.keyword),
                        articles: cat.articles,
                        dynamic: true,
                        keyword: cat.keyword
                    });
                });

                if (topCategories.length > 0) {
                    console.log(`‚ú® Discovered ${topCategories.length} dynamic categories:`, 
                              topCategories.map(c => c.name).join(', '));
                }
            }

            // Format keyword into proper category name
            formatCategoryName(keyword) {
                return keyword.charAt(0).toUpperCase() + keyword.slice(1)
                    .replace(/([a-z])([A-Z])/g, '$1 $2') // camelCase to words
                    .replace(/[-_]/g, ' ') // Replace dashes/underscores
                    .replace(/\b\w/g, l => l.toUpperCase()); // Title case
            }

            // Guess appropriate icon for dynamic category
            guessIconForCategory(keyword) {
                const iconMap = {
                    'crypto': '‚Çø', 'blockchain': '‚õìÔ∏è', 'ai': 'ü§ñ', 'machine': 'ü§ñ',
                    'cloud': '‚òÅÔ∏è', 'mobile': 'üì±', 'security': 'üîí', 'data': 'üìä',
                    'marketing': 'üìà', 'social': 'üë•', 'music': 'üéµ', 'photo': 'üì∏',
                    'video': 'üé•', 'game': 'üéÆ', 'book': 'üìö', 'history': 'üìú',
                    'politics': 'üèõÔ∏è', 'energy': '‚ö°', 'environment': 'üåç', 'space': 'üöÄ'
                };

                for (const [term, icon] of Object.entries(iconMap)) {
                    if (keyword.includes(term)) return icon;
                }

                return 'üìã'; // Default icon
            }

            // Re-categorize all articles with enhanced intelligence
            recategorizeAllArticles() {
                console.log('üìÇ Auto-categorizing all articles...');
                this.categories.clear();
                this.dynamicCategories.clear();

                // First pass: categorize all articles
                for (const article of this.articles) {
                    const category = this.categorizeArticle(article);
                    this.categories.set(category, (this.categories.get(category) || 0) + 1);
                }

                // Second pass: discover dynamic categories
                this.discoverDynamicCategories();

                // Merge static and dynamic categories for display
                const allCategories = new Map([...this.categories]);
                for (const [dynCat, dynData] of this.dynamicCategories.entries()) {
                    allCategories.set(dynCat, dynData.articles.length);
                }

                console.log(`üß† Categorization complete: ${allCategories.size} categories found`);
                console.log(`üìä Distribution:`, Object.fromEntries(allCategories));
                
                this.updateCategoryUI();
            }

            // Enhanced category UI with AI indicators
            updateCategoryUI() {
                const categoryChips = document.getElementById('categoryChips');
                if (!categoryChips) return;

                // Merge static and dynamic categories
                const allCategories = new Map();
                
                // Add static categories
                for (const [cat, count] of this.categories.entries()) {
                    allCategories.set(cat, {
                        count: count,
                        dynamic: false,
                        icon: this.categoryKeywords[cat]?.icon || 'üìÑ'
                    });
                }
                
                // Add dynamic categories
                for (const [cat, data] of this.dynamicCategories.entries()) {
                    allCategories.set(cat, {
                        count: data.articles.length,
                        dynamic: true,
                        icon: data.icon
                    });
                }

                const sortedCategories = Array.from(allCategories.entries())
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, this.maxCategories);

                const totalArticles = this.currentDisplayedArticles.length;

                const dynamicCount = Array.from(allCategories.values()).filter(c => c.dynamic).length;
                const aiIndicator = dynamicCount > 0 ? ` (${dynamicCount} AI-discovered)` : '';

                categoryChips.innerHTML = `
                    <div class="category-chip show-all ${!this.activeCategory ? 'active' : ''}" 
                         onclick="webReader.filterByCategory(null)">
                        <span>ü§ñ</span>
                        <span>All Articles</span>
                        <span class="category-count">${totalArticles}</span>
                    </div>
                    ${sortedCategories.map(([category, data]) => {
                        const isActive = this.activeCategory === category;
                        const isDynamic = data.dynamic;
                        const dynamicBadge = isDynamic ? ' üî•' : '';
                        const title = isDynamic 
                            ? `AI-discovered category: ${category} (${data.count} articles)`
                            : `${category} (${data.count} articles)`;
                        
                        return `
                            <div class="category-chip ${isActive ? 'active' : ''}" 
                                 onclick="webReader.filterByCategory('${category}')"
                                 title="${title}">
                                <span>${data.icon}${dynamicBadge}</span>
                                <span>${category}</span>
                                <span class="category-count">${data.count}</span>
                            </div>
                        `;
                    }).join('')}
                `;

                // Update header to show category capabilities
                const header = categoryChips.parentElement.querySelector('.category-header h3');
                if (header && dynamicCount > 0) {
                    header.textContent = `üìÇ Filter by Category (${dynamicCount} discovered)`;
                }
                
                // Update sidebar counts
                this.updateSidebarCounts();
            }

            // Enhanced category badge with confidence indicators
            getCategoryBadgeHTML(article) {
                // Auto-categorize if not already categorized
                if (!article.category) {
                    this.categorizeArticle(article);
                }

                const category = article.category || 'Other';
                const confidence = article.categoryConfidence || 'low';
                const isDynamic = this.dynamicCategories.has(category);
                
                let categoryData = this.categoryKeywords[category];
                if (!categoryData && isDynamic) {
                    categoryData = this.dynamicCategories.get(category);
                }
                
                const icon = categoryData?.icon || 'üìÑ';
                const confidenceClass = confidence ? `${confidence}-confidence` : '';
                const dynamicIndicator = isDynamic ? ' üî•' : '';

                return `
                    <div class="article-category ${confidenceClass}" 
                         title="AI Category: ${category} (${confidence} confidence)${isDynamic ? ' - AI discovered' : ''}">
                        ${icon}${dynamicIndicator} ${category}
                    </div>
                `;
            }

            // Filter by category including dynamic categories
            filterByCategory(category) {
                this.activeCategory = category;

                let filtered;
                if (!category) {
                    // Show all articles
                    filtered = this.articles;
                } else {
                    // Check if it's a dynamic category
                    if (this.dynamicCategories.has(category)) {
                        filtered = this.dynamicCategories.get(category).articles;
                    } else {
                        // Filter by regular category
                        filtered = this.articles.filter(article => {
                            // Auto-categorize if not already categorized
                            if (!article.category) {
                                this.categorizeArticle(article);
                            }
                            return article.category === category;
                        });
                    }
                }

                this.currentDisplayedArticles = filtered;
                this.displayArticles(filtered);

                // Update category UI to show active state
                this.updateCategoryUI();

                // Update status with AI indicator
                if (!category) {
                    this.updateStatus(`ü§ñ Showing all ${filtered.length} articles`, 'success');
                } else {
                    const isDynamic = this.dynamicCategories.has(category);
                    const aiIndicator = isDynamic ? 'üî• AI-discovered' : '';
                    const categoryData = this.categoryKeywords[category] || this.dynamicCategories.get(category) || { icon: 'üìÑ' };
                    this.updateStatus(`${categoryData.icon} Showing ${filtered.length} ${category.toLowerCase()} articles ${aiIndicator}`, 'success');
                }

                console.log(`ü§ñ Filtered by AI category: ${category || 'All'} (${filtered.length} articles)`);
            }

            // ===== END ENHANCED AI CATEGORIZATION SYSTEM =====

            init() {
                this.setupEventListeners();
                this.checkAuthFromURL();
                this.loadStoredToken();
                this.loadThemePreference();
                this.loadImageCache();
            }

            setupEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', () => this.authenticate());
                document.getElementById('refreshBtn').addEventListener('click', () => this.loadArticles());
                document.getElementById('searchInput').addEventListener('input', (e) => this.searchArticles(e.target.value));
                document.getElementById('closeReader').addEventListener('click', () => this.closeReader());
                document.getElementById('openOriginal').addEventListener('click', () => this.openOriginal());

                // Search toggle keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ctrl/Cmd + K or / to open search
                    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                        e.preventDefault();
                        this.toggleSearch(true);
                    } else if (e.key === '/' && !this.isInputFocused()) {
                        e.preventDefault();
                        this.toggleSearch(true);
                    } else if (e.key === 'Escape') {
                        this.toggleSearch(false);
                    }
                });

                // Close search when clicking outside
                document.addEventListener('click', (e) => {
                    const searchContainer = document.getElementById('searchContainer');
                    const searchToggleBtn = document.getElementById('searchToggleBtn');

                    if (searchContainer.style.display !== 'none' &&
                        !searchContainer.contains(e.target) &&
                        !searchToggleBtn.contains(e.target)) {
                        this.toggleSearch(false);
                    }
                });

                // Close category filter when clicking outside
                document.addEventListener('click', (e) => {
                    const categoryContainer = document.getElementById('categoryContainer');
                    const categoriesBtn = document.getElementById('categoriesBtn');

                    if (categoryContainer.style.display !== 'none' &&
                        !categoryContainer.contains(e.target) &&
                        !categoriesBtn.contains(e.target)) {
                        this.toggleCategoryFilter(false);
                    }
                });

                // Close mobile menu when clicking on overlay
                document.addEventListener('click', (e) => {
                    const sidebar = document.getElementById('sidebar');
                    const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
                    
                    if (window.innerWidth <= 768 && 
                        sidebar.classList.contains('mobile-open') &&
                        !sidebar.contains(e.target) && 
                        !mobileMenuBtn?.contains(e.target)) {
                        this.toggleMobileMenu();
                    }
                });
            }

            isInputFocused() {
                const activeElement = document.activeElement;
                return activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');
            }

            // Toggle category filter visibility
            toggleCategoryFilter(forceState = null) {
                const categoryContainer = document.getElementById('categoryContainer');
                const categoriesBtn = document.getElementById('categoriesBtn');

                const isCurrentlyVisible = categoryContainer.style.display !== 'none';
                const shouldShow = forceState !== null ? forceState : !isCurrentlyVisible;

                if (shouldShow) {
                    // Ensure categories are up to date with AI analysis
                    this.recategorizeAllArticles();

                    // Show category filter
                    categoryContainer.style.display = 'block';
                    setTimeout(() => {
                        categoryContainer.classList.add('visible');
                    }, 10);

                    // Update navigation
                    this.setActiveNavItem('categoriesBtn');
                    document.getElementById('pageTitle').textContent = 'Categories';

                    this.updateStatus('üè∑Ô∏è Category filter active - Click a category to filter articles', 'success');
                } else {
                    // Hide category filter
                    categoryContainer.classList.remove('visible');
                    setTimeout(() => {
                        if (!categoryContainer.classList.contains('visible')) {
                            categoryContainer.style.display = 'none';
                        }
                    }, 300);

                    // Clear any active category filter if closing
                    if (this.activeCategory) {
                        this.showAllArticles();
                    }
                }
            }

            // ===== PKCE IMPLEMENTATION =====

            // Generate a cryptographically secure random string for PKCE
            generateCodeVerifier() {
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return this.base64URLEncode(array);
            }

            // Create SHA256 hash and base64url encode it
            async generateCodeChallenge(codeVerifier) {
                const encoder = new TextEncoder();
                const data = encoder.encode(codeVerifier);
                const digest = await crypto.subtle.digest('SHA-256', data);
                return this.base64URLEncode(new Uint8Array(digest));
            }

            // Base64URL encoding (different from regular base64)
            base64URLEncode(array) {
                return btoa(String.fromCharCode.apply(null, array))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            }

            // Generate cryptographically secure state parameter
            generateState() {
                const array = new Uint8Array(16);
                crypto.getRandomValues(array);
                return this.base64URLEncode(array);
            }

            // Store PKCE parameters securely
            storePKCEParameters(codeVerifier, state) {
                // Use sessionStorage for security (cleared when tab closes)
                sessionStorage.setItem('mypocket_code_verifier', codeVerifier);
                sessionStorage.setItem('mypocket_state', state);
                console.log('üîê PKCE parameters stored securely');
            }

            // Retrieve PKCE parameters
            retrievePKCEParameters() {
                const codeVerifier = sessionStorage.getItem('mypocket_code_verifier');
                const state = sessionStorage.getItem('mypocket_state');
                return { codeVerifier, state };
            }

            // Clear PKCE parameters after use
            clearPKCEParameters() {
                sessionStorage.removeItem('mypocket_code_verifier');
                sessionStorage.removeItem('mypocket_state');
                console.log('üóëÔ∏è PKCE parameters cleared');
            }

            // ENHANCED: Secure authentication with PKCE
            async authenticate() {
                if (!this.redirectUri || (!this.redirectUri.startsWith('http://') && !this.redirectUri.startsWith('https://'))) {
                    this.updateStatus('‚ùå Invalid redirect URI. Please open this page via HTTP/HTTPS.', 'error');
                    console.error('üî¥ Invalid redirect URI:', this.redirectUri);
                    alert(`Redirect URI Error:\n\nCurrent URI: ${this.redirectUri}\n\nPlease:\n1. Open this page via HTTP/HTTPS (not file://)\n2. Register this exact URI in Azure AD\n3. Use a web server to serve this file`);
                    return;
                }

                try {
                    this.updateStatus('üîê Generating secure authentication parameters...', 'loading');

                    // Generate PKCE parameters
                    this.codeVerifier = this.generateCodeVerifier();
                    this.codeChallenge = await this.generateCodeChallenge(this.codeVerifier);
                    this.state = this.generateState();

                    // Store parameters securely
                    this.storePKCEParameters(this.codeVerifier, this.state);

                    // Build authorization URL with PKCE
                    const authUrl = `https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize?` +
                        `client_id=${this.clientId}&` +
                        `response_type=code&` +  // Use code instead of token
                        `redirect_uri=${encodeURIComponent(this.redirectUri)}&` +
                        `scope=${encodeURIComponent('Files.ReadWrite User.Read')}&` +
                        `state=${this.state}&` +  // Anti-CSRF protection
                        `code_challenge=${this.codeChallenge}&` +  // PKCE challenge
                        `code_challenge_method=S256&` +  // SHA256 method
                        `response_mode=query`;  // Use query instead of fragment

                    console.log('üîê PKCE Auth URL generated');
                    console.log('üîê Code Challenge:', this.codeChallenge.substring(0, 20) + '...');
                    console.log('üîê State:', this.state.substring(0, 20) + '...');

                    this.updateStatus('üîÑ Redirecting to secure Microsoft login...', 'loading');

                    setTimeout(() => {
                        window.location.href = authUrl;
                    }, 1000);

                } catch (error) {
                    console.error('PKCE generation error:', error);
                    this.updateStatus('‚ùå Error generating secure authentication. Please try again.', 'error');
                }
            }

            // ENHANCED: Handle authorization code from redirect
            async checkAuthFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const state = urlParams.get('state');
                const error = urlParams.get('error');
                const errorDescription = urlParams.get('error_description');

                // Check for errors first
                if (error) {
                    this.updateStatus(`‚ùå Authentication error: ${error} - ${errorDescription || 'Unknown error'}`, 'error');
                    this.clearPKCEParameters();
                    // Clean URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                    return;
                }

                // If we have an authorization code, exchange it for tokens
                if (code && state) {
                    try {
                        this.updateStatus('üîê Exchanging authorization code for tokens...', 'loading');

                        // Retrieve stored PKCE parameters
                        const { codeVerifier, state: storedState } = this.retrievePKCEParameters();

                        // Verify state parameter (anti-CSRF protection)
                        if (!storedState || state !== storedState) {
                            throw new Error('State parameter mismatch. Possible CSRF attack.');
                        }

                        if (!codeVerifier) {
                            throw new Error('Code verifier not found. Please try authenticating again.');
                        }

                        // Exchange authorization code for access token
                        const tokenResponse = await this.exchangeCodeForTokens(code, codeVerifier);

                        if (tokenResponse.access_token) {
                            this.accessToken = tokenResponse.access_token;
                            this.saveToken(tokenResponse.access_token);

                            // Save refresh token if provided
                            if (tokenResponse.refresh_token) {
                                this.saveRefreshToken(tokenResponse.refresh_token);
                            }

                            this.updateConnectionStatus(true);
                            this.loadArticles();

                            // Clear PKCE parameters and URL
                            this.clearPKCEParameters();
                            window.history.replaceState({}, document.title, window.location.pathname);

                            this.updateStatus('‚úÖ Secure authentication successful!', 'success');
                        } else {
                            throw new Error('No access token received from authorization server');
                        }

                    } catch (error) {
                        console.error('Token exchange error:', error);
                        this.updateStatus(`‚ùå Token exchange failed: ${error.message}`, 'error');
                        this.clearPKCEParameters();
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }
                }
            }

            // NEW: Exchange authorization code for access token using PKCE
            async exchangeCodeForTokens(authorizationCode, codeVerifier) {
                const tokenEndpoint = 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                const tokenRequest = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        client_id: this.clientId,
                        scope: 'Files.ReadWrite User.Read',
                        code: authorizationCode,
                        redirect_uri: this.redirectUri,
                        grant_type: 'authorization_code',
                        code_verifier: codeVerifier  // PKCE verification
                    })
                };

                console.log('üîê Exchanging authorization code for tokens...');

                const response = await fetch(tokenEndpoint, tokenRequest);

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Token exchange failed: ${errorData.error} - ${errorData.error_description}`);
                }

                const tokenData = await response.json();
                console.log('‚úÖ Token exchange successful');

                return tokenData;
            }

            // NEW: Enhanced token management
            saveToken(token) {
                localStorage.setItem('mypocket_access_token', token);
                // Also store timestamp for expiration tracking
                localStorage.setItem('mypocket_token_timestamp', Date.now().toString());
            }

            saveRefreshToken(refreshToken) {
                localStorage.setItem('mypocket_refresh_token', refreshToken);
            }

            getRefreshToken() {
                return localStorage.getItem('mypocket_refresh_token');
            }

            clearTokens() {
                localStorage.removeItem('mypocket_access_token');
                localStorage.removeItem('mypocket_refresh_token');
                localStorage.removeItem('mypocket_token_timestamp');
                this.accessToken = null;
            }

            // NEW: Check if token is expired and refresh if needed
            async ensureValidToken() {
                if (!this.accessToken) {
                    return false;
                }

                // Check if token is expired (Microsoft tokens typically last 1 hour)
                const tokenTimestamp = localStorage.getItem('mypocket_token_timestamp');
                if (tokenTimestamp) {
                    const tokenAge = Date.now() - parseInt(tokenTimestamp);
                    const oneHour = 60 * 60 * 1000;

                    if (tokenAge > oneHour) {
                        console.log('üîÑ Token expired, attempting refresh...');
                        const refreshSuccess = await this.refreshAccessToken();
                        if (!refreshSuccess) {
                            console.log('‚ùå Token refresh failed, need to re-authenticate');
                            return false;
                        }
                    }
                }

                return true;
            }

            // NEW: Refresh access token using refresh token
            async refreshAccessToken() {
                const refreshToken = this.getRefreshToken();
                if (!refreshToken) {
                    console.log('No refresh token available');
                    return false;
                }

                try {
                    const tokenEndpoint = 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                    const refreshRequest = {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: this.clientId,
                            scope: 'Files.ReadWrite User.Read',
                            refresh_token: refreshToken,
                            grant_type: 'refresh_token'
                        })
                    };

                    const response = await fetch(tokenEndpoint, refreshRequest);

                    if (!response.ok) {
                        console.log('Refresh token request failed');
                        return false;
                    }

                    const tokenData = await response.json();

                    if (tokenData.access_token) {
                        this.accessToken = tokenData.access_token;
                        this.saveToken(tokenData.access_token);

                        // Update refresh token if a new one was provided
                        if (tokenData.refresh_token) {
                            this.saveRefreshToken(tokenData.refresh_token);
                        }

                        console.log('‚úÖ Token refreshed successfully');
                        return true;
                    }

                    return false;

                } catch (error) {
                    console.error('Token refresh error:', error);
                    return false;
                }
            }

            loadStoredToken() {
                this.accessToken = localStorage.getItem('mypocket_access_token');
                if (this.accessToken) {
                    this.updateConnectionStatus(true);
                    // Check token validity and load articles
                    this.ensureValidToken().then(isValid => {
                        if (isValid) {
                            this.loadArticles();
                        } else {
                            this.updateConnectionStatus(false);
                            this.updateStatus('Stored token expired. Please reconnect.', 'error');
                        }
                    });
                }
            }

            updateConnectionStatus(connected) {
                const connectBtn = document.getElementById('connectBtn');
                const connectIcon = document.getElementById('connectIcon');
                const connectText = document.getElementById('connectText');
                const connectionStatus = document.getElementById('connectionStatus');
                const refreshBtn = document.getElementById('refreshBtn');
                const syncBtn = document.getElementById('syncBtn');
                const retryFailedBtn = document.getElementById('retryFailedBtn');

                if (connected) {
                    connectIcon.textContent = '‚úÖ';
                    connectText.textContent = 'Connected';
                    connectionStatus.style.background = 'rgba(39, 174, 96, 0.2)';
                    connectionStatus.style.borderColor = '#27ae60';
                    connectionStatus.style.color = '#27ae60';
                    
                    // Update sidebar button
                    connectBtn.querySelector('.label').textContent = 'Connected to OneDrive';
                    connectBtn.querySelector('.icon').textContent = '‚úÖ';
                    
                    refreshBtn.style.display = 'block';
                    if (syncBtn) syncBtn.style.display = 'block';
                    if (retryFailedBtn) retryFailedBtn.style.display = 'block';
                } else {
                    connectIcon.textContent = 'üîê';
                    connectText.textContent = 'Not Connected';
                    connectionStatus.style.background = 'rgba(255, 255, 255, 0.1)';
                    connectionStatus.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                    connectionStatus.style.color = 'white';
                    
                    // Update sidebar button
                    connectBtn.querySelector('.label').textContent = 'Connect to OneDrive';
                    connectBtn.querySelector('.icon').textContent = '‚òÅÔ∏è';
                    
                    refreshBtn.style.display = 'none';
                    if (syncBtn) syncBtn.style.display = 'none';
                    if (retryFailedBtn) retryFailedBtn.style.display = 'none';
                }
            }

            // NEW: Show all articles (default view)
            showAllArticles() {
                this.activeCategory = null;
                this.currentDisplayedArticles = this.articles;
                this.displayArticles(this.articles);
                
                // Update navigation
                this.setActiveNavItem('allArticlesBtn');
                document.getElementById('pageTitle').textContent = 'All Articles';
                
                // Close category filter if open
                this.toggleCategoryFilter(false);
                
                this.updateStatus(`Showing all ${this.articles.length} articles`, 'success');
            }

            // NEW: Toggle mobile menu
            toggleMobileMenu() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('mobileOverlay');
                const isOpen = sidebar.classList.contains('mobile-open');
                
                if (isOpen) {
                    sidebar.classList.remove('mobile-open');
                    overlay.classList.remove('active');
                } else {
                    sidebar.classList.add('mobile-open');
                    overlay.classList.add('active');
                }
            }

            // NEW: Set active navigation item
            setActiveNavItem(activeId) {
                // Remove active class from all nav items
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Add active class to selected item
                const activeItem = document.getElementById(activeId);
                if (activeItem) {
                    activeItem.classList.add('active');
                }
            }

            // NEW: Update article counts in sidebar
            updateSidebarCounts() {
                const allCount = document.getElementById('allArticleCount');
                const categoryCountElement = document.getElementById('categoryCount');
                
                if (allCount) {
                    allCount.textContent = this.articles.length;
                }
                
                if (categoryCountElement) {
                    const totalCategories = this.categories.size + this.dynamicCategories.size;
                    categoryCountElement.textContent = totalCategories;
                }
            }

            // NEW: Toggle search functionality
            toggleSearch(forceState = null) {
                const searchContainer = document.getElementById('searchContainer');
                const searchInput = document.getElementById('searchInput');
                const searchToggleBtn = document.getElementById('searchToggleBtn');

                const isCurrentlyVisible = searchContainer.style.display !== 'none';
                const shouldShow = forceState !== null ? forceState : !isCurrentlyVisible;

                if (shouldShow) {
                    // Show search
                    searchContainer.style.display = 'block';
                    setTimeout(() => {
                        searchContainer.classList.add('visible');
                        searchInput.focus();
                    }, 10);

                    // Update navigation
                    this.setActiveNavItem('searchToggleBtn');
                    document.getElementById('pageTitle').textContent = 'Search Articles';

                    this.updateStatus('üîç Search mode active - Type to search or press Escape to close', 'success');
                } else {
                    // Hide search
                    searchContainer.classList.remove('visible');
                    setTimeout(() => {
                        if (!searchContainer.classList.contains('visible')) {
                            searchContainer.style.display = 'none';
                        }
                    }, 300);

                    // Clear search if closing
                    if (searchInput.value) {
                        searchInput.value = '';
                        this.searchArticles('');
                    }

                    // Return to all articles view
                    this.showAllArticles();

                    // Remove focus
                    searchInput.blur();
                }
            }

            // Get article content for analysis (tries multiple content fields)
            getArticleContentForAnalysis(article) {
                const contentFields = ['content', 'textContent', 'excerpt', 'description', 'summary'];

                for (const field of contentFields) {
                    if (article[field] && typeof article[field] === 'string' && article[field].length > 10) {
                        return article[field];
                    }
                }

                return article.title || '';
            }

            // NEW: Refresh a single image that's working but wrong
            async refreshSingleImage(originalIndex, displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                const imageElement = document.getElementById(`image-${originalIndex}`);
                if (!imageElement) {
                    console.error('Image element not found for index:', originalIndex);
                    return;
                }

                // Confirm the action
                const proceed = confirm(`Refresh image for "${article.title.substring(0, 50)}..."?\n\nThis will:\n‚Ä¢ Clear the current image\n‚Ä¢ Try to find a better image from the original source\n‚Ä¢ Use alternative sources if needed\n\nProceed?`);

                if (!proceed) return;

                console.log(`üîÑ Refreshing single image for: ${article.title.substring(0, 30)}...`);

                // Update status immediately
                const cacheIndicator = imageElement.querySelector('.cache-indicator');
                if (cacheIndicator) {
                    cacheIndicator.textContent = 'üîÑ Refreshing...';
                    cacheIndicator.className = 'cache-indicator loading';
                }

                // Show loading placeholder
                imageElement.innerHTML = `
                    ${this.createPlaceholderHTML()}
                    <div class="cache-indicator loading">
                        üîÑ Refreshing...
                    </div>
                `;

                try {
                    // Clear any existing cache for this article
                    const cacheKey = this.getCacheKey(article);
                    this.imageCache.delete(cacheKey);

                    // Clear stored image from article
                    const mainArticleIndex = this.articles.findIndex(a =>
                        a.url === article.url && a.title === article.title
                    );
                    if (mainArticleIndex !== -1 && this.articles[mainArticleIndex].cachedImage) {
                        delete this.articles[mainArticleIndex].cachedImage;
                    }

                    // Try multiple strategies to get a fresh, correct image
                    let success = false;

                    // Strategy 1: Try to extract fresh from the original website
                    try {
                        console.log(`üåê Attempting fresh extraction from: ${this.getDomain(article.url)}`);
                        const extractedImage = await this.fetchRealImageFromWebsite(article.url);
                        if (extractedImage) {
                            console.log(`‚úÖ Fresh extraction successful: ${article.title.substring(0, 30)}...`);
                            await this.setArticleImageAndCache(article, originalIndex, extractedImage, 'refreshed');
                            success = true;
                        }
                    } catch (error) {
                        console.log(`‚ö†Ô∏è Fresh extraction failed: ${error.message}`);
                    }

                    // Strategy 2: Try alternative extraction methods
                    if (!success) {
                        try {
                            console.log(`üîÑ Trying alternative methods...`);
                            success = await this.tryAlternativeImageStrategies(article, originalIndex);
                        } catch (error) {
                            console.log(`‚ö†Ô∏è Alternative methods failed: ${error.message}`);
                        }
                    }

                    // Strategy 3: Use a new category-based image (last resort)
                    if (!success) {
                        console.log(`üé® Using refreshed category image...`);
                        const fallbackImage = this.getCategoryBasedImage(article, originalIndex + Date.now()); // Add timestamp for variation
                        await this.setArticleImageAndCache(article, originalIndex, fallbackImage, 'refreshed');
                        success = true;
                    }

                    if (success) {
                        this.updateStatus(`‚úÖ Image refreshed successfully for "${article.title.substring(0, 40)}..."`, 'success');

                        // Update backup if connected
                        if (this.accessToken) {
                            try {
                                await this.updateOneDriveBackup();
                                console.log('‚úÖ Updated backup with refreshed image');
                            } catch (error) {
                                console.error('‚ö†Ô∏è Failed to update backup:', error);
                            }
                        }
                    } else {
                        throw new Error('All refresh strategies failed');
                    }

                } catch (error) {
                    console.error('Single image refresh error:', error);
                    this.updateStatus(`‚ùå Failed to refresh image: ${error.message}`, 'error');

                    // Show error state
                    const errorCacheIndicator = imageElement.querySelector('.cache-indicator');
                    if (errorCacheIndicator) {
                        errorCacheIndicator.textContent = '‚ùå Refresh Failed';
                        errorCacheIndicator.className = 'cache-indicator error';
                    }
                }
            }

            async retryFailedImages() {
                if (!this.accessToken) {
                    this.updateStatus('‚ùå Please connect to OneDrive first', 'error');
                    return;
                }

                // MUCH MORE CONSERVATIVE: Only target explicitly failed images
                const articlesWithFailedImages = this.articles.filter((article, index) => {
                    // Only consider images that are explicitly in our failed set
                    // OR have explicit "Failed" indicator - nothing else
                    const isExplicitlyFailed = this.failedImages.has(index);

                    const imageElement = document.getElementById(`image-${index}`);
                    const cacheIndicator = imageElement?.querySelector('.cache-indicator');
                    const hasFailedIndicator = cacheIndicator && cacheIndicator.textContent.includes('‚ùå Failed');

                    // ONLY process if explicitly marked as failed - be very conservative
                    return isExplicitlyFailed || hasFailedIndicator;
                });

                if (articlesWithFailedImages.length === 0) {
                    this.updateStatus('‚úÖ No explicitly failed images found. Use "Sync Images" for broader updates.', 'success');
                    return;
                }

                // Show confirmation with exact count
                const proceed = confirm(`Retry ${articlesWithFailedImages.length} explicitly failed images?\n\nThis will ONLY affect images marked with "‚ùå Failed" status.\nWorking images will NOT be touched.\n\nProceed?`);

                if (!proceed) {
                    this.updateStatus('Retry cancelled by user', 'error');
                    return;
                }

                this.updateStatus(`üîÑ Retrying ONLY ${articlesWithFailedImages.length} explicitly failed images...`, 'loading');

                let retriedCount = 0;
                let successCount = 0;

                for (const article of articlesWithFailedImages) {
                    const originalIndex = this.articles.findIndex(a => a === article);
                    if (originalIndex === -1) continue;

                    try {
                        retriedCount++;
                        console.log(`üîÑ Retrying FAILED image ${retriedCount}/${articlesWithFailedImages.length}: ${article.title.substring(0, 30)}...`);

                        // Clear from failed set
                        this.failedImages.delete(originalIndex);

                        // Try to recover the failed image
                        const success = await this.tryAlternativeImageStrategies(article, originalIndex);
                        if (success) {
                            successCount++;
                            console.log(`‚úÖ Successfully recovered image: ${article.title.substring(0, 30)}...`);
                        }

                        // Update progress
                        this.updateStatus(`üîÑ Retrying failed images... ${retriedCount}/${articlesWithFailedImages.length} (${successCount} recovered)`, 'loading');

                        // Small delay to prevent overwhelming
                        await new Promise(resolve => setTimeout(resolve, 300));

                    } catch (error) {
                        console.error(`Failed to retry image for ${article.title}:`, error);
                        this.failedImages.add(originalIndex);
                    }
                }

                const message = successCount > 0
                    ? `‚úÖ Retry complete! Recovered ${successCount}/${articlesWithFailedImages.length} failed images. Working images were untouched.`
                    : `‚ö†Ô∏è Could not recover the failed images - they may be permanently unavailable.`;

                this.updateStatus(message, successCount > 0 ? 'success' : 'error');

                // Only update backup if we actually recovered images
                if (successCount > 0 && this.accessToken) {
                    try {
                        await this.updateOneDriveBackup();
                        console.log('‚úÖ OneDrive backup updated with recovered images');
                    } catch (error) {
                        console.error('‚ö†Ô∏è Failed to save recovered images to backup:', error);
                    }
                }
            }

            // NEW: Show help for image features
            showImageHelp() {
                const helpText = `
MyPocket AI Reader - Image System Help:
======================================

üñºÔ∏è IMAGE STATUS INDICATORS:
‚Ä¢ üåê Synced - Stored across all devices
‚Ä¢ üíæ Cached - Stored locally on this device  
‚Ä¢ üîÑ Refreshed - Recently updated image
‚Ä¢ ‚ùå Failed - Could not load image

üîß AVAILABLE ACTIONS:

1Ô∏è‚É£ INDIVIDUAL IMAGE REFRESH (üñºÔ∏è button):
   ‚Ä¢ Use when an image loaded but shows wrong content
   ‚Ä¢ Click the üñºÔ∏è button on any article card
   ‚Ä¢ Tries to find the correct image for that article
   ‚Ä¢ Works even if current image appears "successful"

2Ô∏è‚É£ RETRY FAILED IMAGES (Retry Failed button):
   ‚Ä¢ Only processes images marked "‚ùå Failed"
   ‚Ä¢ Leaves working images untouched
   ‚Ä¢ Appears when connected to OneDrive

3Ô∏è‚É£ SYNC ALL IMAGES (Sync Images button):
   ‚Ä¢ Forces refresh of ALL images
   ‚Ä¢ Stores images for cross-device access
   ‚Ä¢ Use for complete refresh

ü§ñ AI CATEGORIZATION FEATURES:
‚Ä¢ Intelligent content analysis with keyword extraction
‚Ä¢ Dynamic category discovery from your articles
‚Ä¢ Confidence scoring (high/medium/low)
‚Ä¢ 12+ predefined categories + AI-discovered categories
‚Ä¢ Categories marked with üî• are AI-discovered
‚Ä¢ Click categories to filter articles

üéØ WHEN TO USE EACH:

Wrong but Working Image ‚Üí Use üñºÔ∏è (Individual Refresh)
Red "‚ùå Failed" Status ‚Üí Use "Retry Failed" button  
Want All Fresh Images ‚Üí Use "Sync Images" button

üí° TIP: The üñºÔ∏è button appears when you hover over article cards (or always visible on mobile). Perfect for fixing individual wrong images!

üß† AI CATEGORIZATION TIP: Categories are automatically discovered from your content. The more articles you have, the smarter the categorization becomes!
                `;

                alert(helpText);
            }

            async tryAlternativeImageStrategies(article, index) {
                console.log(`üéØ Trying alternative strategies for: ${article.title.substring(0, 30)}...`);

                // Strategy 1: Try different proxy services for website extraction
                try {
                    const extractedImage = await this.tryAlternativeProxies(article.url);
                    if (extractedImage) {
                        console.log(`‚úÖ Recovered via alternative proxy: ${article.title.substring(0, 30)}...`);
                        this.setArticleImageAndCache(article, index, extractedImage, 'extracted');
                        return true;
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è Alternative proxy failed: ${error.message}`);
                }

                // Strategy 2: Try searching for similar images via title keywords
                try {
                    const searchBasedImage = await this.getImageFromTitleKeywords(article);
                    if (searchBasedImage) {
                        console.log(`‚úÖ Found via title search: ${article.title.substring(0, 30)}...`);
                        this.setArticleImageAndCache(article, index, searchBasedImage, 'search');
                        return true;
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è Title search failed: ${error.message}`);
                }

                // Strategy 3: Use domain-specific image patterns
                try {
                    const domainImage = this.getDomainSpecificImage(article);
                    if (domainImage) {
                        console.log(`‚úÖ Using domain-specific image: ${article.title.substring(0, 30)}...`);
                        this.setArticleImageAndCache(article, index, domainImage, 'domain');
                        return true;
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è Domain-specific image failed: ${error.message}`);
                }

                // Strategy 4: Use high-quality category fallback (last resort)
                console.log(`üé® Using enhanced fallback for: ${article.title.substring(0, 30)}...`);
                const fallbackImage = this.getCategoryBasedImage(article, index);
                this.setArticleImageAndCache(article, index, fallbackImage, 'fallback');

                // Update cache indicator to show it's a fallback
                const imageElement = document.getElementById(`image-${index}`);
                const cacheIndicator = imageElement?.querySelector('.cache-indicator');
                if (cacheIndicator) {
                    cacheIndicator.textContent = 'üé® Enhanced';
                    cacheIndicator.className = 'cache-indicator fallback';
                }

                return true; // Always return true for fallback since we did set an image
            }

            // NEW: Try alternative proxy services
            async tryAlternativeProxies(url) {
                const proxies = [
                    `https://corsproxy.io/?${encodeURIComponent(url)}`,
                    `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
                    `https://thingproxy.freeboard.io/fetch/${encodeURIComponent(url)}`
                ];

                for (const proxyUrl of proxies) {
                    try {
                        console.log(`Trying proxy: ${proxyUrl.substring(0, 50)}...`);
                        const response = await fetch(proxyUrl);

                        if (response.ok) {
                            const html = await response.text();
                            if (html && html.length > 1000) {
                                const extractedImage = this.parseHTMLForBestImage(html, url);
                                if (extractedImage) {
                                    return extractedImage;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`Proxy failed: ${error.message}`);
                        continue;
                    }
                }

                return null;
            }

            // NEW: Get image based on title keywords using search services
            async getImageFromTitleKeywords(article) {
                // Extract meaningful keywords from title
                const title = article.title.toLowerCase();
                const commonWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'how', 'what', 'why', 'when', 'where'];
                const keywords = title
                    .split(/[^\w]+/)
                    .filter(word => word.length > 3 && !commonWords.includes(word))
                    .slice(0, 3) // Take first 3 meaningful words
                    .join(' ');

                if (!keywords) return null;

                // Use Unsplash search API for relevant images
                try {
                    const searchQuery = encodeURIComponent(keywords);
                    const unsplashUrl = `https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;

                    // For now, return a themed image based on keywords
                    // (In a real implementation, you'd use Unsplash API with a key)
                    if (keywords.includes('tech') || keywords.includes('code') || keywords.includes('software')) {
                        return 'https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                    }
                    if (keywords.includes('business') || keywords.includes('work') || keywords.includes('office')) {
                        return 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                    }
                    if (keywords.includes('design') || keywords.includes('art') || keywords.includes('creative')) {
                        return 'https://images.unsplash.com/photo-1561070791-2526d30994b5?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                    }

                    return unsplashUrl;
                } catch (error) {
                    console.log(`Keyword-based search failed: ${error.message}`);
                    return null;
                }
            }

            // NEW: Get domain-specific images for known sites
            getDomainSpecificImage(article) {
                const domain = this.getDomain(article.url).toLowerCase();

                // Site-specific default images for when original images fail
                const siteDefaults = {
                    'github.com': 'https://images.unsplash.com/photo-1618401471353-b98afee0b2eb?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'medium.com': 'https://images.unsplash.com/photo-1481627834876-b7833e8f5570?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'youtube.com': 'https://images.unsplash.com/photo-1611162617474-5b21e879e113?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'stackoverflow.com': 'https://images.unsplash.com/photo-1516116216624-53e697fedbea?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'dev.to': 'https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'reddit.com': 'https://images.unsplash.com/photo-1611224923853-80b023f02d71?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'news': 'https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'blog': 'https://images.unsplash.com/photo-1486312338219-ce68e2c6b9d6?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                };

                // Check for exact domain matches
                for (const [siteDomain, image] of Object.entries(siteDefaults)) {
                    if (domain.includes(siteDomain)) {
                        return image;
                    }
                }

                return null;
            }

            async forceSyncImages() {
                if (!this.accessToken) {
                    this.updateStatus('‚ùå Please connect to OneDrive first', 'error');
                    return;
                }

                this.updateStatus('üîÑ Force syncing all images to OneDrive...', 'loading');

                try {
                    let syncedCount = 0;
                    const totalArticles = this.articles.length;

                    for (let i = 0; i < this.articles.length; i++) {
                        const article = this.articles[i];

                        // If article doesn't have cached image, try to get it from local cache or extract
                        if (!article.cachedImage) {
                            let imageUrl = this.getCachedImage(article);

                            if (!imageUrl) {
                                imageUrl = this.getBestArticleImage(article);
                            }

                            if (!imageUrl) {
                                imageUrl = this.getCategoryBasedImage(article, i);
                            }

                            if (imageUrl) {
                                try {
                                    const imageData = await this.convertImageToBase64(imageUrl);
                                    if (imageData.stored) {
                                        article.cachedImage = {
                                            base64: imageData.base64,
                                            url: imageData.url,
                                            timestamp: Date.now(),
                                            size: imageData.size,
                                            source: 'force_sync'
                                        };
                                        syncedCount++;
                                    }
                                } catch (error) {
                                    console.error(`Failed to sync image for ${article.title}:`, error);
                                }
                            }
                        } else {
                            syncedCount++; // Already has cached image
                        }

                        // Update progress
                        if (i % 5 === 0) {
                            this.updateStatus(`üîÑ Syncing images... ${i + 1}/${totalArticles}`, 'loading');
                        }
                    }

                    // Save to OneDrive
                    await this.updateOneDriveBackup();

                    this.updateStatus(`‚úÖ Force sync complete! ${syncedCount}/${totalArticles} images synced to OneDrive`, 'success');

                    // Refresh display to show synced status
                    this.displayArticles(this.articles);

                } catch (error) {
                    console.error('Force sync error:', error);
                    this.updateStatus(`‚ùå Force sync failed: ${error.message}`, 'error');
                }
            }

            updateStatus(message, type = '') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }

            // ===== IMAGE CACHE SYSTEM =====

            loadImageCache() {
                try {
                    const cachedData = localStorage.getItem(this.cacheKey);
                    if (cachedData) {
                        const cache = JSON.parse(cachedData);

                        // Clean expired cache entries
                        const now = Date.now();
                        const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                        for (const [key, entry] of Object.entries(cache)) {
                            if (now - entry.timestamp < expiryTime) {
                                this.imageCache.set(key, entry);
                            }
                        }

                        console.log(`üì¶ Loaded ${this.imageCache.size} cached images`);
                    }
                } catch (error) {
                    console.error('Error loading image cache:', error);
                    this.imageCache.clear();
                }
            }

            saveImageCache() {
                try {
                    const cacheObject = {};
                    for (const [key, value] of this.imageCache.entries()) {
                        cacheObject[key] = value;
                    }
                    localStorage.setItem(this.cacheKey, JSON.stringify(cacheObject));
                    console.log(`üíæ Saved ${this.imageCache.size} images to cache`);
                } catch (error) {
                    console.error('Error saving image cache:', error);
                }
            }

            getCacheKey(article) {
                // Create a unique cache key based on article URL and title
                return `${this.getDomain(article.url)}_${article.url.substring(article.url.length - 20)}_${article.title.substring(0, 30)}`.replace(/[^a-zA-Z0-9]/g, '_');
            }

            getCachedImage(article) {
                const key = this.getCacheKey(article);
                const cached = this.imageCache.get(key);

                if (cached) {
                    const now = Date.now();
                    const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                    if (now - cached.timestamp < expiryTime) {
                        console.log(`‚úÖ Using cached image for: ${article.title.substring(0, 30)}...`);
                        return cached.imageUrl;
                    } else {
                        // Remove expired cache entry
                        this.imageCache.delete(key);
                        console.log(`‚è∞ Cache expired for: ${article.title.substring(0, 30)}...`);
                    }
                }

                return null;
            }

            setCachedImage(article, imageUrl) {
                const key = this.getCacheKey(article);
                this.imageCache.set(key, {
                    imageUrl: imageUrl,
                    timestamp: Date.now(),
                    domain: this.getDomain(article.url),
                    title: article.title.substring(0, 50)
                });

                // Save to localStorage (debounced)
                clearTimeout(this.cacheSaveTimeout);
                this.cacheSaveTimeout = setTimeout(() => this.saveImageCache(), 1000);

                console.log(`üíæ Cached image for: ${article.title.substring(0, 30)}...`);
            }

            clearImageCache() {
                if (confirm('Clear all cached images?\n\nThis will:\n- Clear local cache\n- Remove stored images from articles\n- Force re-downloading images next time')) {
                    // Clear local cache
                    this.imageCache.clear();
                    localStorage.removeItem(this.cacheKey);

                    // Clear stored images from articles
                    this.articles.forEach(article => {
                        if (article.cachedImage) {
                            delete article.cachedImage;
                        }
                    });

                    this.updateStatus('üóëÔ∏è All image data cleared. Images will be re-downloaded and stored for cross-device access.', 'success');
                    console.log('üóëÔ∏è All image data cleared');

                    // Refresh display
                    this.displayArticles(this.articles);
                }
            }

            getCacheStats() {
                const timestamps = Array.from(this.imageCache.values()).map(entry => entry.timestamp);
                return {
                    total: this.imageCache.size,
                    memoryUsage: JSON.stringify(Object.fromEntries(this.imageCache)).length,
                    oldestEntry: timestamps.length > 0 ? Math.min(...timestamps) : null,
                    newestEntry: timestamps.length > 0 ? Math.max(...timestamps) : null
                };
            }

            // ===== CROSS-DEVICE IMAGE STORAGE =====

            // Convert image URL to base64 data for storage
            async convertImageToBase64(imageUrl) {
                try {
                    console.log(`üì∏ Converting image to base64: ${imageUrl.substring(0, 50)}...`);

                    // Create a canvas to convert image to base64
                    const img = new Image();
                    img.crossOrigin = 'anonymous'; // Handle CORS

                    return new Promise((resolve, reject) => {
                        img.onload = () => {
                            try {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');

                                // Set canvas size (optimize for web display)
                                const maxWidth = 400;
                                const maxHeight = 250;

                                let { width, height } = img;

                                // Maintain aspect ratio while limiting size
                                if (width > maxWidth) {
                                    height = (height * maxWidth) / width;
                                    width = maxWidth;
                                }
                                if (height > maxHeight) {
                                    width = (width * maxHeight) / height;
                                    height = maxHeight;
                                }

                                canvas.width = width;
                                canvas.height = height;

                                // Draw and convert to base64
                                ctx.drawImage(img, 0, 0, width, height);
                                const base64 = canvas.toDataURL('image/jpeg', 0.8); // Compress to 80% quality

                                // Check size limit
                                const sizeKB = Math.round(base64.length * 0.75 / 1024); // Rough base64 size calculation

                                if (sizeKB > this.maxImageSizeKB) {
                                    console.log(`‚ö†Ô∏è Image too large (${sizeKB}KB), using URL only`);
                                    resolve({ url: imageUrl, size: sizeKB, stored: false });
                                } else {
                                    console.log(`‚úÖ Image converted (${sizeKB}KB): ${imageUrl.substring(0, 30)}...`);
                                    resolve({ base64: base64, url: imageUrl, size: sizeKB, stored: true });
                                }
                            } catch (error) {
                                console.log(`‚ùå Canvas conversion failed: ${error.message}`);
                                resolve({ url: imageUrl, stored: false });
                            }
                        };

                        img.onerror = () => {
                            console.log(`‚ùå Image load failed: ${imageUrl}`);
                            resolve({ url: imageUrl, stored: false });
                        };

                        img.src = imageUrl;
                    });
                } catch (error) {
                    console.error('Image conversion error:', error);
                    return { url: imageUrl, stored: false };
                }
            }

            // ENHANCED: More aggressive synced image prioritization with debugging
            displayArticles(articles) {
                const container = document.getElementById('articlesContainer');

                if (articles.length === 0) {
                    this.displayEmptyState();
                    return;
                }

                // FIXED: Store what we're currently displaying
                this.currentDisplayedArticles = articles;

                // Check if mobile for performance optimization
                const isMobile = window.innerWidth <= 768;

                let imagesFromBackup = 0;
                let imagesFromCache = 0;
                let imagesNeedLoading = 0;

                console.log('üéØ DISPLAYING ARTICLES - Image Source Priority Check:');

                const articlesHTML = articles.map((article, displayIndex) => {
                    // Use the display index for the currently shown articles
                    const index = displayIndex;

                    let imageHTML = '';
                    let cacheStatus = 'loading';
                    let statusText = 'üîÑ Loading';
                    let imageSource = 'none';

                    // PRIORITY 1: Synced base64 images (HIGHEST PRIORITY - guaranteed same across devices)
                    if (article.cachedImage && article.cachedImage.base64) {
                        imageHTML = this.createImageHTML(article.cachedImage.base64, true);
                        cacheStatus = 'synced';
                        statusText = 'üåê Synced';
                        imageSource = 'synced_base64';
                        imagesFromBackup++;
                        console.log(`‚úÖ ${displayIndex}: Using SYNCED base64 for "${article.title.substring(0, 30)}..." (${Math.round(article.cachedImage.size)}KB)`);
                    }
                    // PRIORITY 2: Synced URLs (still cross-device but less reliable)
                    else if (article.cachedImage && article.cachedImage.url && !article.cachedImage.base64) {
                        imageHTML = this.createImageHTML(article.cachedImage.url, true);
                        cacheStatus = 'synced';
                        statusText = 'üîó Synced URL';
                        imageSource = 'synced_url';
                        imagesFromBackup++;
                        console.log(`‚úÖ ${displayIndex}: Using SYNCED URL for "${article.title.substring(0, 30)}..."`);
                    }
                    // PRIORITY 3: Local cache (device specific)
                    else if (this.getCachedImage(article)) {
                        imageHTML = this.createImageHTML(this.getCachedImage(article), true);
                        cacheStatus = 'cached';
                        statusText = 'üíæ Local Cache';
                        imageSource = 'local_cache';
                        imagesFromCache++;
                        console.log(`‚ö° ${displayIndex}: Using LOCAL cache for "${article.title.substring(0, 30)}..."`);
                    }
                    // PRIORITY 4: Article metadata (extract and sync immediately)
                    else if (this.getBestArticleImage(article)) {
                        const savedImage = this.getBestArticleImage(article);
                        imageHTML = this.createImageHTML(savedImage, false);
                        cacheStatus = 'metadata';
                        statusText = 'üìÑ Metadata';
                        imageSource = 'metadata';
                        console.log(`üìÑ ${displayIndex}: Using METADATA image for "${article.title.substring(0, 30)}..." - will sync`);

                        // Store this image for cross-device sync IMMEDIATELY
                        setTimeout(() => this.setArticleImageAndCache(article, index, savedImage, 'saved'), 100);
                    }
                    // PRIORITY 5: Need to extract from website (LAST resort)
                    else {
                        imageHTML = this.createPlaceholderHTML();
                        cacheStatus = 'loading';
                        statusText = isMobile ? 'üì± Loading...' : 'üîÑ Loading';
                        imageSource = 'needs_extraction';
                        imagesNeedLoading++;
                        console.log(`‚ùå ${displayIndex}: NO image found for "${article.title.substring(0, 30)}..." - needs extraction`);
                    }

                    return `
                    <div class="article-card" data-index="${index}" data-display-index="${displayIndex}" data-image-source="${imageSource}">
                        <div class="article-image" id="image-${index}">
                            ${imageHTML}
                            <div class="cache-indicator ${cacheStatus}">
                                ${statusText}
                            </div>
                        </div>
                        <div class="article-content" onclick="webReader.openReaderByDisplayIndex(${displayIndex})">
                            <h2 class="article-title">${this.escapeHtml(article.title)}</h2>
                            <p class="article-excerpt">${this.escapeHtml(article.excerpt)}</p>
                            <div class="article-meta">
                                <span class="article-domain">üåê ${this.getDomain(article.url)}</span>
                                <span class="article-date">üìÖ ${this.formatDate(article.dateAdded)}</span>
                            </div>
                            <div class="article-stats">
                                <span>‚è±Ô∏è ${article.readTime || 1} min read</span>
                                <span>üìù ${article.wordCount || 0} words</span>
                            </div>
                        </div>
                        <div class="article-actions">
                            <button class="action-btn read-btn" onclick="event.stopPropagation(); webReader.openReaderByDisplayIndex(${displayIndex})" title="Read article">
                                üìñ
                            </button>
                            <button class="action-btn refresh-image-btn" onclick="event.stopPropagation(); webReader.refreshSingleImage(${index}, ${displayIndex})" title="Refresh this image">
                                üñºÔ∏è
                            </button>
                            <button class="action-btn export-btn" onclick="event.stopPropagation(); webReader.exportArticleByDisplayIndex(${displayIndex})" title="Export article">
                                üì§
                            </button>
                            <button class="action-btn delete-btn" onclick="event.stopPropagation(); webReader.deleteArticleByDisplayIndex(${displayIndex})" title="Delete article">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                `}).join('');

                container.innerHTML = `<div class="articles-grid">${articlesHTML}</div>`;

                // Enhanced status reporting with debugging
                const totalReady = imagesFromBackup + imagesFromCache;

                console.log(`üìä IMAGE SUMMARY: ${imagesFromBackup} synced, ${imagesFromCache} cached, ${imagesNeedLoading} need loading`);

                if (imagesNeedLoading === 0) {
                    const message = isMobile ?
                        `üì± ALL images ready! ${totalReady}/${articles.length} synced perfectly ‚ú®` :
                        `‚úÖ ALL images ready! ${imagesFromBackup} synced, ${imagesFromCache} cached ‚ú®`;
                    this.updateStatus(message, 'success');
                } else {
                    const message = isMobile ?
                        `üì± ${totalReady} ready instantly, extracting ${imagesNeedLoading} more...` :
                        `‚ö° ${totalReady} ready instantly, extracting ${imagesNeedLoading} more...`;
                    this.updateStatus(message, 'loading');

                    // Load missing images - prioritize on mobile for faster completion
                    if (isMobile) {
                        setTimeout(() => this.loadMissingImages(articles), 500); // Start faster on mobile
                    } else {
                        this.loadMissingImages(articles);
                    }
                }
            }

            createImageHTML(imageUrl, fromCache = false) {
                return `
                    <img src="${imageUrl}" 
                         alt="Article image" 
                         style="
                            opacity: 0; 
                            transition: opacity 0.8s ease;
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: inherit;
                         "
                         onload="
                            this.style.opacity='1';
                            console.log('‚úÖ Image loaded ${fromCache ? 'from cache' : 'successfully'}');
                         " 
                         onerror="
                            console.log('‚ö†Ô∏è Image failed, tracking for retry');
                            const cardElement = this.closest('.article-card');
                            if (cardElement) {
                                const index = parseInt(cardElement.dataset.index);
                                if (!isNaN(index)) {
                                    webReader.failedImages.add(index);
                                    const indicator = this.parentElement.querySelector('.cache-indicator');
                                    if (indicator) {
                                        indicator.textContent = '‚ùå Failed';
                                        indicator.className = 'cache-indicator error';
                                    }
                                }
                            }
                            this.src='https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                         ">
                `;
            }

            createPlaceholderHTML() {
                return `
                    <div style="
                        width: 100%; 
                        height: 100%; 
                        background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                                   linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                                   linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                                   linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
                        background-size: 20px 20px;
                        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: #999;
                        animation: shimmer 1.5s ease-in-out infinite;
                    ">
                        <div style="text-align: center;">
                            <div style="font-size: 1.2em; margin-bottom: 5px;">üñºÔ∏è</div>
                            <div style="font-size: 0.7em;">Loading image...</div>
                        </div>
                    </div>
                `;
            }

            // Mobile-optimized image loading (SAME images, just optimized performance)
            async loadMissingImages(articles) {
                console.log('üé® SMART IMAGE LOADER - Loading same images for all devices...');

                const articlesNeedingImages = articles.filter((article, index) => {
                    // Check both stored backup images and local cache
                    const hasStoredImage = article.cachedImage && article.cachedImage.base64;
                    const hasCachedImage = this.getCachedImage(article);
                    return !hasStoredImage && !hasCachedImage;
                });

                if (articlesNeedingImages.length === 0) {
                    this.updateStatus(`‚úÖ All images loaded!`, 'success');
                    return;
                }

                const isMobile = window.innerWidth <= 768;
                let successCount = 0;
                const totalNew = articlesNeedingImages.length;

                console.log(`üîÑ Loading ${totalNew} SAME images${isMobile ? ' (mobile optimized)' : ''}`);

                // Mobile optimization: Load in smaller batches with longer delays for performance
                // But extract the SAME real images, not fallbacks
                const batchSize = isMobile ? 2 : 5; // Process fewer images at once on mobile
                const delayBetweenImages = isMobile ? 800 : 300; // Longer delays on mobile

                for (let i = 0; i < articlesNeedingImages.length; i += batchSize) {
                    const batch = articlesNeedingImages.slice(i, i + batchSize);

                    // Process batch - SAME extraction process for both mobile and desktop
                    await Promise.all(batch.map(async (article) => {
                        const originalIndex = articles.findIndex(a => a === article);

                        try {
                            const success = await this.extractAndCacheRealImage(article, originalIndex);
                            if (success) successCount++;
                        } catch (error) {
                            console.error(`Failed to extract image for article ${originalIndex}:`, error);
                            // Use category fallback for failed extractions (SAME on both platforms)
                            const fallbackImage = this.getCategoryBasedImage(article, originalIndex);
                            this.setArticleImageAndCache(article, originalIndex, fallbackImage, 'fallback');
                            successCount++;
                        }
                    }));

                    // Update progress with mobile-friendly messages
                    const progress = Math.round(((i + batchSize) / totalNew) * 100);
                    if (isMobile) {
                        this.updateStatus(`üì± Loading images... ${Math.min(i + batchSize, totalNew)}/${totalNew}`, 'loading');
                    } else {
                        this.updateStatus(`üîç Loading new images... ${Math.min(i + batchSize, totalNew)}/${totalNew} (${progress}%)`, 'loading');
                    }

                    // Delay between batches (longer on mobile for better performance)
                    if (i + batchSize < articlesNeedingImages.length) {
                        await new Promise(resolve => setTimeout(resolve, delayBetweenImages));
                    }
                }

                const totalCached = this.imageCache.size;

                if (isMobile) {
                    this.updateStatus(`üì± ${successCount} images loaded! Same as desktop üéâ`, 'success');
                } else {
                    this.updateStatus(`‚úÖ Loaded ${successCount}/${totalNew} new images! (${totalCached} total cached)`, 'success');
                }

                console.log(`üé® Image loading complete: ${successCount}/${totalNew} SAME images on both platforms`);
            }

            // ENHANCED: Force backup update when images are stored
            async setArticleImageAndCache(article, index, imageUrl, source) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return;

                // Update the DOM immediately
                imageElement.innerHTML = this.createImageHTML(imageUrl, false);

                // Update cache indicator
                const cacheIndicator = imageElement.querySelector('.cache-indicator');
                if (cacheIndicator) {
                    if (source === 'extracted') {
                        cacheIndicator.textContent = 'üåê Fresh';
                        cacheIndicator.className = 'cache-indicator fresh';
                    } else if (source === 'refreshed') {
                        cacheIndicator.textContent = 'üîÑ Refreshed';
                        cacheIndicator.className = 'cache-indicator fresh';
                    } else {
                        cacheIndicator.textContent = 'üíæ Cached';
                        cacheIndicator.className = 'cache-indicator cached';
                    }
                }

                // Store in local cache
                this.setCachedImage(article, imageUrl);

                // ENHANCED: Always store base64 data for cross-device sync (not just extracted images)
                if (this.storeImagesInBackup && (source === 'extracted' || source === 'saved' || source === 'fallback' || source === 'refreshed')) {
                    try {
                        console.log(`üîÑ Converting image for cross-device storage: ${article.title.substring(0, 30)}...`);
                        const imageData = await this.convertImageToBase64(imageUrl);

                        if (imageData.stored) {
                            // Find the article in our array and add image data
                            const articleIndex = this.articles.findIndex(a => a.url === article.url);
                            if (articleIndex !== -1) {
                                this.articles[articleIndex].cachedImage = {
                                    base64: imageData.base64,
                                    url: imageData.url,
                                    timestamp: Date.now(),
                                    size: imageData.size,
                                    source: source
                                };

                                console.log(`üíæ Stored ${imageData.size}KB image in backup for cross-device sync`);

                                // Update cache indicator to show it's stored for sync
                                if (cacheIndicator) {
                                    cacheIndicator.textContent = 'üåê Synced';
                                    cacheIndicator.className = 'cache-indicator synced';
                                }

                                // IMMEDIATELY save to OneDrive to ensure sync
                                if (this.accessToken) {
                                    console.log('üíæ Auto-saving to OneDrive for instant cross-device sync...');
                                    try {
                                        await this.updateOneDriveBackup();
                                        console.log('‚úÖ OneDrive backup updated with new image');
                                    } catch (error) {
                                        console.error('‚ö†Ô∏è Failed to auto-save backup:', error);
                                    }
                                }
                            }
                        } else {
                            console.log(`‚ö†Ô∏è Image too large for cross-device storage: ${imageData.size}KB`);
                        }
                    } catch (error) {
                        console.error('Error storing image for cross-device sync:', error);
                    }
                }
            }

            // Extract and cache image (enhanced version)
            async extractAndCacheRealImage(article, index) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return false;

                console.log(`üîç Extracting new image from: ${this.getDomain(article.url)}`);

                // Strategy 1: Try saved article images first (fastest)
                const savedImage = this.getBestArticleImage(article);
                if (savedImage) {
                    console.log(`‚úÖ Using saved image: ${article.title.substring(0, 30)}...`);
                    this.setArticleImageAndCache(article, index, savedImage, 'saved');
                    return true;
                }

                // Strategy 2: Extract image from the original website
                try {
                    const extractedImage = await this.fetchRealImageFromWebsite(article.url);
                    if (extractedImage) {
                        console.log(`‚úÖ Extracted real image: ${article.title.substring(0, 30)}...`);
                        this.setArticleImageAndCache(article, index, extractedImage, 'extracted');
                        return true;
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è Could not extract from website: ${error.message}`);
                }

                // Strategy 3: Use intelligent category-based fallback
                console.log(`üé® Using intelligent fallback: ${article.title.substring(0, 30)}...`);
                const fallbackImage = this.getCategoryBasedImage(article, index);
                this.setArticleImageAndCache(article, index, fallbackImage, 'fallback');
                return true;
            }

            // ENHANCED: Load articles with automatic token refresh
            async loadArticles() {
                // Ensure we have a valid token
                const hasValidToken = await this.ensureValidToken();
                if (!hasValidToken) {
                    this.updateConnectionStatus(false);
                    this.updateStatus('Authentication expired. Please reconnect.', 'error');
                    return;
                }

                try {
                    this.updateStatus('Loading articles... ‚è≥', 'loading');

                    const listResponse = await fetch('https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket:/children', {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!listResponse.ok) {
                        if (listResponse.status === 401) {
                            // Try to refresh token
                            const refreshSuccess = await this.refreshAccessToken();
                            if (refreshSuccess) {
                                // Retry the request with new token
                                return this.loadArticles();
                            } else {
                                this.clearTokens();
                                this.updateConnectionStatus(false);
                                this.updateStatus('Session expired. Please reconnect.', 'error');
                                return;
                            }
                        }
                        throw new Error(`Failed to list files: ${listResponse.status}`);
                    }

                    const fileList = await listResponse.json();
                    const backupFiles = fileList.value.filter(file =>
                        file.name.startsWith('mypocket-backup-') && file.name.endsWith('.json')
                    );

                    if (backupFiles.length === 0) {
                        this.updateStatus('No backup files found. Save some articles with the browser extension first.', 'error');
                        this.displayEmptyState();
                        return;
                    }

                    const latestFile = backupFiles.sort((a, b) =>
                        new Date(b.lastModifiedDateTime) - new Date(a.lastModifiedDateTime)
                    )[0];

                    const downloadResponse = await fetch(`https://graph.microsoft.com/v1.0/me/drive/items/${latestFile.id}/content`, {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`
                        }
                    });

                    if (!downloadResponse.ok) {
                        throw new Error(`Failed to download backup: ${downloadResponse.status}`);
                    }

                    const backupContent = await downloadResponse.text();
                    const backup = JSON.parse(backupContent);

                    this.articles = backup.articles || [];
                    this.currentDisplayedArticles = this.articles; // Initialize displayed articles

                    // Auto-categorize all articles on load with AI
                    console.log('üìÇ Auto-categorizing loaded articles...');
                    this.recategorizeAllArticles();

                    this.displayArticles(this.articles);
                    
                    // Update sidebar counts
                    this.updateSidebarCounts();

                    const cacheStats = this.getCacheStats();
                    const storedImages = this.articles.filter(a => a.cachedImage).length;
                    const dynamicCount = this.dynamicCategories.size;
                    const aiIndicator = dynamicCount > 0 ? ` (${dynamicCount} auto-discovered categories)` : '';
                    
                    this.updateStatus(`‚úÖ Loaded ${this.articles.length} articles from ${latestFile.name} (${storedImages} with stored images, ${cacheStats.total} locally cached)${aiIndicator}`, 'success');

                } catch (error) {
                    console.error('Error loading articles:', error);
                    this.updateStatus(`Error loading articles: ${error.message}`, 'error');
                }
            }

            displayEmptyState() {
                const container = document.getElementById('articlesContainer');
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìñ</div>
                        <h3>No articles found</h3>
                        <p>Use the MyPocket browser extension to save articles, then refresh this page to see intelligent categorization!</p>
                    </div>`;
            }

            searchArticles(query) {
                // Clear any active category filter when searching
                if (this.activeCategory && query.trim() !== '') {
                    this.activeCategory = null;
                    this.updateCategoryUI();
                }

                if (!query || query.trim() === '') {
                    this.currentDisplayedArticles = this.articles;
                    this.displayArticles(this.articles);
                    if (this.articles.length > 0) {
                        this.updateStatus(`Showing all ${this.articles.length} articles`, 'success');
                    }
                    return;
                }

                const searchTerm = query.toLowerCase().trim();
                console.log(`üîç Enhanced searching for: "${searchTerm}"`);

                const filtered = this.articles.filter(article => {
                    // Search in title (always exists)
                    const titleMatch = article.title && article.title.toLowerCase().includes(searchTerm);

                    // Search in excerpt (usually exists)
                    const excerptMatch = article.excerpt && article.excerpt.toLowerCase().includes(searchTerm);

                    // Search in various content fields
                    const contentFields = ['content', 'textContent', 'html', 'fullContent', 'body', 'readableContent'];
                    const contentMatch = contentFields.some(field =>
                        article[field] && typeof article[field] === 'string' &&
                        article[field].toLowerCase().includes(searchTerm)
                    );

                    // Search in author (if exists)
                    const authorMatch = article.author && article.author.toLowerCase().includes(searchTerm);

                    // Search in domain
                    const domainMatch = this.getDomain(article.url).toLowerCase().includes(searchTerm);

                    // Search in URL
                    const urlMatch = article.url && article.url.toLowerCase().includes(searchTerm);

                    // Search in tags or categories (if they exist)
                    const tagsMatch = article.tags && Array.isArray(article.tags) &&
                        article.tags.some(tag => tag.toLowerCase().includes(searchTerm));

                    // Search in AI category
                    if (!article.category) {
                        this.categorizeArticle(article);
                    }
                    const categoryMatch = article.category && article.category.toLowerCase().includes(searchTerm);

                    // Search in AI-extracted keywords
                    const keywordMatch = article.extractedKeywords && Array.isArray(article.extractedKeywords) &&
                        article.extractedKeywords.some(keyword => keyword.toLowerCase().includes(searchTerm));

                    return titleMatch || excerptMatch || contentMatch || authorMatch || domainMatch || urlMatch || tagsMatch || categoryMatch || keywordMatch;
                });

                console.log(`üéØ Search results: ${filtered.length}/${this.articles.length} articles`);

                // FIXED: Store the filtered articles and display them
                this.currentDisplayedArticles = filtered;
                this.displayArticles(filtered);

                if (filtered.length === 0) {
                    this.updateStatus(`No articles found matching "${query}". Try different keywords or check categories.`, 'error');
                } else if (filtered.length === 1) {
                    this.updateStatus(`Found 1 article matching "${query}"`, 'success');
                } else {
                    this.updateStatus(`Found ${filtered.length} articles matching "${query}"`, 'success');
                }
            }

            // FIXED: New functions that work with display indices
            openReaderByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                this.currentArticle = article;
                const overlay = document.getElementById('readerOverlay');

                // Set title and meta info
                document.getElementById('readerTitle').textContent = article.title;
                document.getElementById('readerDate').textContent = this.formatDate(article.dateAdded);
                document.getElementById('readerDomain').textContent = this.getDomain(article.url);
                document.getElementById('readerTime').textContent = `${article.readTime || 1} min read`;

                // Show loading state first
                document.getElementById('readerContent').innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                        <p>Checking for article content...</p>
                    </div>
                `;

                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';

                // Try to get content, fetch if needed
                setTimeout(() => this.loadArticleContent(article), 100);
            }

            exportArticleByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                try {
                    const html = this.createArticleHTML(article);
                    const filename = `${this.sanitizeFilename(article.title)}.html`;
                    this.downloadFile(html, filename, 'text/html');
                    this.updateStatus(`üì§ Article "${article.title}" exported successfully!`, 'success');
                } catch (error) {
                    console.error('Error exporting article:', error);
                    this.updateStatus(`‚ùå Failed to export article: ${error.message}`, 'error');
                }
            }

            async deleteArticleByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                if (confirm(`Delete "${article.title}"?\n\nThis will permanently remove the article from your OneDrive backup.`)) {
                    try {
                        // Find the original index in the main articles array
                        const originalIndex = this.articles.findIndex(a =>
                            a.url === article.url && a.title === article.title
                        );

                        if (originalIndex === -1) {
                            throw new Error('Could not find article in main collection');
                        }

                        // Remove from cache
                        const cacheKey = this.getCacheKey(article);
                        this.imageCache.delete(cacheKey);
                        this.saveImageCache();

                        // Remove from main articles array
                        this.articles.splice(originalIndex, 1);

                        // Remove from currently displayed articles
                        this.currentDisplayedArticles.splice(displayIndex, 1);

                        if (this.accessToken) {
                            this.updateStatus('üè∑Ô∏è Updating categories and OneDrive backup...', 'loading');
                            await this.updateOneDriveBackup();
                            // Recategorize after deletion
                            this.recategorizeAllArticles();
                            this.updateStatus(`‚úÖ Article deleted and backup updated. ${this.articles.length} articles remaining.`, 'success');
                        } else {
                            this.updateStatus(`‚ùå Article deleted locally but OneDrive backup not updated (not connected).`, 'error');
                        }

                        // Refresh the display with current articles
                        this.displayArticles(this.currentDisplayedArticles);

                    } catch (error) {
                        console.error('Error deleting article:', error);
                        this.updateStatus(`‚ùå Failed to delete article: ${error.message}`, 'error');
                    }
                }
            }

            // Keep original functions for backward compatibility
            openReader(index) {
                this.currentArticle = this.articles[index];
                const overlay = document.getElementById('readerOverlay');

                // Set title and meta info
                document.getElementById('readerTitle').textContent = this.currentArticle.title;
                document.getElementById('readerDate').textContent = this.formatDate(this.currentArticle.dateAdded);
                document.getElementById('readerDomain').textContent = this.getDomain(this.currentArticle.url);
                document.getElementById('readerTime').textContent = `${this.currentArticle.readTime || 1} min read`;

                // Show loading state first
                document.getElementById('readerContent').innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                        <p>Checking for article content...</p>
                    </div>
                `;

                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';

                // Try to get content, fetch if needed
                setTimeout(() => this.loadArticleContent(this.currentArticle), 100);
            }

            async loadArticleContent(article) {
                console.log('üöÄ CONTENT LOADER WITH CACHING');
                const contentElement = document.getElementById('readerContent');

                // First try to get saved content
                let content = this.getArticleContent(article);

                // If no saved content found, try to fetch from original URL
                if (!content) {
                    console.log('üåê No saved content found. Attempting to fetch from original URL...');

                    try {
                        // Show fetching status
                        contentElement.innerHTML = `
                            <div style="text-align: center; padding: 40px;">
                                <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                                <p><strong>üåê Fetching article content...</strong></p>
                                <p style="font-size: 0.9em; color: var(--text-secondary);">
                                    Loading from ${this.getDomain(article.url)}
                                </p>
                                <p style="font-size: 0.8em; color: var(--text-secondary);">
                                    This may take a few seconds...
                                </p>
                            </div>
                        `;

                        // Fetch content using proxy services
                        const fetchedContent = await this.fetchArticleContent(article.url);

                        if (fetchedContent && fetchedContent.trim()) {
                            content = fetchedContent;
                            console.log('‚úÖ Successfully fetched article content');
                            this.updateStatus('‚úÖ Article content loaded successfully!', 'success');
                        } else {
                            throw new Error('No content extracted from fetched page');
                        }

                    } catch (error) {
                        console.log('‚ùå Failed to fetch content:', error.message);
                        this.updateStatus('‚ùå Could not fetch article content. Using fallback.', 'error');
                        content = this.getFallbackContent(article, error.message);
                    }
                } else {
                    console.log('‚úÖ Using saved content');
                    this.updateStatus('‚úÖ Article loaded from saved content', 'success');
                }

                // Display the final content
                contentElement.innerHTML = content;
            }

            async fetchArticleContent(url) {
                try {
                    console.log(`üåê Starting fetch for: ${url}`);

                    // Method 1: Try using AllOrigins proxy (most reliable)
                    try {
                        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                        console.log(`Trying AllOrigins proxy...`);

                        const response = await fetch(proxyUrl);

                        if (response.ok) {
                            const data = await response.json();
                            const html = data.contents;

                            if (html && html.length > 1000) { // Ensure we got substantial content
                                console.log(`‚úÖ AllOrigins success: ${html.length} chars`);
                                const extractedContent = this.extractContentFromHTML(html, url);
                                if (extractedContent && extractedContent.length > 500) {
                                    return extractedContent;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`AllOrigins failed: ${error.message}`);
                    }

                    // Method 2: Try CORS proxy
                    try {
                        const corsProxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                        console.log(`Trying CORS proxy...`);

                        const response = await fetch(corsProxyUrl);

                        if (response.ok) {
                            const html = await response.text();

                            if (html && html.length > 1000) {
                                console.log(`‚úÖ CORS proxy success: ${html.length} chars`);
                                const extractedContent = this.extractContentFromHTML(html, url);
                                if (extractedContent && extractedContent.length > 500) {
                                    return extractedContent;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`CORS proxy failed: ${error.message}`);
                    }

                    // Method 3: Try direct fetch (will likely fail due to CORS, but worth trying)
                    try {
                        console.log(`Trying direct fetch...`);
                        const response = await fetch(url, {
                            mode: 'cors',
                            headers: {
                                'User-Agent': 'Mozilla/5.0 (compatible; MyPocket AI Reader)'
                            }
                        });

                        if (response.ok) {
                            const html = await response.text();
                            console.log(`‚úÖ Direct fetch success: ${html.length} chars`);
                            return this.extractContentFromHTML(html, url);
                        }
                    } catch (error) {
                        console.log(`Direct fetch failed (expected): ${error.message}`);
                    }

                    throw new Error('All proxy methods failed to fetch content');

                } catch (error) {
                    console.error('‚ùå All fetch methods failed:', error);
                    throw error;
                }
            }

            extractContentFromHTML(html, url) {
                try {
                    // Create a temporary DOM to parse the HTML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    // Remove unwanted elements
                    const unwantedSelectors = [
                        'script', 'style', 'nav', 'header', 'footer',
                        '.sidebar', '.menu', '.navigation', '.comments',
                        '.advertisement', '.ads', '.social-share',
                        '[role="banner"]', '[role="navigation"]', '[role="complementary"]'
                    ];

                    unwantedSelectors.forEach(selector => {
                        doc.querySelectorAll(selector).forEach(el => el.remove());
                    });

                    // Try to find the main content using common selectors
                    const contentSelectors = [
                        'article',
                        '[role="main"]',
                        '.post-content', '.entry-content', '.article-content',
                        '.content', '.main-content', '.post-body',
                        '.entry', '.post', '.article-body',
                        'main', '#content', '#main'
                    ];

                    let contentElement = null;

                    for (const selector of contentSelectors) {
                        contentElement = doc.querySelector(selector);
                        if (contentElement && contentElement.textContent.trim().length > 200) {
                            break;
                        }
                    }

                    // If no main content found, try to get paragraphs from body
                    if (!contentElement || contentElement.textContent.trim().length < 200) {
                        const paragraphs = Array.from(doc.querySelectorAll('p'))
                            .filter(p => p.textContent.trim().length > 50)
                            .slice(0, 20); // Take first 20 substantial paragraphs

                        if (paragraphs.length > 0) {
                            const div = doc.createElement('div');
                            paragraphs.forEach(p => div.appendChild(p.cloneNode(true)));
                            contentElement = div;
                        }
                    }

                    if (contentElement) {
                        // Clean up the content
                        let content = contentElement.innerHTML;

                        // Fix relative URLs to absolute
                        const baseUrl = new URL(url).origin;
                        content = content.replace(/src="\/([^"]+)"/g, `src="${baseUrl}/$1"`);
                        content = content.replace(/href="\/([^"]+)"/g, `href="${baseUrl}/$1"`);

                        // Add a note about the source
                        content = `
                            <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                                <p style="margin: 0; font-size: 0.9em;">
                                    <strong>üì° Content fetched from original source</strong><br>
                                    This article content was retrieved in real-time from <a href="${url}" target="_blank" style="color: #1976d2;">${this.getDomain(url)}</a>
                                </p>
                            </div>
                            ${content}
                        `;

                        return content;
                    }

                    throw new Error('Could not extract readable content from page');

                } catch (error) {
                    console.error('Content extraction error:', error);
                    throw error;
                }
            }

            getFallbackContent(article, errorMessage) {
                return `
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h3>üìÑ Content Not Available</h3>
                        <p>We couldn't load the full article content. This can happen because:</p>
                        <ul style="margin: 15px 0;">
                            <li>The website blocks automated content fetching</li>
                            <li>CORS (Cross-Origin) restrictions prevent access</li>
                            <li>The article content wasn't saved by the browser extension</li>
                            <li>Network connectivity issues</li>
                        </ul>
                        
                        <p><strong>What you can do:</strong></p>
                        <ol style="margin: 15px 0;">
                            <li><strong>Visit the original article</strong> using the button below</li>
                            <li><strong>Re-save the article</strong> with your browser extension</li>
                            <li><strong>Check extension settings</strong> for content extraction options</li>
                        </ol>
                        
                        <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <p><strong>Available excerpt:</strong></p>
                            <p style="font-style: italic;">${article.excerpt || 'No excerpt available'}</p>
                            
                            ${article.category ? `
                                <p><strong>ü§ñ AI Category:</strong> ${article.category} 
                                   ${article.categoryConfidence ? `(${article.categoryConfidence} confidence)` : ''}
                                </p>
                            ` : ''}
                            
                            ${article.extractedKeywords ? `
                                <p><strong>üîç AI Keywords:</strong> ${article.extractedKeywords.slice(0, 5).join(', ')}</p>
                            ` : ''}
                        </div>
                        
                        <div style="text-align: center; margin: 20px 0;">
                            <a href="${article.url}" target="_blank" style="display: inline-block; background: #ee5a24; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                                üîó Read Full Article
                            </a>
                        </div>
                        
                        <details style="margin-top: 20px;">
                            <summary style="cursor: pointer; color: #666;">Technical Details</summary>
                            <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
                                Error: ${errorMessage}
                            </p>
                        </details>
                    </div>
                `;
            }

            // Get the best available content for reading - simplified version
            getArticleContent(article) {
                console.log('üìñ Checking for saved content...');

                // Try content fields in order
                const contentFields = ['content', 'html', 'fullContent', 'textContent', 'body', 'readableContent', 'articleContent', 'savedContent'];

                for (const field of contentFields) {
                    if (article[field] && article[field].trim()) {
                        console.log(`‚úÖ Found content in ${field} (${article[field].length} chars)`);
                        return article[field];
                    }
                }

                // Look for any substantial text content
                for (const [key, value] of Object.entries(article)) {
                    if (typeof value === 'string' && value.length > 200 && key !== 'excerpt' && key !== 'url') {
                        console.log(`‚úÖ Found substantial content in ${key} (${value.length} chars)`);
                        return value;
                    }
                }

                console.log('‚ùå No saved content found');
                return null;
            }

            closeReader() {
                const overlay = document.getElementById('readerOverlay');
                overlay.classList.remove('active');
                document.body.style.overflow = 'auto';
            }

            openOriginal() {
                if (this.currentArticle) {
                    window.open(this.currentArticle.url, '_blank');
                }
            }

            async deleteArticle(index) {
                const article = this.articles[index];
                if (!article) return;

                if (confirm(`Delete "${article.title}"?\n\nThis will permanently remove the article from your OneDrive backup.`)) {
                    try {
                        // Remove from cache
                        const cacheKey = this.getCacheKey(article);
                        this.imageCache.delete(cacheKey);
                        this.saveImageCache();

                        this.articles.splice(index, 1);

                        // Update current displayed articles if this article is in the current view
                        const displayedIndex = this.currentDisplayedArticles.findIndex(a =>
                            a.url === article.url && a.title === article.title
                        );
                        if (displayedIndex !== -1) {
                            this.currentDisplayedArticles.splice(displayedIndex, 1);
                        }

                        if (this.accessToken) {
                            this.updateStatus('üè∑Ô∏è Updating categories and OneDrive backup...', 'loading');
                            await this.updateOneDriveBackup();
                            // Recategorize after deletion
                            this.recategorizeAllArticles();
                            this.updateStatus(`‚úÖ Article deleted and backup updated. ${this.articles.length} articles remaining.`, 'success');
                        } else {
                            this.updateStatus(`‚ùå Article deleted locally but OneDrive backup not updated (not connected).`, 'error');
                        }

                        // Refresh the display with current articles
                        this.displayArticles(this.currentDisplayedArticles);

                    } catch (error) {
                        console.error('Error deleting article:', error);
                        this.updateStatus(`‚ùå Failed to delete article: ${error.message}`, 'error');
                    }
                }
            }

            exportArticle(index) {
                const article = this.articles[index];
                if (!article) return;

                try {
                    const html = this.createArticleHTML(article);
                    const filename = `${this.sanitizeFilename(article.title)}.html`;
                    this.downloadFile(html, filename, 'text/html');
                    this.updateStatus(`üì§ Article "${article.title}" exported successfully!`, 'success');
                } catch (error) {
                    console.error('Error exporting article:', error);
                    this.updateStatus(`‚ùå Failed to export article: ${error.message}`, 'error');
                }
            }

            // Enhanced backup to include image data and AI analysis
            async updateOneDriveBackup() {
                if (!this.accessToken) {
                    throw new Error('Not connected to OneDrive');
                }

                // Calculate backup size with images
                const articlesWithImages = this.articles.filter(a => a.cachedImage);
                const totalImageSizeKB = articlesWithImages.reduce((total, article) => {
                    return total + (article.cachedImage ? article.cachedImage.size || 0 : 0);
                }, 0);

                const articlesWithAI = this.articles.filter(a => a.category || a.extractedKeywords);
                const dynamicCategoriesCount = this.dynamicCategories.size;

                console.log(`üì¶ Creating AI-enhanced backup with ${articlesWithImages.length} stored images (${Math.round(totalImageSizeKB)}KB) and ${articlesWithAI.length} AI-analyzed articles`);

                const backup = {
                    articles: this.articles, // This now includes cachedImage data and AI analysis
                    settings: {
                        storeImagesInBackup: this.storeImagesInBackup,
                        maxImageSizeKB: this.maxImageSizeKB,
                        enableDynamicCategories: this.enableDynamicCategories,
                        minCategoryConfidence: this.minCategoryConfidence
                    },
                    aiAnalysis: {
                        dynamicCategories: Object.fromEntries(this.dynamicCategories),
                        categoryCounts: Object.fromEntries(this.categories),
                        totalAnalyzedArticles: articlesWithAI.length,
                        dynamicCategoriesFound: dynamicCategoriesCount
                    },
                    exportDate: new Date().toISOString(),
                    version: "5.0", // Bump version for AI categorization
                    deviceInfo: {
                        browser: "MyPocket AI Reader with PKCE Security + AI Categorization",
                        platform: navigator.platform,
                        timestamp: Date.now(),
                        articleCount: this.articles.length,
                        storedImages: articlesWithImages.length,
                        totalImageSizeKB: Math.round(totalImageSizeKB),
                        aiAnalyzedArticles: articlesWithAI.length,
                        dynamicCategories: dynamicCategoriesCount,
                        authMethod: "Authorization Code + PKCE"
                    }
                };

                const fileName = `mypocket-backup-${new Date().toISOString().split('T')[0]}.json`;
                const fileContent = JSON.stringify(backup, null, 2);

                // Check if backup is getting too large (>10MB)
                const backupSizeMB = fileContent.length / (1024 * 1024);
                if (backupSizeMB > 10) {
                    console.warn(`‚ö†Ô∏è Large backup detected: ${backupSizeMB.toFixed(1)}MB`);
                }

                const uploadUrl = `https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket/${fileName}:/content`;

                const uploadResponse = await fetch(uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${this.accessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: fileContent
                });

                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    throw new Error(`Failed to update OneDrive backup: ${uploadResponse.status} - ${errorText}`);
                }

                console.log(`‚úÖ AI-enhanced backup saved with ${articlesWithImages.length} images (${Math.round(totalImageSizeKB)}KB) and ${dynamicCategoriesCount} AI-discovered categories`);
                return await uploadResponse.json();
            }

            createArticleHTML(article) {
                const aiInfo = article.category ? `
                    <div style="background: #e8f5e8; padding: 12px; border-radius: 8px; margin: 16px 0;">
                        <strong>ü§ñ AI Analysis:</strong><br>
                        Category: ${article.category} ${article.categoryConfidence ? `(${article.categoryConfidence} confidence)` : ''}<br>
                        ${article.extractedKeywords ? `Keywords: ${article.extractedKeywords.slice(0, 5).join(', ')}` : ''}
                    </div>
                ` : '';

                return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHtml(article.title)}</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 40px 20px; 
            line-height: 1.7; 
            color: #333;
        }
        .header { 
            border-bottom: 3px solid #ee5a24; 
            margin-bottom: 32px; 
            padding-bottom: 24px; 
        }
        .title { 
            font-size: 2.4em; 
            font-weight: bold; 
            margin-bottom: 16px; 
            color: #2c3e50; 
            line-height: 1.2; 
        }
        .meta { 
            color: #7f8c8d; 
            font-size: 0.95em; 
            margin-bottom: 24px; 
        }
        .content { 
            font-size: 1.15em; 
            line-height: 1.8; 
        }
        .content img { 
            max-width: 100%; 
            height: auto; 
            margin: 24px 0; 
            border-radius: 8px; 
        }
        .content p { 
            margin-bottom: 1.4em; 
        }
        .footer { 
            margin-top: 48px; 
            padding-top: 24px; 
            border-top: 2px solid #f0f0f0; 
            color: #666; 
            font-size: 0.9em; 
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">${this.escapeHtml(article.title)}</h1>
        <div class="meta">
            <div style="margin-bottom: 8px;">üåê From: <a href="${article.url}" style="color: #ee5a24;">${this.getDomain(article.url)}</a></div>
            ${article.author ? `<div style="margin-bottom: 8px;">‚úçÔ∏è By: ${this.escapeHtml(article.author)}</div>` : ''}
            <div style="margin-bottom: 8px;">üìÖ Saved: ${this.formatDate(article.dateAdded)}</div>
            <div>‚è±Ô∏è Reading time: ${article.readTime || 1} minutes</div>
        </div>
        ${aiInfo}
    </div>
    <div class="content">
        ${article.content}
    </div>
    <div class="footer">
        <p><strong>ü§ñ Exported from MyPocket AI Reader (PKCE Secured)</strong></p>
        <p>Original URL: <a href="${article.url}" style="color: #ee5a24;">${article.url}</a></p>
        <p>Export Date: ${new Date().toLocaleDateString()}</p>
        ${article.category ? `<p>AI Category: ${article.category}</p>` : ''}
    </div>
</body>
</html>`;
            }

            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                URL.revokeObjectURL(url);
            }

            // Enhanced image handling
            getBestArticleImage(article) {
                if (article.images && article.images.length > 0) {
                    let bestImage = article.images[0];

                    for (const img of article.images) {
                        if (img.width && img.height) {
                            if (img.width >= 300 && img.height >= 150) {
                                bestImage = img;
                                break;
                            }
                        }
                    }

                    return bestImage.src || bestImage.url || bestImage;
                }

                if (article.featuredImage) {
                    return article.featuredImage;
                }

                if (article.image) {
                    return article.image;
                }

                if (article.content) {
                    const imgMatch = article.content.match(/<img[^>]+src="([^"]+)"/i);
                    if (imgMatch && imgMatch[1]) {
                        return imgMatch[1];
                    }
                }

                return null;
            }

            // Fetch the actual featured image from a website
            async fetchRealImageFromWebsite(url) {
                try {
                    console.log(`üåê Fetching webpage to extract image: ${url}`);

                    // Method 1: Try AllOrigins proxy
                    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                    const response = await fetch(proxyUrl);

                    if (!response.ok) {
                        throw new Error('Failed to fetch webpage');
                    }

                    const data = await response.json();
                    const html = data.contents;

                    if (!html || html.length < 500) {
                        throw new Error('No substantial HTML content received');
                    }

                    // Parse the HTML and extract the best image
                    const extractedImageUrl = this.parseHTMLForBestImage(html, url);

                    if (extractedImageUrl) {
                        console.log(`üéØ Found image: ${extractedImageUrl}`);
                        return extractedImageUrl;
                    }

                    throw new Error('No suitable image found in webpage');

                } catch (error) {
                    console.log(`‚ùå Website image extraction failed: ${error.message}`);

                    // Try alternative proxy methods
                    try {
                        return await this.tryAlternativeImageExtraction(url);
                    } catch (altError) {
                        console.log(`‚ùå Alternative extraction also failed: ${altError.message}`);
                        throw error;
                    }
                }
            }

            // Parse HTML to find the best image
            parseHTMLForBestImage(html, baseUrl) {
                try {
                    // Create a DOM parser
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    // Strategy 1: Look for Open Graph image (most reliable)
                    const ogImage = doc.querySelector('meta[property="og:image"]');
                    if (ogImage) {
                        const imageUrl = this.makeAbsoluteUrl(ogImage.getAttribute('content'), baseUrl);
                        if (this.isValidImageUrl(imageUrl)) {
                            console.log(`üéØ Found Open Graph image: ${imageUrl}`);
                            return imageUrl;
                        }
                    }

                    // Strategy 2: Look for Twitter card image
                    const twitterImage = doc.querySelector('meta[name="twitter:image"], meta[property="twitter:image"]');
                    if (twitterImage) {
                        const imageUrl = this.makeAbsoluteUrl(twitterImage.getAttribute('content'), baseUrl);
                        if (this.isValidImageUrl(imageUrl)) {
                            console.log(`üéØ Found Twitter card image: ${imageUrl}`);
                            return imageUrl;
                        }
                    }

                    // Strategy 3: Look for article featured image
                    const featuredSelectors = [
                        '.featured-image img',
                        '.hero-image img',
                        '.post-thumbnail img',
                        '.article-image img',
                        '.entry-image img',
                        '.wp-post-image',
                        'article img:first-of-type',
                        '.content img:first-of-type',
                        '.post-content img:first-of-type'
                    ];

                    for (const selector of featuredSelectors) {
                        const img = doc.querySelector(selector);
                        if (img) {
                            const src = img.getAttribute('src') || img.getAttribute('data-src') || img.getAttribute('data-lazy-src');
                            if (src) {
                                const imageUrl = this.makeAbsoluteUrl(src, baseUrl);
                                if (this.isValidImageUrl(imageUrl) && !this.isIconOrLogo(src)) {
                                    console.log(`üéØ Found featured image: ${imageUrl}`);
                                    return imageUrl;
                                }
                            }
                        }
                    }

                    // Strategy 4: Look for the first substantial image in the content
                    const allImages = Array.from(doc.querySelectorAll('img')).filter(img => {
                        const src = img.getAttribute('src') || img.getAttribute('data-src');
                        const width = img.getAttribute('width') || img.style.width;
                        const height = img.getAttribute('height') || img.style.height;

                        // Filter out small images, icons, and logos
                        return src &&
                            !this.isIconOrLogo(src) &&
                            !this.isSmallImage(width, height) &&
                            !src.includes('avatar') &&
                            !src.includes('profile');
                    });

                    for (const img of allImages) {
                        const src = img.getAttribute('src') || img.getAttribute('data-src');
                        if (src) {
                            const imageUrl = this.makeAbsoluteUrl(src, baseUrl);
                            if (this.isValidImageUrl(imageUrl)) {
                                console.log(`üéØ Found content image: ${imageUrl}`);
                                return imageUrl;
                            }
                        }
                    }

                    console.log(`‚ùå No suitable image found in HTML`);
                    return null;

                } catch (error) {
                    console.error('HTML parsing error:', error);
                    return null;
                }
            }

            // Try alternative image extraction methods
            async tryAlternativeImageExtraction(url) {
                // Method 1: Try CORS proxy
                try {
                    const corsProxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                    const response = await fetch(corsProxyUrl);

                    if (response.ok) {
                        const html = await response.text();
                        const extractedImage = this.parseHTMLForBestImage(html, url);
                        if (extractedImage) return extractedImage;
                    }
                } catch (error) {
                    console.log(`CORS proxy failed: ${error.message}`);
                }

                // Method 2: Try to guess common image patterns based on URL
                const guessedImage = this.guessImageFromUrl(url);
                if (guessedImage) return guessedImage;

                throw new Error('All alternative extraction methods failed');
            }

            // Guess image from URL patterns (for known sites)
            guessImageFromUrl(url) {
                const domain = this.getDomain(url).toLowerCase();

                // Medium articles often have predictable image patterns
                if (domain.includes('medium.com')) {
                    // Try to extract the article ID and construct image URL
                    const match = url.match(/\/([a-f0-9]+)$/);
                    if (match) {
                        return `https://miro.medium.com/max/1400/1*${match[1]}.png`;
                    }
                }

                // GitHub repository images
                if (domain.includes('github.com')) {
                    const pathMatch = url.match(/github\.com\/([^\/]+)\/([^\/]+)/);
                    if (pathMatch) {
                        return `https://opengraph.githubassets.com/1/${pathMatch[1]}/${pathMatch[2]}`;
                    }
                }

                // YouTube videos
                if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                    const videoIdMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/);
                    if (videoIdMatch) {
                        return `https://img.youtube.com/vi/${videoIdMatch[1]}/maxresdefault.jpg`;
                    }
                }

                return null;
            }

            // Enhanced URL validation
            isValidImageUrl(url) {
                if (!url || typeof url !== 'string') return false;

                // Must be a valid URL
                try {
                    new URL(url);
                } catch {
                    return false;
                }

                // Must have common image extensions or be from known image services
                const imagePattern = /\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i;
                const imageServices = ['unsplash.com', 'images.unsplash.com', 'picsum.photos', 'via.placeholder.com'];

                return imagePattern.test(url) || imageServices.some(service => url.includes(service));
            }

            // Enhanced icon/logo detection
            isIconOrLogo(src) {
                if (!src) return false;

                const iconPatterns = [
                    'icon', 'logo', 'avatar', 'profile', 'favicon', 'sprite',
                    'button', 'badge', 'social', 'thumb', 'thumbnail',
                    '/icons/', '/images/icons/', 'gravatar', 'user-content'
                ];

                const srcLower = src.toLowerCase();
                return iconPatterns.some(pattern => srcLower.includes(pattern)) ||
                    srcLower.includes('.ico') ||
                    (srcLower.includes('64x64') || srcLower.includes('32x32'));
            }

            // Check if image dimensions suggest it's too small
            isSmallImage(width, height) {
                if (!width && !height) return false;

                const w = parseInt(width) || 0;
                const h = parseInt(height) || 0;

                return (w > 0 && w < 200) || (h > 0 && h < 150);
            }

            // Get category-based images that are CONSISTENT across devices (not based on index)
            getCategoryBasedImage(article, index) {
                const domain = this.getDomain(article.url).toLowerCase();
                const title = article.title.toLowerCase();
                const url = article.url.toLowerCase();

                // Create a consistent seed based on article content (NOT display order)
                const articleSeed = article.url + article.title;
                let hash = 0;
                for (let i = 0; i < articleSeed.length; i++) {
                    const char = articleSeed.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                const consistentIndex = Math.abs(hash);

                // Use AI category if available for better image selection
                if (article.category && this.categoryKeywords[article.category]) {
                    const categoryData = this.categoryKeywords[article.category];
                    
                    // Technology/Programming
                    if (article.category === 'Technology') {
                        return `https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    // Business/Finance
                    if (article.category === 'Business' || article.category === 'Finance') {
                        return `https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    // Design/Creative
                    if (article.category === 'Design') {
                        return `https://images.unsplash.com/photo-1561070791-2526d30994b5?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    // Science
                    if (article.category === 'Science') {
                        return `https://images.unsplash.com/photo-1532094349884-543bc11b234d?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    // Health & Fitness
                    if (article.category === 'Health & Fitness') {
                        return `https://images.unsplash.com/photo-1571019613454-1cb2f99b2d8b?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    // News
                    if (article.category === 'News') {
                        return `https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    // Food & Cooking
                    if (article.category === 'Food & Cooking') {
                        return `https://images.unsplash.com/photo-1504674900247-0877df9cc836?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    // Travel
                    if (article.category === 'Travel') {
                        return `https://images.unsplash.com/photo-1488646953014-85cb44e25828?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    // Education
                    if (article.category === 'Education') {
                        return `https://images.unsplash.com/photo-1523240795612-9a054b0db644?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    // Entertainment
                    if (article.category === 'Entertainment') {
                        return `https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    // Sports
                    if (article.category === 'Sports') {
                        return `https://images.unsplash.com/photo-1461896836934-ffe607ba8211?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                }

                // Fallback to keyword-based selection if no AI category or for dynamic categories
                if (domain.includes('github') || domain.includes('stackoverflow') || domain.includes('dev.to') ||
                    title.includes('code') || title.includes('programming') || title.includes('javascript') || title.includes('react')) {
                    return `https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }

                if (domain.includes('business') || domain.includes('finance') || domain.includes('linkedin') ||
                    title.includes('business') || title.includes('finance') || title.includes('startup') || title.includes('entrepreneur')) {
                    return `https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }

                if (domain.includes('dribbble') || domain.includes('behance') ||
                    title.includes('design') || title.includes('ui') || title.includes('ux') || title.includes('creative')) {
                    return `https://images.unsplash.com/photo-1561070791-2526d30994b5?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }

                if (domain.includes('news') || domain.includes('bbc') || domain.includes('cnn') ||
                    title.includes('news') || title.includes('politics') || title.includes('media')) {
                    return `https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }

                // Default beautiful images based on CONSISTENT hash (not display order)
                const defaultImages = [
                    'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Mountain landscape
                    'https://images.unsplash.com/photo-1511593358241-7eea1f3c84e5?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Abstract colorful
                    'https://images.unsplash.com/photo-1519681393784-d120267933ba?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Space/galaxy
                    'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Ocean waves
                    'https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // City skyline
                    'https://images.unsplash.com/photo-1470115636492-6d2b56f9146d?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Forest/trees
                    'https://images.unsplash.com/photo-1503023345310-bd7c1de61c7d?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Sunset/sunrise
                    'https://images.unsplash.com/photo-1558618047-3c8c76ca7d13?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Architecture
                    'https://images.unsplash.com/photo-1506744038136-46273834b3fb?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Lake reflection
                    'https://images.unsplash.com/photo-1518837695005-2083093ee35b?w=400&h=250&fit=crop&crop=center&q=80&auto=format'  // Geometric pattern
                ];

                // Use consistent index based on article content, not display position
                return defaultImages[consistentIndex % defaultImages.length];
            }

            // Convert relative URLs to absolute
            makeAbsoluteUrl(imageUrl, baseUrl) {
                if (!imageUrl) return null;

                try {
                    // If already absolute, return as-is
                    if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                        return imageUrl;
                    }

                    // Handle protocol-relative URLs
                    if (imageUrl.startsWith('//')) {
                        return 'https:' + imageUrl;
                    }

                    // If relative, make it absolute
                    const base = new URL(baseUrl);
                    return new URL(imageUrl, base.origin).href;
                } catch (error) {
                    console.log(`Failed to make absolute URL: ${imageUrl}, base: ${baseUrl}`);
                    return null;
                }
            }

            // Smart icon selection based on domain
            getArticleIcon(url) {
                const domain = this.getDomain(url).toLowerCase();

                const siteIcons = {
                    'youtube.com': 'üì∫',
                    'github.com': 'üêô',
                    'stackoverflow.com': 'üíª',
                    'medium.com': 'üìù',
                    'dev.to': 'üë®‚Äçüíª',
                    'twitter.com': 'üê¶',
                    'x.com': 'üê¶',
                    'linkedin.com': 'üíº',
                    'reddit.com': 'üî¥',
                    'hackernews.ycombinator.com': 'üü†',
                    'techcrunch.com': 'üì∞',
                    'theverge.com': 'üì±',
                    'arstechnica.com': 'üî¨',
                    'wired.com': '‚ö°',
                    'bbc.com': 'üì∫',
                    'cnn.com': 'üì∞',
                    'nytimes.com': 'üì∞',
                    'guardian.co.uk': 'üì∞',
                    'washingtonpost.com': 'üì∞',
                    'wikipedia.org': 'üìñ',
                    'arxiv.org': 'üéì',
                };

                for (const [siteDomain, icon] of Object.entries(siteIcons)) {
                    if (domain.includes(siteDomain)) {
                        return icon;
                    }
                }

                if (domain.includes('blog') || domain.includes('medium')) return 'üìù';
                if (domain.includes('news')) return 'üì∞';
                if (domain.includes('tech')) return 'üíª';
                if (domain.includes('code') || domain.includes('dev')) return 'üë®‚Äçüíª';
                if (domain.includes('video') || domain.includes('tube')) return 'üì∫';
                if (domain.includes('music') || domain.includes('spotify')) return 'üéµ';
                if (domain.includes('photo') || domain.includes('image')) return 'üì∏';
                if (domain.includes('shop') || domain.includes('store')) return 'üõí';
                if (domain.includes('book') || domain.includes('read')) return 'üìö';
                if (domain.includes('learn') || domain.includes('edu')) return 'üéì';

                return 'üìÑ';
            }

            getDomain(url) {
                try {
                    return new URL(url).hostname.replace('www.', '');
                } catch (e) {
                    return url;
                }
            }

            formatDate(dateString) {
                try {
                    const date = new Date(dateString);

                    if (isNaN(date.getTime())) {
                        console.error('Invalid date:', dateString);
                        return 'invalid date';
                    }

                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const targetDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                    const diffMs = today.getTime() - targetDate.getTime();
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

                    if (diffDays < 0) {
                        return date.toLocaleDateString();
                    }

                    if (diffDays === 0) {
                        return 'today';
                    } else if (diffDays === 1) {
                        return 'yesterday';
                    } else if (diffDays <= 7) {
                        return `${diffDays} days ago`;
                    } else if (diffDays <= 30) {
                        const weeks = Math.floor(diffDays / 7);
                        return weeks === 1 ? '1 week ago' : `${weeks} weeks ago`;
                    } else if (diffDays <= 365) {
                        const months = Math.floor(diffDays / 30);
                        return months === 1 ? '1 month ago' : `${months} months ago`;
                    } else {
                        const years = Math.floor(diffDays / 365);
                        return years === 1 ? '1 year ago' : `${years} years ago`;
                    }
                } catch (error) {
                    console.error('Date formatting error:', error, 'Input:', dateString);
                    return 'date error';
                }
            }

            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            sanitizeFilename(filename) {
                if (!filename) return 'article';
                return filename.replace(/[^a-z0-9\s]/gi, '_').toLowerCase().substring(0, 50);
            }

            showDebugInfo() {
                const cacheStats = this.getCacheStats();
                const storedImages = this.articles.filter(a => a.cachedImage).length;
                const totalStoredSizeKB = this.articles.reduce((total, article) => {
                    return total + (article.cachedImage ? article.cachedImage.size || 0 : 0);
                }, 0);

                const hasRefreshToken = !!this.getRefreshToken();
                const tokenTimestamp = localStorage.getItem('mypocket_token_timestamp');
                const tokenAge = tokenTimestamp ? Math.round((Date.now() - parseInt(tokenTimestamp)) / 1000 / 60) : 'Unknown';

                const searchContainer = document.getElementById('searchContainer');
                const isSearchVisible = searchContainer.style.display !== 'none';

                const categoryContainer = document.getElementById('categoryContainer');
                const isCategoryVisible = categoryContainer.style.display !== 'none';

                const categorizedArticles = this.articles.filter(a => a.category).length;
                const categoryBreakdown = Array.from(this.categories.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .map(([cat, count]) => `${cat}: ${count}`)
                    .join(', ');

                const dynamicCategoryBreakdown = Array.from(this.dynamicCategories.entries())
                    .slice(0, 3)
                    .map(([cat, data]) => `${cat}: ${data.articles.length}`)
                    .join(', ');

                const aiAnalyzedArticles = this.articles.filter(a => a.extractedKeywords && a.extractedKeywords.length > 0).length;

                const info = `
MyPocket AI Reader Debug Info (Enhanced PKCE + AI):
==================================================

Current URL: ${window.location.href}
Redirect URI: ${this.redirectUri}
Client ID: ${this.clientId}
Protocol: ${window.location.protocol}
Host: ${window.location.host}

üîê SECURITY (PKCE):
- Authentication Method: Authorization Code + PKCE
- Security Level: HIGH (recommended for SPAs)
- Anti-CSRF Protection: Enabled (state parameter)
- Code Challenge Method: SHA256
- Token Storage: localStorage (access), sessionStorage (PKCE params)

üé´ TOKEN STATUS:
- Has Access Token: ${!!this.accessToken}
- Has Refresh Token: ${hasRefreshToken}
- Token Age: ${tokenAge} minutes
- Auto-Refresh: Enabled

üìö ARTICLES & IMAGES:
- Articles Loaded: ${this.articles.length}
- Currently Displayed: ${this.currentDisplayedArticles.length}
- Store Images in Backup: ${this.storeImagesInBackup}
- Max Image Size: ${this.maxImageSizeKB}KB
- Articles with Stored Images: ${storedImages}
- Total Stored Image Size: ${Math.round(totalStoredSizeKB)}KB
- Failed Images: ${this.failedImages.size}

üîç SEARCH STATUS:
- Search Visible: ${isSearchVisible}
- Keyboard Shortcuts: Ctrl/Cmd+K, / (open), Esc (close)
- Click Outside: Enabled

ü§ñ AI CATEGORIZATION:
- AI Analysis Enabled: ${this.enableDynamicCategories}
- Min Category Confidence: ${this.minCategoryConfidence}
- Max Categories: ${this.maxCategories}
- AI Analyzed Articles: ${aiAnalyzedArticles}/${this.articles.length}
- Categorized Articles: ${categorizedArticles}/${this.articles.length}
- Static Categories Found: ${this.categories.size}
- Dynamic Categories (AI-discovered): ${this.dynamicCategories.size}
- Top Static Categories: ${categoryBreakdown || 'None'}
- Top Dynamic Categories: ${dynamicCategoryBreakdown || 'None'}
- Category Filter Visible: ${isCategoryVisible}
- Active Category Filter: ${this.activeCategory || 'None'}

üíæ LOCAL CACHE:
- Total Cached Images: ${cacheStats.total}
- Memory Usage: ${Math.round(cacheStats.memoryUsage / 1024)} KB
- Cache Expiry: ${this.cacheExpiryDays} days

üõ°Ô∏è SECURITY BENEFITS:
‚úÖ No tokens exposed in URL
‚úÖ Protection against code interception
‚úÖ Anti-CSRF state verification
‚úÖ Automatic token refresh
‚úÖ Secure parameter storage

ü§ñ AI CATEGORIZATION FEATURES:
‚úÖ Intelligent content analysis with TF-IDF-like scoring
‚úÖ Dynamic category discovery from content patterns
‚úÖ Multi-factor analysis (title, content, domain, keywords)
‚úÖ Confidence scoring (high/medium/low confidence indicators)
‚úÖ Stop word filtering and keyword extraction
‚úÖ Cross-device AI analysis consistency
‚úÖ Support for 12+ predefined categories + unlimited dynamic categories

Azure AD Setup for PKCE:
1. App Registration ‚Üí Authentication
2. Add Web platform: ${this.redirectUri}
3. Enable "Access tokens" and "ID tokens"
4. Set redirect URI exactly: ${this.redirectUri}
5. PKCE is automatically supported for public clients

Cross-Device Image Features:
- Images stored in OneDrive backup for instant loading
- Base64 encoding with ${this.maxImageSizeKB}KB size limit
- Automatic compression to 80% quality
- Works across all devices and browsers

AI Categorization Algorithm:
- Extracts meaningful keywords using frequency analysis
- Scores categories using domain matching, keyword analysis, semantic understanding
- Discovers new categories dynamically from content patterns
- Maintains consistency across devices through content-based analysis
- Provides confidence indicators for category assignments
                `;

                alert(info);
                console.log('ü§ñ AI Debug Info:', {
                    currentUrl: window.location.href,
                    redirectUri: this.redirectUri,
                    authMethod: 'Authorization Code + PKCE',
                    securityLevel: 'HIGH',
                    hasToken: !!this.accessToken,
                    hasRefreshToken: hasRefreshToken,
                    tokenAge: `${tokenAge} minutes`,
                    articlesCount: this.articles.length,
                    displayedCount: this.currentDisplayedArticles.length,
                    searchVisible: isSearchVisible,
                    categoryVisible: isCategoryVisible,
                    categorizedArticles: categorizedArticles,
                    staticCategories: this.categories.size,
                    dynamicCategories: this.dynamicCategories.size,
                    aiAnalyzedArticles: aiAnalyzedArticles,
                    activeCategory: this.activeCategory,
                    cacheStats: cacheStats,
                    storedImages: storedImages,
                    crossDeviceEnabled: this.storeImagesInBackup,
                    aiSettings: {
                        enableDynamicCategories: this.enableDynamicCategories,
                        minCategoryConfidence: this.minCategoryConfidence,
                        maxCategories: this.maxCategories
                    }
                });
            }

            toggleTestMode() {
                document.body.classList.toggle('test-mode');
                const isTestMode = document.body.classList.contains('test-mode');

                const testBtn = document.getElementById('testBtn');
                if (testBtn) {
                    const iconSpan = testBtn.querySelector('.icon');
                    const labelSpan = testBtn.querySelector('.label');
                    
                    if (isTestMode) {
                        iconSpan.textContent = 'üëÅÔ∏è';
                        labelSpan.textContent = 'Hide Buttons';
                    } else {
                        iconSpan.textContent = 'üëÅÔ∏è';
                        labelSpan.textContent = 'Show Buttons';
                    }
                }

                this.updateStatus(
                    isTestMode
                        ? 'üîç Test mode ON - Action buttons always visible'
                        : 'üëÅÔ∏è Test mode OFF - Action buttons show on hover',
                    'success'
                );
            }

            // Dark mode functionality
            toggleDarkMode() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);

                this.updateDarkModeButton(newTheme);
                this.updateStatus(
                    newTheme === 'dark' ? 'üåô Dark mode enabled' : '‚òÄÔ∏è Light mode enabled',
                    'success'
                );
            }

            loadThemePreference() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                document.documentElement.setAttribute('data-theme', savedTheme);
                this.updateDarkModeButton(savedTheme);
            }

            updateDarkModeButton(theme) {
                const darkModeBtn = document.getElementById('darkModeBtn');
                if (darkModeBtn) {
                    const iconSpan = darkModeBtn.querySelector('.icon');
                    const labelSpan = darkModeBtn.querySelector('.label');
                    
                    if (theme === 'dark') {
                        iconSpan.textContent = '‚òÄÔ∏è';
                        labelSpan.textContent = 'Light Mode';
                    } else {
                        iconSpan.textContent = 'üåô';
                        labelSpan.textContent = 'Dark Mode';
                    }
                }
            }
        }

        let webReader;
        document.addEventListener('DOMContentLoaded', () => {
            webReader = new MyPocketWebReader();
            window.webReader = webReader;
        });
    </script>
</body>

</html>
