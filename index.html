<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyPocket - Web Reader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --pocket-red: #ef4056;
            --pocket-red-dark: #d73754;
            --pocket-red-light: #ff6b7a;
            --pocket-green: #00d084;
            --pocket-blue: #0587ff;
            --pocket-orange: #ff8a00;
            --background: #f7f8fa;
            --surface: #ffffff;
            --surface-elevated: #ffffff;
            --text-primary: #1a1b1c;
            --text-secondary: #6b7280;
            --text-tertiary: #9ca3af;
            --border: #e5e7eb;
            --border-light: #f3f4f6;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.15);
            --radius: 12px;
            --radius-lg: 16px;
        }

        /* Dark mode */
        body.dark-mode {
            --background: #0f0f0f;
            --surface: #1a1a1a;
            --surface-elevated: #202020;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --text-tertiary: #808080;
            --border: #333333;
            --border-light: #2a2a2a;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        /* Dark mode */
        body.dark-mode {
            --background: #0f0f0f;
            --surface: #1a1a1a;
            --surface-elevated: #202020;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --text-tertiary: #808080;
            --border: #333333;
            --border-light: #2a2a2a;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.3);
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        /* Dark mode action buttons */
        body.dark-mode .action-btn {
            background: rgba(0, 0, 0, 0.8);
            color: white;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--background);
            font-size: 16px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 24px;
        }

        /* Header */
        .header {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            padding: 16px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.95);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            color: var(--pocket-red);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--pocket-red), var(--pocket-red-light));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: white;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            white-space: nowrap;
        }

        .btn-primary {
            background: var(--pocket-red);
            color: white;
        }

        .btn-primary:hover {
            background: var(--pocket-red-dark);
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border-light);
            transform: translateY(-1px);
        }

        .btn-ghost {
            background: transparent;
            color: var(--text-secondary);
        }

        .btn-ghost:hover {
            background: var(--border-light);
        }

        /* Search */
        .search-container {
            padding: 32px 0;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .search-box {
            position: relative;
            max-width: 600px;
            margin: 0 auto;
        }

        .search-input {
            width: 100%;
            padding: 16px 48px 16px 20px;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            font-size: 16px;
            background: var(--background);
            transition: all 0.2s ease;
            color: var(--text-primary);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--pocket-red);
            box-shadow: 0 0 0 3px rgba(239, 64, 86, 0.1);
            background: var(--surface);
        }

        .search-input::placeholder {
            color: var(--text-tertiary);
        }

        .search-icon {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-tertiary);
            font-size: 20px;
            pointer-events: none;
        }

        /* Status */
        .status {
            padding: 16px 0;
            text-align: center;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            font-size: 14px;
            font-weight: 500;
        }

        .status.loading {
            color: var(--pocket-blue);
        }

        .status.error {
            color: var(--pocket-red);
        }

        .status.success {
            color: var(--pocket-green);
        }

        /* Articles Grid */
        .articles-section {
            padding: 24px 0;
            min-height: 60vh;
        }

        .articles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .article-card {
            background: var(--surface);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            transition: all 0.2s ease;
            border: 1px solid var(--border);
            position: relative;
            display: flex;
            flex-direction: column;
            cursor: pointer;
            max-width: 300px;
        }

        .article-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translateY(-1px);
        }

        .article-card:hover .article-actions {
            opacity: 1;
            visibility: visible;
        }

        .article-image-container {
            width: 100%;
            height: 120px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .article-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.2s ease;
        }

        .article-card:hover .article-image {
            transform: scale(1.02);
        }

        .article-image-placeholder {
            font-size: 24px;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
        }

        .article-content {
            padding: 12px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .article-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 6px;
            line-height: 1.3;
            color: var(--text-primary);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-excerpt {
            color: var(--text-secondary);
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 8px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            flex: 1;
        }

        .article-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-tertiary);
            font-size: 10px;
            font-weight: 500;
            margin-top: auto;
        }

        .article-domain {
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .article-date {
            color: var(--text-tertiary);
        }

        .article-actions {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 4px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            border-radius: 6px;
            padding: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow-sm);
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: var(--shadow);
        }

        .read-btn:hover {
            background: rgba(5, 135, 255, 0.9);
            color: white;
        }

        .export-btn:hover {
            background: rgba(0, 208, 132, 0.9);
            color: white;
        }

        .delete-btn:hover {
            background: rgba(239, 64, 86, 0.9);
            color: white;
        }

        /* Dark mode action buttons */
        body.dark-mode .action-btn {
            background: rgba(0, 0, 0, 0.8);
            color: white;
        }

        /* Reader View */
        .reader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            display: none;
            overflow-y: auto;
            backdrop-filter: blur(8px);
        }

        .reader-overlay.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .reader-container {
            max-width: 800px;
            margin: 20px auto;
            background: var(--surface);
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow-lg);
            position: relative;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { 
                transform: translateY(30px);
                opacity: 0;
            }
            to { 
                transform: translateY(0);
                opacity: 1;
            }
        }

        .reader-header {
            padding: 32px 32px 24px;
            border-bottom: 1px solid var(--border);
            background: var(--surface-elevated);
        }

        .reader-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 16px;
            line-height: 1.3;
            color: var(--text-primary);
        }

        .reader-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 20px;
        }

        .reader-meta-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .reader-actions {
            display: flex;
            gap: 12px;
        }

        .reader-content {
            padding: 32px;
            font-size: 18px;
            line-height: 1.7;
            color: var(--text-primary);
        }

        .reader-content h1,
        .reader-content h2,
        .reader-content h3,
        .reader-content h4,
        .reader-content h5,
        .reader-content h6 {
            margin: 32px 0 16px;
            color: var(--text-primary);
            font-weight: 600;
        }

        .reader-content h1 { font-size: 2em; }
        .reader-content h2 { font-size: 1.6em; }
        .reader-content h3 { font-size: 1.4em; }

        .reader-content p {
            margin-bottom: 24px;
        }

        .reader-content img {
            max-width: 100%;
            height: auto;
            border-radius: var(--radius);
            margin: 24px 0;
            box-shadow: var(--shadow-sm);
        }

        .reader-content blockquote {
            border-left: 4px solid var(--pocket-red);
            margin: 24px 0;
            padding: 16px 24px;
            background: var(--background);
            font-style: italic;
            border-radius: 0 var(--radius) var(--radius) 0;
        }

        .reader-content a {
            color: var(--pocket-red);
            text-decoration: none;
        }

        .reader-content a:hover {
            text-decoration: underline;
        }

        .close-reader {
            position: absolute;
            top: 16px;
            right: 16px;
            background: var(--pocket-red);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .close-reader:hover {
            background: var(--pocket-red-dark);
            transform: scale(1.1);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 24px;
            opacity: 0.6;
        }

        .empty-state h3 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .empty-state p {
            font-size: 16px;
            max-width: 400px;
            margin: 0 auto;
        }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 50%;
            border-top-color: var(--pocket-red);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Connection Status */
        .connection-status {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 16px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
        }

        .connection-status.connected {
            border-color: var(--pocket-green);
            background: rgba(0, 208, 132, 0.05);
            color: var(--pocket-green);
        }

        .connection-status.disconnected {
            border-color: var(--pocket-red);
            background: rgba(239, 64, 86, 0.05);
            color: var(--pocket-red);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 0 16px;
            }

            .header-content {
                flex-direction: column;
                gap: 12px;
            }

            .header-actions {
                width: 100%;
                justify-content: center;
            }

            .articles-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .article-actions {
                position: static;
                opacity: 1;
                visibility: visible;
                justify-content: center;
                margin-top: 12px;
                padding: 12px;
                background: var(--background);
                border-radius: var(--radius);
                border-top: 1px solid var(--border);
            }

            .reader-container {
                margin: 10px;
                border-radius: var(--radius);
            }

            .reader-header,
            .reader-content {
                padding: 20px;
            }

            .reader-title {
                font-size: 24px;
            }

            .reader-content {
                font-size: 16px;
            }

            .search-input {
                font-size: 16px; /* Prevent zoom on iOS */
            }
        }

        /* Test mode styles - force visible on all devices */
        body.test-mode .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
            background: rgba(239, 64, 86, 0.05) !important;
            border: 1px dashed var(--pocket-red) !important;
            border-radius: 6px !important;
            padding: 4px !important;
            position: absolute !important;
            top: 8px !important;
            right: 8px !important;
            margin-top: 0 !important;
        }

        /* Focus styles for accessibility */
        .btn:focus,
        .action-btn:focus,
        .search-input:focus {
            outline: 2px solid var(--pocket-red);
            outline-offset: 2px;
        }

        /* Improved typography */
        .article-title {
            font-feature-settings: 'liga' 1, 'kern' 1;
        }

        .reader-title {
            font-feature-settings: 'liga' 1, 'kern' 1;
        }

        .reader-content {
            font-feature-settings: 'liga' 1, 'kern' 1;
        }
    </style>
</head>

<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <div class="logo-icon">üìö</div>
                    MyPocket
                </div>
                <div class="header-actions">
                    <button id="connectBtn" class="btn btn-primary">
                        <span id="connectIcon">‚òÅÔ∏è</span>
                        <span id="connectText">Connect OneDrive</span>
                    </button>
                    <button id="refreshBtn" class="btn btn-secondary" style="display: none;">
                        <span>üîÑ</span> Refresh
                    </button>
                    <button id="darkModeBtn" class="btn btn-ghost" onclick="webReader.toggleDarkMode()">
                        <span>üåô</span> Dark
                    </button>
                    <button id="darkModeBtn" class="btn btn-ghost" onclick="webReader.toggleDarkMode()">
                        <span>üåô</span> Dark
                    </button>
                    <button id="debugBtn" class="btn btn-ghost" onclick="webReader.showDebugInfo()">
                        üîß
                    </button>
                    <button id="testBtn" class="btn btn-ghost" onclick="webReader.toggleTestMode()">
                        üìù Test
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Search -->
    <section class="search-container">
        <div class="container">
            <div class="search-box">
                <input type="text" id="searchInput" class="search-input" placeholder="Search your saved articles...">
                <span class="search-icon">üîç</span>
            </div>
        </div>
    </section>

    <!-- Status -->
    <div class="status" id="status">
        Connect to OneDrive to view your saved articles
    </div>

    <!-- Articles -->
    <section class="articles-section">
        <div class="container">
            <div id="articlesContainer">
                <div class="empty-state">
                    <div class="empty-state-icon">üìñ</div>
                    <h3>Welcome to MyPocket</h3>
                    <p>Connect to OneDrive to access your saved articles from anywhere. Start building your personal reading library today!</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Reader Overlay -->
    <div class="reader-overlay" id="readerOverlay">
        <div class="reader-container">
            <button class="close-reader" id="closeReader">‚úï</button>
            <div class="reader-header">
                <h1 class="reader-title" id="readerTitle">Article Title</h1>
                <div class="reader-meta">
                    <div class="reader-meta-item">
                        <span>üìÖ</span>
                        <span id="readerDate">Date</span>
                    </div>
                    <div class="reader-meta-item">
                        <span>üåê</span>
                        <span id="readerDomain">Domain</span>
                    </div>
                    <div class="reader-meta-item">
                        <span>‚è±Ô∏è</span>
                        <span id="readerTime">5 min read</span>
                    </div>
                </div>
                <div class="reader-actions">
                    <button class="btn btn-primary" id="openOriginal">
                        üîó Open Original
                    </button>
                    <button class="btn btn-secondary" id="exportFromReader" onclick="webReader.exportCurrentArticle()">
                        üì§ Export
                    </button>
                </div>
            </div>
            <div class="reader-content" id="readerContent">
                Article content will appear here...
            </div>
        </div>
    </div>

    <script>
        class MyPocketWebReader {
            constructor() {
                this.clientId = '436e8796-8c40-47c3-9ad5-b8882f3ef7f7';
                this.redirectUri = this.getRedirectUri();
                console.log('üîµ Redirect URI:', this.redirectUri);

                this.accessToken = null;
                this.articles = [];
                this.currentArticle = null;
                this.currentArticleIndex = null;

                this.init();
            }

            getRedirectUri() {
                const currentUrl = window.location.href;
                const baseUrl = currentUrl.split('#')[0];
                
                if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {
                    return baseUrl;
                } else {
                    return window.location.origin + window.location.pathname;
                }
            }

            init() {
                this.setupEventListeners();
                this.checkAuthFromURL();
                this.loadStoredToken();
                this.loadDarkModePreference();
            }

            loadDarkModePreference() {
                const isDarkMode = localStorage.getItem('mypocket_dark_mode') === 'true';
                if (isDarkMode) {
                    document.body.classList.add('dark-mode');
                    const darkModeBtn = document.getElementById('darkModeBtn');
                    if (darkModeBtn) {
                        darkModeBtn.innerHTML = '<span>‚òÄÔ∏è</span> Light';
                    }
                }
            }

            toggleDarkMode() {
                document.body.classList.toggle('dark-mode');
                const isDarkMode = document.body.classList.contains('dark-mode');
                
                // Save preference
                localStorage.setItem('mypocket_dark_mode', isDarkMode);
                
                // Update button
                const darkModeBtn = document.getElementById('darkModeBtn');
                if (darkModeBtn) {
                    darkModeBtn.innerHTML = isDarkMode 
                        ? '<span>‚òÄÔ∏è</span> Light' 
                        : '<span>üåô</span> Dark';
                }

                this.updateStatus(
                    isDarkMode ? 'üåô Dark mode enabled' : '‚òÄÔ∏è Light mode enabled',
                    'success'
                );
            }

            setupEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', () => this.authenticate());
                document.getElementById('refreshBtn').addEventListener('click', () => this.loadArticles());
                document.getElementById('searchInput').addEventListener('input', (e) => this.searchArticles(e.target.value));
                document.getElementById('closeReader').addEventListener('click', () => this.closeReader());
                document.getElementById('openOriginal').addEventListener('click', () => this.openOriginal());
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && document.getElementById('readerOverlay').classList.contains('active')) {
                        this.closeReader();
                    }
                });
            }

            checkAuthFromURL() {
                const hash = window.location.hash.substring(1);
                if (hash && hash.includes('access_token=')) {
                    const params = new URLSearchParams(hash);
                    const accessToken = params.get('access_token');
                    const error = params.get('error');

                    if (error) {
                        this.updateStatus(`Authentication error: ${error}`, 'error');
                        return;
                    }

                    if (accessToken) {
                        this.accessToken = accessToken;
                        this.saveToken(accessToken);
                        this.updateConnectionStatus(true);
                        this.loadArticles();
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }
                }
            }

            loadStoredToken() {
                this.accessToken = localStorage.getItem('mypocket_access_token');
                if (this.accessToken) {
                    this.updateConnectionStatus(true);
                    this.loadArticles();
                }
            }

            saveToken(token) {
                localStorage.setItem('mypocket_access_token', token);
            }

            clearToken() {
                localStorage.removeItem('mypocket_access_token');
                this.accessToken = null;
            }

            authenticate() {
                console.log('üîµ Authenticate button clicked');
                
                // More detailed validation
                if (!this.redirectUri || (!this.redirectUri.startsWith('http://') && !this.redirectUri.startsWith('https://'))) {
                    const errorMsg = `‚ùå Invalid redirect URI: ${this.redirectUri}. Must start with http:// or https://`;
                    this.updateStatus(errorMsg, 'error');
                    console.error('üî¥ Invalid redirect URI:', this.redirectUri);
                    alert(`Redirect URI Error:\n\n${errorMsg}\n\nCurrent URI: ${this.redirectUri}\n\nPlease:\n1. Open this page via HTTPS\n2. Register this exact URI in Azure AD`);
                    return;
                }

                const authUrl = `https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize?` +
                    `client_id=${this.clientId}&` +
                    `response_type=token&` +
                    `redirect_uri=${encodeURIComponent(this.redirectUri)}&` +
                    `scope=${encodeURIComponent('Files.ReadWrite User.Read')}&` +
                    `response_mode=fragment&` +
                    `nonce=${Date.now()}`;

                console.log('üîµ Auth URL constructed:', authUrl);
                console.log('üîµ Redirect URI being used:', this.redirectUri);
                console.log('üîµ Encoded Redirect URI:', encodeURIComponent(this.redirectUri));

                this.updateStatus('üîÑ Redirecting to Microsoft login...', 'loading');

                // Try immediate redirect first
                try {
                    console.log('üîµ Attempting redirect...');
                    window.location.href = authUrl;
                } catch (error) {
                    console.error('üî¥ Redirect failed:', error);
                    this.updateStatus(`‚ùå Redirect failed: ${error.message}`, 'error');
                    
                    // Fallback: try opening in new window
                    try {
                        console.log('üîµ Trying popup window...');
                        const popup = window.open(authUrl, 'auth', 'width=500,height=600');
                        if (!popup) {
                            this.updateStatus('‚ùå Popup blocked. Please allow popups and try again.', 'error');
                        }
                    } catch (popupError) {
                        console.error('üî¥ Popup failed:', popupError);
                        this.updateStatus(`‚ùå Both redirect and popup failed. Check console for details.`, 'error');
                    }
                }
            }

            updateConnectionStatus(connected) {
                const connectBtn = document.getElementById('connectBtn');
                const connectIcon = document.getElementById('connectIcon');
                const connectText = document.getElementById('connectText');
                const refreshBtn = document.getElementById('refreshBtn');

                if (connected) {
                    connectIcon.textContent = '‚úÖ';
                    connectText.textContent = 'Connected';
                    connectBtn.classList.remove('btn-primary');
                    connectBtn.classList.add('btn-secondary');
                    refreshBtn.style.display = 'inline-flex';
                } else {
                    connectIcon.textContent = '‚òÅÔ∏è';
                    connectText.textContent = 'Connect OneDrive';
                    connectBtn.classList.remove('btn-secondary');
                    connectBtn.classList.add('btn-primary');
                    refreshBtn.style.display = 'none';
                }
            }

            updateStatus(message, type = '') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }

            async loadArticles() {
                if (!this.accessToken) {
                    this.updateStatus('Not connected to OneDrive', 'error');
                    return;
                }

                try {
                    this.updateStatus('Loading articles... ‚è≥', 'loading');

                    const listResponse = await fetch('https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket:/children', {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!listResponse.ok) {
                        if (listResponse.status === 401) {
                            this.clearToken();
                            this.updateConnectionStatus(false);
                            this.updateStatus('Session expired. Please reconnect.', 'error');
                            return;
                        }
                        throw new Error(`Failed to list files: ${listResponse.status}`);
                    }

                    const fileList = await listResponse.json();
                    const backupFiles = fileList.value.filter(file =>
                        file.name.startsWith('mypocket-backup-') && file.name.endsWith('.json')
                    );

                    if (backupFiles.length === 0) {
                        this.updateStatus('No backup files found. Save some articles with the browser extension first.', 'error');
                        this.displayEmptyState();
                        return;
                    }

                    const latestFile = backupFiles.sort((a, b) =>
                        new Date(b.lastModifiedDateTime) - new Date(a.lastModifiedDateTime)
                    )[0];

                    const downloadResponse = await fetch(`https://graph.microsoft.com/v1.0/me/drive/items/${latestFile.id}/content`, {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`
                        }
                    });

                    if (!downloadResponse.ok) {
                        throw new Error(`Failed to download backup: ${downloadResponse.status}`);
                    }

                    const backupContent = await downloadResponse.text();
                    const backup = JSON.parse(backupContent);

                    this.articles = backup.articles || [];
                    this.displayArticles(this.articles);

                    this.updateStatus(`‚ú® Loaded ${this.articles.length} articles from ${latestFile.name}`, 'success');

                } catch (error) {
                    console.error('Error loading articles:', error);
                    this.updateStatus(`‚ùå Error loading articles: ${error.message}`, 'error');
                }
            }

            displayArticles(articles) {
                const container = document.getElementById('articlesContainer');

                if (articles.length === 0) {
                    this.displayEmptyState();
                    return;
                }

                const articlesHTML = articles.map((article, index) => `
                    <div class="article-card" onclick="webReader.openReader(${index})">
                        <div class="article-image-container">
                            ${this.getArticleImage(article)}
                        </div>
                        <div class="article-content">
                            <h2 class="article-title">${this.escapeHtml(article.title)}</h2>
                            <p class="article-excerpt">${this.escapeHtml(article.excerpt)}</p>
                            <div class="article-meta">
                                <span class="article-domain">${this.getDomain(article.url)}</span>
                                <span class="article-date">${this.formatDate(article.dateAdded)}</span>
                            </div>
                        </div>
                        <div class="article-actions">
                            <button class="action-btn read-btn" onclick="event.stopPropagation(); webReader.openReader(${index})" title="Read article">
                                üìñ
                            </button>
                            <button class="action-btn export-btn" onclick="event.stopPropagation(); webReader.exportArticle(${index})" title="Export article">
                                üì§
                            </button>
                            <button class="action-btn delete-btn" onclick="event.stopPropagation(); webReader.deleteArticle(${index})" title="Delete article">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                `).join('');

                container.innerHTML = `<div class="articles-grid">${articlesHTML}</div>`;
            }

            getArticleImage(article) {
                // Try multiple image sources in order of preference
                let imageUrl = null;
                
                // Check for images array (most common)
                if (article.images && Array.isArray(article.images) && article.images.length > 0) {
                    const img = article.images[0];
                    if (typeof img === 'string') {
                        imageUrl = img;
                    } else if (img && typeof img === 'object') {
                        imageUrl = img.src || img.url || img.href || img.source;
                    }
                }
                
                // Check other common image properties
                if (!imageUrl && article.featuredImage) {
                    imageUrl = article.featuredImage;
                }
                
                if (!imageUrl && article.image) {
                    imageUrl = article.image;
                }
                
                if (!imageUrl && article.thumbnail) {
                    imageUrl = article.thumbnail;
                }

                if (!imageUrl && article.hero_image) {
                    imageUrl = article.hero_image;
                }

                if (!imageUrl && article.lead_image_url) {
                    imageUrl = article.lead_image_url;
                }

                // Validate and clean the URL
                if (imageUrl && typeof imageUrl === 'string' && imageUrl.trim()) {
                    imageUrl = imageUrl.trim();
                    
                    // Handle relative URLs
                    if (imageUrl.startsWith('//')) {
                        imageUrl = 'https:' + imageUrl;
                    } else if (imageUrl.startsWith('/') && article.url) {
                        try {
                            const baseUrl = new URL(article.url);
                            imageUrl = baseUrl.origin + imageUrl;
                        } catch (e) {
                            // If URL parsing fails, ignore
                        }
                    }
                    
                    // Check if it's a valid URL
                    if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                        return `<img src="${this.escapeHtml(imageUrl)}" alt="Article image" class="article-image" 
                                onerror="this.parentElement.innerHTML='<div class=\\"article-image-placeholder\\">üìÑ</div>'">`;
                    }
                }

                // Return placeholder if no valid image found
                return '<div class="article-image-placeholder">üìÑ</div>';
            }

            displayEmptyState() {
                const container = document.getElementById('articlesContainer');
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìñ</div>
                        <h3>No articles found</h3>
                        <p>Use the MyPocket browser extension to save articles, then refresh this page to see them here.</p>
                    </div>`;
            }

            searchArticles(query) {
                if (!query) {
                    this.displayArticles(this.articles);
                    return;
                }

                const filtered = this.articles.filter(article =>
                    article.title.toLowerCase().includes(query.toLowerCase()) ||
                    article.textContent.toLowerCase().includes(query.toLowerCase()) ||
                    (article.author && article.author.toLowerCase().includes(query.toLowerCase())) ||
                    this.getDomain(article.url).toLowerCase().includes(query.toLowerCase())
                );

                this.displayArticles(filtered);
                this.updateStatus(`Found ${filtered.length} articles matching "${query}"`, filtered.length > 0 ? 'success' : 'error');
            }

            openReader(index) {
                this.currentArticle = this.articles[index];
                this.currentArticleIndex = index;
                const overlay = document.getElementById('readerOverlay');

                document.getElementById('readerTitle').textContent = this.currentArticle.title;
                document.getElementById('readerDate').textContent = this.formatDate(this.currentArticle.dateAdded);
                document.getElementById('readerDomain').textContent = this.getDomain(this.currentArticle.url);
                document.getElementById('readerTime').textContent = `${this.currentArticle.readTime || 1} min read`;
                
                // Try multiple content sources
                let content = this.getArticleContent(this.currentArticle);
                document.getElementById('readerContent').innerHTML = content;

                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
                overlay.scrollTop = 0;
            }

            getArticleContent(article) {
                // Try different content fields in order of preference
                let content = '';
                
                // First try the main content field
                if (article.content && article.content.trim()) {
                    content = article.content;
                } 
                // Try HTML content
                else if (article.html && article.html.trim()) {
                    content = article.html;
                }
                // Try readable content
                else if (article.readable && article.readable.trim()) {
                    content = article.readable;
                }
                // Try body content
                else if (article.body && article.body.trim()) {
                    content = article.body;
                }
                // Try article content
                else if (article.article && article.article.trim()) {
                    content = article.article;
                }
                // Try plain text content and convert to HTML
                else if (article.textContent && article.textContent.trim()) {
                    const text = article.textContent.trim();
                    // Split by double newlines for paragraphs
                    content = text
                        .split(/\n\s*\n/)
                        .map(paragraph => paragraph.trim())
                        .filter(paragraph => paragraph.length > 0)
                        .map(paragraph => `<p>${this.escapeHtml(paragraph.replace(/\n/g, ' '))}</p>`)
                        .join('');
                } 
                // Try plain text field
                else if (article.text && article.text.trim()) {
                    const text = article.text.trim();
                    content = text
                        .split(/\n\s*\n/)
                        .map(paragraph => paragraph.trim())
                        .filter(paragraph => paragraph.length > 0)
                        .map(paragraph => `<p>${this.escapeHtml(paragraph.replace(/\n/g, ' '))}</p>`)
                        .join('');
                }
                // Try description
                else if (article.description && article.description.trim() && article.description.length > 100) {
                    content = `<p>${this.escapeHtml(article.description)}</p>`;
                }
                // Last resort: use excerpt if it's substantial
                else if (article.excerpt && article.excerpt.trim() && article.excerpt.length > 50) {
                    content = `
                        <div style="text-align: center; padding: 20px; background: var(--border-light); border-radius: 8px; margin-bottom: 20px;">
                            <p><strong>üìñ Preview Only</strong></p>
                            <p style="font-size: 14px; color: var(--text-secondary);">Only excerpt available - click "Open Original" for full article</p>
                        </div>
                        <p><em>${this.escapeHtml(article.excerpt)}</em></p>
                    `;
                } else {
                    // No content available
                    content = `
                        <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                            <div style="font-size: 48px; margin-bottom: 20px;">üìÑ</div>
                            <h3>Content Not Available</h3>
                            <p style="margin: 16px 0;">This article doesn't have readable content saved.</p>
                            <p style="font-size: 14px;">Click <strong>"Open Original"</strong> below to read the full article on the source website.</p>
                            <div style="margin-top: 24px; padding: 16px; background: var(--background); border-radius: 8px; font-size: 12px;">
                                <strong>Tip:</strong> Make sure your browser extension is configured to save full article content.
                            </div>
                        </div>
                    `;
                }

                return content;
            }

            closeReader() {
                const overlay = document.getElementById('readerOverlay');
                overlay.classList.remove('active');
                document.body.style.overflow = 'auto';
                this.currentArticle = null;
                this.currentArticleIndex = null;
            }

            openOriginal() {
                if (this.currentArticle) {
                    window.open(this.currentArticle.url, '_blank');
                }
            }

            exportCurrentArticle() {
                if (this.currentArticleIndex !== null) {
                    this.exportArticle(this.currentArticleIndex);
                }
            }

            async deleteArticle(index) {
                const article = this.articles[index];
                if (!article) return;

                if (confirm(`Delete "${article.title}"?\n\nThis will permanently remove the article from your OneDrive backup.`)) {
                    try {
                        this.articles.splice(index, 1);

                        if (this.accessToken) {
                            this.updateStatus('Updating OneDrive backup...', 'loading');
                            await this.updateOneDriveBackup();
                            this.updateStatus(`‚úÖ Article deleted and backup updated. ${this.articles.length} articles remaining.`, 'success');
                        } else {
                            this.updateStatus(`‚ùå Article deleted locally but OneDrive backup not updated (not connected).`, 'error');
                        }

                        this.displayArticles(this.articles);

                    } catch (error) {
                        console.error('Error deleting article:', error);
                        this.updateStatus(`‚ùå Failed to delete article: ${error.message}`, 'error');
                    }
                }
            }

            exportArticle(index) {
                const article = this.articles[index];
                if (!article) return;

                try {
                    const html = this.createArticleHTML(article);
                    const filename = `${this.sanitizeFilename(article.title)}.html`;
                    this.downloadFile(html, filename, 'text/html');
                    this.updateStatus(`üì§ Article "${article.title}" exported successfully!`, 'success');
                } catch (error) {
                    console.error('Error exporting article:', error);
                    this.updateStatus(`‚ùå Failed to export article: ${error.message}`, 'error');
                }
            }

            async updateOneDriveBackup() {
                if (!this.accessToken) {
                    throw new Error('Not connected to OneDrive');
                }

                const backup = {
                    articles: this.articles,
                    settings: {},
                    exportDate: new Date().toISOString(),
                    version: "3.3",
                    deviceInfo: {
                        browser: "Web Reader",
                        platform: navigator.platform,
                        timestamp: Date.now(),
                        articleCount: this.articles.length
                    }
                };

                const fileName = `mypocket-backup-${new Date().toISOString().split('T')[0]}.json`;
                const fileContent = JSON.stringify(backup, null, 2);

                const uploadUrl = `https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket/${fileName}:/content`;

                const uploadResponse = await fetch(uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${this.accessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: fileContent
                });

                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    throw new Error(`Failed to update OneDrive backup: ${uploadResponse.status} - ${errorText}`);
                }

                return await uploadResponse.json();
            }

            createArticleHTML(article) {
                return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHtml(article.title)}</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 40px 20px; 
            line-height: 1.8; 
            color: #1a1b1c;
            background: #ffffff;
        }
        .header { 
            border-bottom: 3px solid #ef4056; 
            margin-bottom: 40px; 
            padding-bottom: 32px; 
        }
        .title { 
            font-size: 2.5em; 
            font-weight: 700; 
            margin-bottom: 20px; 
            color: #1a1b1c; 
            line-height: 1.2; 
        }
        .meta { 
            color: #6b7280; 
            font-size: 1em; 
            margin-bottom: 32px; 
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .meta-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .content { 
            font-size: 1.2em; 
            line-height: 1.8; 
        }
        .content img { 
            max-width: 100%; 
            height: auto; 
            margin: 32px 0; 
            border-radius: 12px; 
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        .content p { 
            margin-bottom: 1.6em; 
        }
        .content h1, .content h2, .content h3 {
            margin: 40px 0 20px;
            color: #1a1b1c;
            font-weight: 600;
        }
        .content blockquote {
            border-left: 4px solid #ef4056;
            margin: 32px 0;
            padding: 20px 24px;
            background: #f7f8fa;
            border-radius: 0 12px 12px 0;
            font-style: italic;
        }
        .content a {
            color: #ef4056;
            text-decoration: none;
        }
        .content a:hover {
            text-decoration: underline;
        }
        .footer { 
            margin-top: 64px; 
            padding-top: 32px; 
            border-top: 2px solid #f3f4f6; 
            color: #6b7280; 
            font-size: 0.95em; 
        }
        .footer a {
            color: #ef4056;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">${this.escapeHtml(article.title)}</h1>
        <div class="meta">
            <div class="meta-item">üåê <strong>From:</strong> <a href="${article.url}">${this.getDomain(article.url)}</a></div>
            ${article.author ? `<div class="meta-item">‚úçÔ∏è <strong>By:</strong> ${this.escapeHtml(article.author)}</div>` : ''}
            <div class="meta-item">üìÖ <strong>Saved:</strong> ${this.formatDate(article.dateAdded)}</div>
            <div class="meta-item">‚è±Ô∏è <strong>Reading time:</strong> ${article.readTime || 1} minutes</div>
        </div>
    </div>
    <div class="content">
        ${article.content}
    </div>
    <div class="footer">
        <p><strong>‚ú® Exported from MyPocket Web Reader</strong></p>
        <p><strong>Original URL:</strong> <a href="${article.url}">${article.url}</a></p>
        <p><strong>Export Date:</strong> ${new Date().toLocaleDateString()}</p>
    </div>
</body>
</html>`;
            }

            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                URL.revokeObjectURL(url);
            }

            getDomain(url) {
                try {
                    return new URL(url).hostname.replace('www.', '');
                } catch (e) {
                    return url;
                }
            }

            formatDate(dateString) {
                try {
                    const date = new Date(dateString);

                    if (isNaN(date.getTime())) {
                        console.error('Invalid date:', dateString);
                        return 'invalid date';
                    }

                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const targetDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                    const diffMs = today.getTime() - targetDate.getTime();
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

                    if (diffDays < 0) {
                        return date.toLocaleDateString();
                    }

                    if (diffDays === 0) {
                        return 'today';
                    } else if (diffDays === 1) {
                        return 'yesterday';
                    } else if (diffDays <= 7) {
                        return `${diffDays} days ago`;
                    } else if (diffDays <= 30) {
                        const weeks = Math.floor(diffDays / 7);
                        return weeks === 1 ? '1 week ago' : `${weeks} weeks ago`;
                    } else if (diffDays <= 365) {
                        const months = Math.floor(diffDays / 30);
                        return months === 1 ? '1 month ago' : `${months} months ago`;
                    } else {
                        const years = Math.floor(diffDays / 365);
                        return years === 1 ? '1 year ago' : `${years} years ago`;
                    }
                } catch (error) {
                    console.error('Date formatting error:', error, 'Input:', dateString);
                    return 'date error';
                }
            }

            formatWordCount(count) {
                if (count < 1000) {
                    return `${count} words`;
                } else {
                    return `${(count / 1000).toFixed(1)}k words`;
                }
            }

            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            sanitizeFilename(filename) {
                if (!filename) return 'article';
                return filename.replace(/[^a-z0-9\s]/gi, '_').toLowerCase().substring(0, 50);
            }

            showDebugInfo() {
                const firstArticle = this.articles.length > 0 ? this.articles[0] : null;
                
                let articleInfo = 'No articles loaded';
                if (firstArticle) {
                    articleInfo = {
                        title: firstArticle.title,
                        url: firstArticle.url,
                        hasContent: !!firstArticle.content,
                        contentLength: firstArticle.content ? firstArticle.content.length : 0,
                        hasTextContent: !!firstArticle.textContent,
                        textContentLength: firstArticle.textContent ? firstArticle.textContent.length : 0,
                        hasExcerpt: !!firstArticle.excerpt,
                        excerptLength: firstArticle.excerpt ? firstArticle.excerpt.length : 0,
                        hasImages: !!firstArticle.images,
                        imagesArray: firstArticle.images,
                        featuredImage: firstArticle.featuredImage,
                        image: firstArticle.image,
                        thumbnail: firstArticle.thumbnail,
                        allKeys: Object.keys(firstArticle)
                    };
                }

                const info = `
MyPocket Web Reader Debug Info:
=====================================

CONNECTION:
Current URL: ${window.location.href}
Redirect URI: ${this.redirectUri}
Has Access Token: ${!!this.accessToken}
Articles Loaded: ${this.articles.length}

SAMPLE ARTICLE DATA:
${JSON.stringify(articleInfo, null, 2)}

TROUBLESHOOTING:
- If no images: Articles may not have image data saved
- If no content: Articles may only have excerpts
- Check browser extension settings to save full content
- Some sites block content extraction

POSSIBLE FIXES:
1. Re-save articles with browser extension
2. Check extension settings for full content saving
3. Try different articles to see if issue is specific
                `;

                alert(info);
                console.log('üîß Debug Info:', {
                    currentUrl: window.location.href,
                    redirectUri: this.redirectUri,
                    hasToken: !!this.accessToken,
                    articlesCount: this.articles.length,
                    sampleArticle: firstArticle,
                    allArticles: this.articles.slice(0, 3) // Show first 3 articles
                });
            }

            getDebugImageUrl(article) {
                if (article.images && Array.isArray(article.images) && article.images.length > 0) {
                    return article.images[0].src || article.images[0].url || article.images[0];
                }
                if (article.featuredImage) return article.featuredImage;
                if (article.image) return article.image;
                if (article.thumbnail) return article.thumbnail;
                return 'No image found';
            }

            toggleDarkMode() {
                document.body.classList.toggle('dark-mode');
                const isDarkMode = document.body.classList.contains('dark-mode');
                
                // Save preference
                localStorage.setItem('mypocket_dark_mode', isDarkMode);
                
                // Update button
                const darkModeBtn = document.getElementById('darkModeBtn');
                if (darkModeBtn) {
                    darkModeBtn.innerHTML = isDarkMode 
                        ? '<span>‚òÄÔ∏è</span> Light' 
                        : '<span>üåô</span> Dark';
                }

                this.updateStatus(
                    isDarkMode ? 'üåô Dark mode enabled' : '‚òÄÔ∏è Light mode enabled',
                    'success'
                );
            }

            toggleTestMode() {
                document.body.classList.toggle('test-mode');
                const isTestMode = document.body.classList.contains('test-mode');

                const testBtn = document.getElementById('testBtn');
                if (testBtn) {
                    if (isTestMode) {
                        testBtn.innerHTML = '<span>üìù</span> Sample';
                        testBtn.title = 'Hide sample articles';
                    } else {
                        testBtn.innerHTML = '<span>üìù</span> Test';
                        testBtn.title = 'Show sample articles';
                    }
                }

                // If test mode and no articles, show sample data
                if (isTestMode && this.articles.length === 0) {
                    this.showSampleArticles();
                } else if (!isTestMode && this.articles.length > 0 && this.articles[0].title === 'Sample Article: How to Use MyPocket') {
                    // Remove sample articles when exiting test mode
                    this.articles = [];
                    this.displayEmptyState();
                }

                this.updateStatus(
                    isTestMode
                        ? 'üîç Test mode ON - Action buttons always visible'
                        : 'üëÅÔ∏è Test mode OFF - Action buttons show on hover',
                    'success'
                );
            }

            loadDarkModePreference() {
                const isDarkMode = localStorage.getItem('mypocket_dark_mode') === 'true';
                if (isDarkMode) {
                    document.body.classList.add('dark-mode');
                    const darkModeBtn = document.getElementById('darkModeBtn');
                    if (darkModeBtn) {
                        darkModeBtn.innerHTML = '<span>‚òÄÔ∏è</span> Light';
                    }
                }
            }
                document.body.classList.toggle('test-mode');
                const isTestMode = document.body.classList.contains('test-mode');

                const testBtn = document.getElementById('testBtn');
                if (testBtn) {
                    if (isTestMode) {
                        testBtn.innerHTML = '<span>üìù</span> Sample';
                        testBtn.title = 'Hide sample articles';
                    } else {
                        testBtn.innerHTML = '<span>üìù</span> Test';
                        testBtn.title = 'Show sample articles';
                    }
                }

                // If test mode and no articles, show sample data
                if (isTestMode && this.articles.length === 0) {
                    this.showSampleArticles();
                } else if (!isTestMode && this.articles.length > 0 && this.articles[0].title === 'Sample Article: How to Use MyPocket') {
                    // Remove sample articles when exiting test mode
                    this.articles = [];
                    this.displayEmptyState();
                }

                this.updateStatus(
                    isTestMode
                        ? 'üîç Test mode ON - Action buttons always visible'
                        : 'üëÅÔ∏è Test mode OFF - Action buttons show on hover',
                    'success'
                );
            }

            showSampleArticles() {
                this.articles = [
                    {
                        title: 'The Future of Web Reading: How Digital Platforms Are Changing',
                        excerpt: 'Digital reading platforms are revolutionizing how we consume content. From Pocket to Instapaper, discover the evolution of read-later apps and what comes next.',
                        url: 'https://example.com/future-of-reading',
                        dateAdded: new Date().toISOString(),
                        readTime: 5,
                        wordCount: 1200,
                        content: `
                            <h2>The Evolution of Digital Reading</h2>
                            <p>In the past decade, digital reading platforms have fundamentally transformed how we consume written content online. What started as simple bookmarking tools have evolved into sophisticated content curation systems that help millions of users manage information overload.</p>
                            
                            <h3>The Rise of Read-Later Apps</h3>
                            <p>Applications like Pocket, Instapaper, and others emerged to solve a specific problem: the overwhelming amount of content available online and our limited time to consume it all immediately.</p>
                            
                            <blockquote>
                                "The future of reading isn't just about consuming content‚Äîit's about curating meaningful experiences that enhance our understanding of the world."
                            </blockquote>
                            
                            <p>These platforms offer several key benefits:</p>
                            <ul>
                                <li><strong>Distraction-free reading:</strong> Clean interfaces that remove ads and clutter</li>
                                <li><strong>Cross-device synchronization:</strong> Access your articles anywhere</li>
                                <li><strong>Offline availability:</strong> Read without internet connectivity</li>
                                <li><strong>Content preservation:</strong> Save articles even if they're later removed</li>
                            </ul>
                            
                            <h3>Personal Knowledge Management</h3>
                            <p>Modern reading apps are becoming more than just repositories‚Äîthey're turning into personal knowledge management systems. Features like tagging, highlighting, and note-taking transform passive reading into active learning.</p>
                            
                            <p>The integration of AI and machine learning is also opening new possibilities for content discovery and organization, making these tools even more powerful for researchers, students, and knowledge workers.</p>
                            
                            <h3>What's Next?</h3>
                            <p>As we look to the future, we can expect to see more sophisticated features around content analysis, automatic summarization, and intelligent recommendations. The goal is not just to save content, but to help users extract maximum value from what they read.</p>
                        `,
                        images: [
                            { src: 'https://images.unsplash.com/photo-1481627834876-b7833e8f5570?w=400&h=200&fit=crop' }
                        ]
                    },
                    {
                        title: 'Building Better Reading Habits in the Digital Age',
                        excerpt: 'With endless distractions and information overload, maintaining focus while reading has become more challenging than ever. Here are proven strategies to improve your digital reading experience.',
                        url: 'https://example.com/reading-habits',
                        dateAdded: new Date(Date.now() - 86400000).toISOString(),
                        readTime: 7,
                        wordCount: 1800,
                        content: `
                            <h2>The Challenge of Digital Reading</h2>
                            <p>Our brains are wired for deep, focused reading, but the digital environment presents unique challenges. Hyperlinks, notifications, and the endless scroll of social media have trained us for quick, surface-level consumption rather than deep engagement with text.</p>
                            
                            <h3>Strategies for Better Reading</h3>
                            <p>Research in cognitive science has revealed several effective techniques for improving reading comprehension and retention in digital environments:</p>
                            
                            <h4>1. Create a Dedicated Reading Environment</h4>
                            <p>Just as you might have a physical reading nook, create a digital equivalent. This means:</p>
                            <ul>
                                <li>Using distraction-free reading apps like MyPocket</li>
                                <li>Turning off notifications during reading sessions</li>
                                <li>Setting specific times for reading</li>
                            </ul>
                            
                            <h4>2. Practice Active Reading</h4>
                            <p>Don't just consume content passively. Engage with it:</p>
                            <ul>
                                <li>Take notes while reading</li>
                                <li>Highlight important passages</li>
                                <li>Ask yourself questions about the content</li>
                                <li>Summarize key points after reading</li>
                            </ul>
                            
                            <blockquote>
                                "Reading is not just about information consumption‚Äîit's about transformation. The goal is not to read more, but to understand better."
                            </blockquote>
                            
                            <h4>3. Use the Pomodoro Technique</h4>
                            <p>Break your reading into focused 25-minute sessions with short breaks. This helps maintain concentration and prevents mental fatigue.</p>
                            
                            <h3>The Science Behind Reading Retention</h3>
                            <p>Studies show that we retain information better when we:</p>
                            <ul>
                                <li>Read in a consistent environment</li>
                                <li>Take regular breaks</li>
                                <li>Connect new information to existing knowledge</li>
                                <li>Review material shortly after reading</li>
                            </ul>
                            
                            <p>By implementing these strategies and using tools designed for focused reading, we can reclaim our ability to engage deeply with written content, even in our hyperconnected world.</p>
                        `,
                        images: [
                            { src: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=200&fit=crop' }
                        ]
                    },
                    {
                        title: 'Open Source Alternatives to Popular Reading Apps',
                        excerpt: 'Privacy-conscious readers are turning to open source alternatives. Explore self-hosted options and community-driven projects that put users in control.',
                        url: 'https://example.com/open-source-reading',
                        dateAdded: new Date(Date.now() - 172800000).toISOString(),
                        readTime: 4,
                        wordCount: 950,
                        content: `
                            <h2>Why Open Source Matters for Reading Apps</h2>
                            <p>In an era of increasing concerns about data privacy and platform dependency, many users are seeking alternatives to commercial reading applications. Open source solutions offer transparency, customization, and user control that proprietary apps cannot match.</p>
                            
                            <h3>Popular Open Source Reading Tools</h3>
                            <p>Several excellent open source projects have emerged to serve the read-later and content curation market:</p>
                            
                            <h4>Wallabag</h4>
                            <p>Perhaps the most well-known open source alternative to Pocket, Wallabag offers:</p>
                            <ul>
                                <li>Self-hosting capabilities</li>
                                <li>Article archiving and full-text search</li>
                                <li>Mobile apps for iOS and Android</li>
                                <li>Export capabilities in multiple formats</li>
                            </ul>
                            
                            <h4>Shiori</h4>
                            <p>A simple bookmarks manager written in Go, perfect for users who want something lightweight and fast.</p>
                            
                            <h4>LinkAce</h4>
                            <p>A comprehensive bookmark and link management system with advanced organization features.</p>
                            
                            <h3>Benefits of Self-Hosting</h3>
                            <p>When you self-host your reading application, you gain:</p>
                            <ul>
                                <li><strong>Complete data ownership:</strong> Your articles and reading habits stay private</li>
                                <li><strong>Customization freedom:</strong> Modify the interface and features to your needs</li>
                                <li><strong>No vendor lock-in:</strong> You're not dependent on a company's business decisions</li>
                                <li><strong>Learning opportunities:</strong> Understanding how these systems work</li>
                            </ul>
                            
                            <h3>Getting Started</h3>
                            <p>Setting up your own reading app might seem daunting, but many solutions offer Docker containers and one-click deployment options. Start small with a simple setup and expand as you become more comfortable with the technology.</p>
                            
                            <p>The open source ecosystem for reading and content management continues to grow, offering viable alternatives for users who want to take control of their digital reading experience.</p>
                        `,
                        // This article intentionally has no image to test the placeholder
                    }
                ];

                this.displayArticles(this.articles);
                this.updateStatus('üìù Showing sample articles with working images and content - Click test mode again to hide', 'success');
            }
        }

        // Initialize the web reader
        let webReader;
        document.addEventListener('DOMContentLoaded', () => {
            webReader = new MyPocketWebReader();
            window.webReader = webReader;
        });
    </script>
</body>

</html>
