<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyPocket - Enhanced Web Reader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #ee5a24;
            --secondary-color: #667eea;
            --background: #f8f9fa;
            --surface: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --border: #e9ecef;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.15);
            --success-color: #27ae60;
            --error-color: #e74c3c;
            --warning-color: #f39c12;
        }

        /* Enhanced Dark mode with better contrast */
        [data-theme="dark"] {
            --primary-color: #ff6b35;
            --secondary-color: #7b88f7;
            --background: #0d1117;
            --surface: #161b22;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --border: #30363d;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.6);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.8);
        }

        /* Dark mode specific improvements */
        [data-theme="dark"] .article-card {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .article-card:hover {
            border-color: #484f58;
            transform: translateY(-2px) scale(1.02);
        }

        [data-theme="dark"] .search-input {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .search-input:focus {
            border-color: var(--primary-color);
            background: var(--surface);
        }

        [data-theme="dark"] .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.8;
        }

        [data-theme="dark"] .search-close-btn:hover {
            background: #21262d;
            color: var(--text-primary);
        }

        [data-theme="dark"] .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border-color: var(--border);
        }

        [data-theme="dark"] .btn-secondary:hover {
            background: #21262d;
            border-color: #484f58;
            color: var(--text-primary);
        }

        [data-theme="dark"] .action-btn {
            background: rgba(22, 27, 34, 0.95);
            border-color: var(--border);
            color: var(--text-primary);
            backdrop-filter: blur(10px);
        }

        [data-theme="dark"] .action-btn:hover {
            background: rgba(33, 38, 45, 0.95);
            border-color: #484f58;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--background);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Enhanced Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(4px);
        }

        .loading-content {
            background: var(--surface);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: var(--shadow-hover);
            max-width: 400px;
            width: 90%;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--border);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .spinner.small {
            width: 20px;
            height: 20px;
            border-width: 2px;
        }

        .spinner.large {
            width: 60px;
            height: 60px;
            border-width: 6px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 20px;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-color);
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Enhanced Notification System */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px 20px;
            box-shadow: var(--shadow);
            z-index: 10000;
            max-width: 400px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            border-left: 4px solid var(--success-color);
        }

        .notification.error {
            border-left: 4px solid var(--error-color);
        }

        .notification.warning {
            border-left: 4px solid var(--warning-color);
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            color: white;
            padding: 20px 0;
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .logo {
            font-size: 1.8em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .btn-primary:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--border);
            transform: translateY(-1px);
        }

        /* Enhanced Search */
        .search-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 90;
            padding: 30px 0;
            max-height: 0;
            overflow: hidden;
        }

        .search-container.visible {
            opacity: 1;
            transform: translateY(0);
            max-height: 200px;
        }

        .search-box {
            position: relative;
            max-width: 600px;
            margin: 0 auto;
        }

        .search-input {
            width: 100%;
            padding: 15px 50px 15px 20px;
            border: 2px solid var(--border);
            border-radius: 25px;
            font-size: 16px;
            background: var(--background);
            transition: border-color 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .search-close-btn {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .search-close-btn:hover {
            background: var(--border);
            color: var(--text-primary);
            transform: translateY(-50%) scale(1.1);
        }

        /* Status */
        .status {
            padding: 20px 0;
            text-align: center;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            transition: all 0.3s ease;
        }

        .status.loading {
            color: var(--secondary-color);
        }

        .status.error {
            color: var(--error-color);
        }

        .status.success {
            color: var(--success-color);
        }

        .status.warning {
            color: var(--warning-color);
        }

        /* Articles Grid */
        .articles-section {
            padding: 40px 0;
            min-height: 60vh;
        }

        .articles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 18px;
            margin-top: 20px;
        }

        /* Enhanced Article Cards */
        .article-card {
            background: var(--surface);
            border-radius: 32px 24px 32px 24px;
            overflow: visible;
            box-shadow: var(--shadow);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border: 1px solid var(--border);
            position: relative;
            display: flex;
            flex-direction: column;
            transform-origin: center center;
            cursor: pointer;
        }

        .article-card:nth-child(3n+1) {
            border-radius: 28px 36px 28px 36px;
        }

        .article-card:nth-child(3n+2) {
            border-radius: 35px 25px 35px 25px;
        }

        .article-card:nth-child(3n+3) {
            border-radius: 30px 30px 40px 20px;
        }

        .article-card:nth-child(4n+1) {
            border-radius: 40px 20px 30px 30px;
        }

        .article-card:nth-child(5n+1) {
            border-radius: 25px 35px 25px 35px;
        }

        .article-card:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-8px) scale(1.02) rotate(1deg);
            border-color: var(--primary-color);
        }

        .article-card:nth-child(even):hover {
            transform: translateY(-8px) scale(1.02) rotate(-1deg);
        }

        .article-card:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
        }

        .article-image {
            width: 100%;
            height: 100px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: white;
            position: relative;
            overflow: hidden;
            border-radius: inherit;
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 16px;
        }

        .article-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.4s ease, opacity 0.3s ease;
        }

        .article-image:hover img {
            transform: scale(1.08);
        }

        .article-content {
            padding: 15px;
            flex: 1;
            cursor: pointer;
            border-radius: 0 0 inherit inherit;
        }

        .article-title {
            font-size: 1em;
            font-weight: 600;
            margin-bottom: 6px;
            line-height: 1.3;
            color: var(--text-primary);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-excerpt {
            color: var(--text-secondary);
            font-size: 0.8em;
            line-height: 1.4;
            margin-bottom: 10px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
            color: var(--text-secondary);
            font-size: 0.75em;
            margin-bottom: 6px;
        }

        .article-domain {
            font-weight: 500;
        }

        .article-date {
            opacity: 0.8;
        }

        .article-stats {
            display: flex;
            gap: 10px;
            font-size: 0.7em;
            color: var(--text-secondary);
        }

        /* Enhanced Action Buttons */
        .article-actions {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 6px;
            opacity: 0 !important;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid var(--border);
            border-radius: 50%;
            padding: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            min-width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn:hover {
            transform: translateY(-4px) scale(1.15);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
            border-radius: 40% 60% 70% 30%;
        }

        .action-btn:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        .read-btn:hover {
            background: #e3f2fd;
            border-color: #2196f3;
            border-radius: 60% 40% 30% 70%;
        }

        .export-btn:hover {
            background: #e8f5e8;
            border-color: #4caf50;
            border-radius: 30% 70% 60% 40%;
        }

        .refresh-image-btn:hover {
            background: #fff3e0;
            border-color: #ff9800;
            border-radius: 40% 60% 40% 60%;
        }

        .delete-btn {
            color: #f44336;
        }

        .delete-btn:hover {
            background: #ffebee;
            border-color: #f44336;
            color: #d32f2f;
            border-radius: 70% 30% 40% 60%;
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
        }

        .article-actions:hover {
            opacity: 1 !important;
            visibility: visible !important;
        }

        /* Cache indicator */
        .cache-indicator {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            z-index: 5;
        }

        .cache-indicator.synced {
            background: rgba(76, 175, 80, 0.8);
            color: white;
        }

        .cache-indicator.cached {
            background: rgba(52, 152, 219, 0.8);
            color: white;
        }

        .cache-indicator.fallback {
            background: rgba(255, 152, 0, 0.8);
            color: white;
        }

        .cache-indicator.metadata {
            background: rgba(103, 58, 183, 0.8);
            color: white;
        }

        .cache-indicator.error {
            background: rgba(244, 67, 54, 0.8);
            color: white;
        }

        /* Reader View */
        .reader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            overflow-y: auto;
        }

        .reader-overlay.active {
            display: block;
        }

        .reader-container {
            max-width: 800px;
            margin: 40px auto;
            background: var(--surface);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.3);
        }

        .reader-header {
            padding: 30px;
            border-bottom: 1px solid var(--border);
            background: var(--background);
        }

        .reader-title {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 15px;
            line-height: 1.3;
        }

        .reader-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .reader-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .reader-content {
            padding: 40px;
            font-size: 1.1em;
            line-height: 1.8;
            max-width: none;
        }

        .reader-content h1,
        .reader-content h2,
        .reader-content h3 {
            margin: 30px 0 15px;
            color: var(--text-primary);
        }

        .reader-content p {
            margin-bottom: 20px;
        }

        .reader-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
        }

        .reader-content blockquote {
            border-left: 4px solid var(--primary-color);
            margin: 20px 0;
            padding: 15px 20px;
            background: var(--background);
            font-style: italic;
        }

        .close-reader {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-reader:hover {
            border-radius: 30% 70% 70% 30%;
            transform: scale(1.1);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        /* Enhanced Mobile Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 0 12px;
            }

            .header {
                padding: 15px 0;
                position: relative;
            }

            .header-content {
                flex-direction: column;
                text-align: center;
                gap: 15px;
            }

            .logo {
                font-size: 1.5em;
                margin-bottom: 10px;
            }

            .header-actions {
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
            }

            .btn {
                padding: 8px 16px;
                font-size: 13px;
                border-radius: 20px;
            }

            .search-container {
                padding: 20px 0;
            }

            .search-input {
                font-size: 16px !important;
                padding: 12px 45px 12px 16px;
                border-radius: 20px;
            }

            .search-close-btn {
                right: 12px;
                width: 28px;
                height: 28px;
                font-size: 16px;
            }

            .status {
                padding: 15px 0;
                font-size: 14px;
                line-height: 1.4;
            }

            .articles-section {
                padding: 20px 0;
            }

            .articles-grid {
                display: block;
                margin-top: 15px;
            }

            .article-card {
                display: block !important;
                width: 100% !important;
                margin-bottom: 20px !important;
                border-radius: 20px !important;
                overflow: hidden;
                background: var(--surface);
                border: 1px solid var(--border);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                transform: none !important;
                animation: none !important;
            }

            .article-card:hover {
                transform: none !important;
                box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
            }

            .article-image {
                width: 100% !important;
                height: 140px !important;
                border-radius: 20px 20px 0 0 !important;
                position: relative;
            }

            .article-content {
                padding: 20px !important;
                cursor: pointer;
            }

            .article-title {
                font-size: 1.25em !important;
                font-weight: 600;
                margin-bottom: 10px !important;
                line-height: 1.4 !important;
                color: var(--text-primary);
                display: block !important;
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-excerpt {
                font-size: 1em !important;
                line-height: 1.5 !important;
                margin-bottom: 15px !important;
                color: var(--text-secondary);
                display: block !important;
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-meta {
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-wrap: wrap;
                gap: 8px;
                color: var(--text-secondary);
                font-size: 0.9em !important;
                margin-bottom: 10px;
            }

            .article-stats {
                display: flex;
                gap: 15px;
                font-size: 0.85em !important;
                color: var(--text-secondary);
                margin-bottom: 10px;
            }

            .article-actions {
                position: static !important;
                opacity: 1 !important;
                visibility: visible !important;
                display: flex !important;
                justify-content: center;
                gap: 12px;
                padding: 15px 20px;
                background: var(--background);
                border-radius: 0;
                margin: 0;
                border-top: 1px solid var(--border);
            }

            .action-btn {
                min-width: 45px !important;
                height: 45px !important;
                font-size: 18px !important;
                border-radius: 50% !important;
                padding: 0;
                background: var(--surface);
                border: 2px solid var(--border);
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .action-btn:hover,
            .action-btn:active {
                border-radius: 50% !important;
                transform: scale(1.05);
                background: var(--primary-color);
                color: white;
                border-color: var(--primary-color);
            }

            .reader-overlay {
                padding: 0;
            }

            .reader-container {
                margin: 0 !important;
                border-radius: 0 !important;
                height: 100vh;
                max-width: none;
                display: flex;
                flex-direction: column;
            }

            .reader-header {
                padding: 20px;
                border-radius: 0;
                flex-shrink: 0;
            }

            .reader-title {
                font-size: 1.4em !important;
                line-height: 1.3;
                margin-bottom: 15px;
            }

            .reader-meta {
                font-size: 0.9em;
                gap: 15px;
            }

            .reader-content {
                padding: 20px;
                font-size: 1.1em !important;
                line-height: 1.7 !important;
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            .close-reader {
                top: 15px;
                right: 15px;
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .search-input {
                font-size: 16px !important;
                padding: 14px 50px 14px 18px;
            }

            .empty-state {
                padding: 40px 20px;
            }

            .empty-state-icon {
                font-size: 3em;
                margin-bottom: 15px;
            }

            .empty-state h3 {
                font-size: 1.3em;
                margin-bottom: 8px;
            }

            .empty-state p {
                font-size: 1em;
                line-height: 1.5;
            }

            .notification {
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: none;
                font-size: 14px;
            }

            .loading-content {
                padding: 30px 20px;
                margin: 0 20px;
            }
        }

        /* Extra small screens */
        @media (max-width: 480px) {
            .article-title {
                font-size: 1.15em !important;
            }

            .article-excerpt {
                font-size: 0.95em !important;
            }

            .article-content {
                padding: 16px !important;
            }

            .header-actions {
                gap: 6px;
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        /* Test mode for debugging */
        body.test-mode .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
            background: rgba(255, 255, 0, 0.1);
            border: 2px dashed #ff9800;
            border-radius: 20px;
            padding: 5px;
        }

        /* Accessibility improvements */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Focus visible for better keyboard navigation */
        .btn:focus-visible,
        .article-card:focus-visible,
        .action-btn:focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        /* Reduced motion preference */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>

<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    📚 MyPocket Enhanced Reader
                </div>
                <div class="header-actions">
                    <button id="connectBtn" class="btn btn-primary" aria-label="Connect to OneDrive">
                        <span id="connectIcon">🔐</span>
                        <span id="connectText">Secure Connect</span>
                    </button>
                    <button id="refreshBtn" class="btn btn-secondary" style="display: none;" aria-label="Refresh articles">
                        <span>🔄</span> Refresh
                    </button>
                    <button id="searchToggleBtn" class="btn btn-secondary" aria-label="Toggle search">
                        <span>🔍</span> Search
                    </button>
                    <button id="clearCacheBtn" class="btn btn-secondary" aria-label="Clear image cache">
                        <span>🗑️</span> Clear Cache
                    </button>
                    <button id="syncBtn" class="btn btn-secondary" style="display: none;" aria-label="Sync images">
                        <span>🔄</span> Sync Images
                    </button>
                    <button id="retryFailedBtn" class="btn btn-secondary" style="display: none;" aria-label="Retry failed images">
                        <span>🔄</span> Retry Failed
                    </button>
                    <button id="helpBtn" class="btn btn-secondary" aria-label="Show help">
                        <span>❓</span> Help
                    </button>
                    <button id="debugBtn" class="btn btn-secondary" aria-label="Show debug info">
                        <span>🔧</span> Debug
                    </button>
                    <button id="testBtn" class="btn btn-secondary" aria-label="Toggle test mode">
                        <span>👁️</span> Show Buttons
                    </button>
                    <button id="darkModeBtn" class="btn btn-secondary" aria-label="Toggle dark mode">
                        <span>🌙</span> Dark Mode
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Search (Initially Hidden) -->
    <section class="search-container" id="searchContainer" style="display: none;" role="search">
        <div class="container">
            <div class="search-box">
                <label for="searchInput" class="sr-only">Search articles</label>
                <input type="text" id="searchInput" class="search-input" placeholder="Search your saved articles..."
                    autocomplete="off" aria-describedby="searchHelp">
                <button class="search-close-btn" aria-label="Close search" title="Close search">✕</button>
                <div id="searchHelp" class="sr-only">Type to search through article titles, content, and metadata</div>
            </div>
        </div>
    </section>

    <!-- Status -->
    <div class="status" id="status" role="status" aria-live="polite">
        Connect to OneDrive to view your saved articles
    </div>

    <!-- Articles -->
    <main class="articles-section">
        <div class="container">
            <div id="articlesContainer" role="main" aria-label="Articles list">
                <div class="empty-state">
                    <div class="empty-state-icon">📖</div>
                    <h3>Welcome to MyPocket Enhanced Reader</h3>
                    <p>Connect to OneDrive to access your saved articles from anywhere!</p>
                </div>
            </div>
        </div>
    </main>

    <!-- Reader Overlay -->
    <div class="reader-overlay" id="readerOverlay" role="dialog" aria-modal="true" aria-labelledby="readerTitle">
        <div class="reader-container">
            <button class="close-reader" id="closeReader" aria-label="Close reader">✕</button>
            <div class="reader-header">
                <h1 class="reader-title" id="readerTitle">Article Title</h1>
                <div class="reader-meta" id="readerMeta">
                    <span>📅 <span id="readerDate">Date</span></span>
                    <span>🌐 <span id="readerDomain">Domain</span></span>
                    <span>⏱️ <span id="readerTime">5 min read</span></span>
                </div>
                <div class="reader-actions">
                    <button class="btn btn-secondary" id="openOriginal" aria-label="Open original article">
                        🔗 Open Original
                    </button>
                </div>
            </div>
            <div class="reader-content" id="readerContent" tabindex="0">
                Article content will appear here...
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            API: {
                MICROSOFT_CLIENT_ID: '436e8796-8c40-47c3-9ad5-b8882f3ef7f7',
                GRAPH_API_BASE: 'https://graph.microsoft.com/v1.0',
                TOKEN_REFRESH_THRESHOLD: 5 * 60 * 1000, // 5 minutes
            },
            CACHE: {
                EXPIRY_DAYS: 7,
                MAX_IMAGE_SIZE_KB: 500,
                MAX_CACHE_SIZE_MB: 50,
            },
            UI: {
                SEARCH_DEBOUNCE_MS: 300,
                ANIMATION_DURATION: 300,
                NOTIFICATION_DURATION: 5000,
            },
            STORAGE: {
                KEYS: {
                    ACCESS_TOKEN: 'mypocket_access_token',
                    REFRESH_TOKEN: 'mypocket_refresh_token',
                    THEME: 'mypocket_theme',
                    IMAGE_CACHE: 'mypocket_image_cache',
                    TOKEN_TIMESTAMP: 'mypocket_token_timestamp',
                }
            }
        };

        // Utility Functions
        class Utils {
            static debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            static async withRetry(fn, maxRetries = 3, delay = 1000) {
                for (let i = 0; i < maxRetries; i++) {
                    try {
                        return await fn();
                    } catch (error) {
                        if (i === maxRetries - 1) throw error;
                        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
                    }
                }
            }

            static generateRandomString(length = 32) {
                const array = new Uint8Array(length);
                crypto.getRandomValues(array);
                return this.base64URLEncode(array);
            }

            static base64URLEncode(array) {
                return btoa(String.fromCharCode.apply(null, array))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            }

            static async sha256(text) {
                const encoder = new TextEncoder();
                const data = encoder.encode(text);
                const digest = await crypto.subtle.digest('SHA-256', data);
                return this.base64URLEncode(new Uint8Array(digest));
            }

            static escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            static sanitizeFilename(filename) {
                if (!filename) return 'article';
                return filename.replace(/[^a-z0-9\s]/gi, '_').toLowerCase().substring(0, 50);
            }

            static getDomain(url) {
                try {
                    return new URL(url).hostname.replace('www.', '');
                } catch (e) {
                    return url;
                }
            }

            static formatDate(dateString) {
                try {
                    const date = new Date(dateString);
                    if (isNaN(date.getTime())) return 'invalid date';

                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const targetDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                    const diffMs = today.getTime() - targetDate.getTime();
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

                    if (diffDays < 0) return date.toLocaleDateString();
                    if (diffDays === 0) return 'today';
                    if (diffDays === 1) return 'yesterday';
                    if (diffDays <= 7) return `${diffDays} days ago`;
                    if (diffDays <= 30) {
                        const weeks = Math.floor(diffDays / 7);
                        return weeks === 1 ? '1 week ago' : `${weeks} weeks ago`;
                    }
                    if (diffDays <= 365) {
                        const months = Math.floor(diffDays / 30);
                        return months === 1 ? '1 month ago' : `${months} months ago`;
                    }
                    const years = Math.floor(diffDays / 365);
                    return years === 1 ? '1 year ago' : `${years} years ago`;
                } catch (error) {
                    console.error('Date formatting error:', error);
                    return 'date error';
                }
            }

            static makeAbsoluteUrl(imageUrl, baseUrl) {
                if (!imageUrl) return null;
                try {
                    if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) return imageUrl;
                    if (imageUrl.startsWith('//')) return 'https:' + imageUrl;
                    const base = new URL(baseUrl);
                    return new URL(imageUrl, base.origin).href;
                } catch (error) {
                    console.log(`Failed to make absolute URL: ${imageUrl}`);
                    return null;
                }
            }
        }

        // Error Management
        class ErrorManager {
            static handleError(error, context = '', userMessage = '') {
                console.error(`[${context}] ${error.message}`, error);
                
                if (userMessage) {
                    NotificationManager.show(userMessage, 'error');
                }
                
                // In production, you might want to send to an error tracking service
                this.logError(error, context);
            }

            static logError(error, context) {
                // Store error for debugging
                const errorLog = {
                    message: error.message,
                    stack: error.stack,
                    context,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };
                
                // In production, send to error tracking service
                console.log('Error logged:', errorLog);
            }

            static async withErrorHandling(fn, context, userMessage) {
                try {
                    return await fn();
                } catch (error) {
                    this.handleError(error, context, userMessage);
                    throw error;
                }
            }
        }

        // Loading State Manager
        class LoadingStateManager {
            constructor() {
                this.activeStates = new Set();
            }

            show(key, message = 'Loading...', options = {}) {
                this.activeStates.add(key);
                
                // Remove existing loader if any
                this.hide(key);
                
                const loader = document.createElement('div');
                loader.id = `loader-${key}`;
                loader.className = 'loading-overlay';
                loader.innerHTML = `
                    <div class="loading-content">
                        <div class="spinner ${options.size || 'medium'}"></div>
                        <p>${message}</p>
                        ${options.progress ? '<div class="progress-bar"><div class="progress-fill"></div></div>' : ''}
                    </div>
                `;
                
                document.body.appendChild(loader);
                
                if (options.timeout) {
                    setTimeout(() => this.hide(key), options.timeout);
                }
            }

            updateProgress(key, percent) {
                const progressFill = document.querySelector(`#loader-${key} .progress-fill`);
                if (progressFill) {
                    progressFill.style.width = `${Math.min(100, Math.max(0, percent))}%`;
                }
            }

            hide(key) {
                this.activeStates.delete(key);
                const loader = document.getElementById(`loader-${key}`);
                if (loader) {
                    loader.remove();
                }
            }

            hideAll() {
                this.activeStates.forEach(key => this.hide(key));
                this.activeStates.clear();
            }
        }

        // Notification Manager
        class NotificationManager {
            static show(message, type = 'info', duration = CONFIG.UI.NOTIFICATION_DURATION) {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.innerHTML = `
                    <div>${message}</div>
                `;
                
                document.body.appendChild(notification);
                
                // Trigger animation
                setTimeout(() => notification.classList.add('show'), 10);
                
                // Auto remove
                setTimeout(() => {
                    notification.classList.remove('show');
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, duration);
            }

            static success(message, duration) {
                this.show(message, 'success', duration);
            }

            static error(message, duration) {
                this.show(message, 'error', duration);
            }

            static warning(message, duration) {
                this.show(message, 'warning', duration);
            }
        }

        // Authentication Manager
        class AuthenticationManager {
            constructor() {
                this.clientId = CONFIG.API.MICROSOFT_CLIENT_ID;
                this.redirectUri = this.getRedirectUri();
                this.accessToken = null;
                this.codeVerifier = null;
                this.codeChallenge = null;
                this.state = null;
            }

            getRedirectUri() {
                const currentUrl = window.location.href;
                const baseUrl = currentUrl.split('#')[0].split('?')[0];
                
                if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {
                    return baseUrl;
                } else {
                    return window.location.origin + window.location.pathname;
                }
            }

            async authenticate() {
                try {
                    if (!this.redirectUri || (!this.redirectUri.startsWith('http://') && !this.redirectUri.startsWith('https://'))) {
                        const errorMsg = 'Invalid redirect URI. Please open this page via HTTP/HTTPS.';
                        NotificationManager.error(errorMsg);
                        console.error('🔴 Invalid redirect URI:', this.redirectUri);
                        return;
                    }

                    LoadingStateManager.prototype.show('auth', 'Generating secure authentication parameters...');

                    // Generate PKCE parameters
                    this.codeVerifier = Utils.generateRandomString();
                    this.codeChallenge = await Utils.sha256(this.codeVerifier);
                    this.state = Utils.generateRandomString(16);

                    // Store parameters securely
                    this.storePKCEParameters(this.codeVerifier, this.state);

                    // Build authorization URL with PKCE
                    const authUrl = `https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize?` +
                        `client_id=${this.clientId}&` +
                        `response_type=code&` +
                        `redirect_uri=${encodeURIComponent(this.redirectUri)}&` +
                        `scope=${encodeURIComponent('Files.ReadWrite User.Read')}&` +
                        `state=${this.state}&` +
                        `code_challenge=${this.codeChallenge}&` +
                        `code_challenge_method=S256&` +
                        `response_mode=query`;

                    console.log('🔐 PKCE Auth URL generated');

                    LoadingStateManager.prototype.hide('auth');
                    LoadingStateManager.prototype.show('auth', 'Redirecting to secure Microsoft login...', { timeout: 3000 });

                    setTimeout(() => {
                        window.location.href = authUrl;
                    }, 1000);

                } catch (error) {
                    LoadingStateManager.prototype.hide('auth');
                    ErrorManager.handleError(error, 'authenticate', 'Authentication setup failed. Please try again.');
                }
            }

            storePKCEParameters(codeVerifier, state) {
                sessionStorage.setItem('mypocket_code_verifier', codeVerifier);
                sessionStorage.setItem('mypocket_state', state);
                console.log('🔐 PKCE parameters stored securely');
            }

            retrievePKCEParameters() {
                const codeVerifier = sessionStorage.getItem('mypocket_code_verifier');
                const state = sessionStorage.getItem('mypocket_state');
                return { codeVerifier, state };
            }

            clearPKCEParameters() {
                sessionStorage.removeItem('mypocket_code_verifier');
                sessionStorage.removeItem('mypocket_state');
                console.log('🗑️ PKCE parameters cleared');
            }

            async checkAuthFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const state = urlParams.get('state');
                const error = urlParams.get('error');
                const errorDescription = urlParams.get('error_description');

                if (error) {
                    const errorMsg = `Authentication error: ${error} - ${errorDescription || 'Unknown error'}`;
                    NotificationManager.error(errorMsg);
                    this.clearPKCEParameters();
                    window.history.replaceState({}, document.title, window.location.pathname);
                    return;
                }

                if (code && state) {
                    try {
                        LoadingStateManager.prototype.show('token', 'Exchanging authorization code for tokens...');

                        const { codeVerifier, state: storedState } = this.retrievePKCEParameters();

                        if (!storedState || state !== storedState) {
                            throw new Error('State parameter mismatch. Possible CSRF attack.');
                        }

                        if (!codeVerifier) {
                            throw new Error('Code verifier not found. Please try authenticating again.');
                        }

                        const tokenResponse = await this.exchangeCodeForTokens(code, codeVerifier);

                        if (tokenResponse.access_token) {
                            this.accessToken = tokenResponse.access_token;
                            this.saveToken(tokenResponse.access_token);

                            if (tokenResponse.refresh_token) {
                                this.saveRefreshToken(tokenResponse.refresh_token);
                            }

                            this.clearPKCEParameters();
                            window.history.replaceState({}, document.title, window.location.pathname);

                            LoadingStateManager.prototype.hide('token');
                            NotificationManager.success('Secure authentication successful!');
                            
                            return true;
                        } else {
                            throw new Error('No access token received from authorization server');
                        }

                    } catch (error) {
                        LoadingStateManager.prototype.hide('token');
                        ErrorManager.handleError(error, 'token exchange', `Token exchange failed: ${error.message}`);
                        this.clearPKCEParameters();
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }
                }
                return false;
            }

            async exchangeCodeForTokens(authorizationCode, codeVerifier) {
                const tokenEndpoint = 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                const tokenRequest = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        client_id: this.clientId,
                        scope: 'Files.ReadWrite User.Read',
                        code: authorizationCode,
                        redirect_uri: this.redirectUri,
                        grant_type: 'authorization_code',
                        code_verifier: codeVerifier
                    })
                };

                console.log('🔐 Exchanging authorization code for tokens...');

                const response = await fetch(tokenEndpoint, tokenRequest);

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Token exchange failed: ${errorData.error} - ${errorData.error_description}`);
                }

                const tokenData = await response.json();
                console.log('✅ Token exchange successful');

                return tokenData;
            }

            saveToken(token) {
                localStorage.setItem(CONFIG.STORAGE.KEYS.ACCESS_TOKEN, token);
                localStorage.setItem(CONFIG.STORAGE.KEYS.TOKEN_TIMESTAMP, Date.now().toString());
            }

            saveRefreshToken(refreshToken) {
                localStorage.setItem(CONFIG.STORAGE.KEYS.REFRESH_TOKEN, refreshToken);
            }

            getRefreshToken() {
                return localStorage.getItem(CONFIG.STORAGE.KEYS.REFRESH_TOKEN);
            }

            loadStoredToken() {
                this.accessToken = localStorage.getItem(CONFIG.STORAGE.KEYS.ACCESS_TOKEN);
                return !!this.accessToken;
            }

            clearTokens() {
                Object.values(CONFIG.STORAGE.KEYS).forEach(key => {
                    localStorage.removeItem(key);
                });
                this.accessToken = null;
            }

            async ensureValidToken() {
                if (!this.accessToken) return false;

                const tokenTimestamp = localStorage.getItem(CONFIG.STORAGE.KEYS.TOKEN_TIMESTAMP);
                if (tokenTimestamp) {
                    const tokenAge = Date.now() - parseInt(tokenTimestamp);
                    const oneHour = 60 * 60 * 1000;

                    if (tokenAge > oneHour) {
                        console.log('🔄 Token expired, attempting refresh...');
                        const refreshSuccess = await this.refreshAccessToken();
                        if (!refreshSuccess) {
                            console.log('❌ Token refresh failed, need to re-authenticate');
                            return false;
                        }
                    }
                }

                return true;
            }

            async refreshAccessToken() {
                const refreshToken = this.getRefreshToken();
                if (!refreshToken) {
                    console.log('No refresh token available');
                    return false;
                }

                try {
                    const tokenEndpoint = 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                    const refreshRequest = {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: this.clientId,
                            scope: 'Files.ReadWrite User.Read',
                            refresh_token: refreshToken,
                            grant_type: 'refresh_token'
                        })
                    };

                    const response = await fetch(tokenEndpoint, refreshRequest);

                    if (!response.ok) {
                        console.log('Refresh token request failed');
                        return false;
                    }

                    const tokenData = await response.json();

                    if (tokenData.access_token) {
                        this.accessToken = tokenData.access_token;
                        this.saveToken(tokenData.access_token);

                        if (tokenData.refresh_token) {
                            this.saveRefreshToken(tokenData.refresh_token);
                        }

                        console.log('✅ Token refreshed successfully');
                        return true;
                    }

                    return false;

                } catch (error) {
                    console.error('Token refresh error:', error);
                    return false;
                }
            }
        }

        // Image Cache Manager
        class ImageCacheManager {
            constructor() {
                this.imageCache = new Map();
                this.cacheKey = CONFIG.STORAGE.KEYS.IMAGE_CACHE;
                this.cacheExpiryDays = CONFIG.CACHE.EXPIRY_DAYS;
                this.maxImageSizeKB = CONFIG.CACHE.MAX_IMAGE_SIZE_KB;
                this.cacheSaveTimeout = null;
                this.failedImages = new Set();
                this.loadImageCache();
            }

            loadImageCache() {
                try {
                    const cachedData = localStorage.getItem(this.cacheKey);
                    if (cachedData) {
                        const cache = JSON.parse(cachedData);
                        const now = Date.now();
                        const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                        for (const [key, entry] of Object.entries(cache)) {
                            if (now - entry.timestamp < expiryTime) {
                                this.imageCache.set(key, entry);
                            }
                        }

                        console.log(`📦 Loaded ${this.imageCache.size} cached images`);
                    }
                } catch (error) {
                    console.error('Error loading image cache:', error);
                    this.imageCache.clear();
                }
            }

            saveImageCache() {
                try {
                    const cacheObject = {};
                    for (const [key, value] of this.imageCache.entries()) {
                        cacheObject[key] = value;
                    }
                    localStorage.setItem(this.cacheKey, JSON.stringify(cacheObject));
                    console.log(`💾 Saved ${this.imageCache.size} images to cache`);
                } catch (error) {
                    console.error('Error saving image cache:', error);
                }
            }

            getCacheKey(article) {
                return `${Utils.getDomain(article.url)}_${article.url.substring(article.url.length - 20)}_${article.title.substring(0, 30)}`.replace(/[^a-zA-Z0-9]/g, '_');
            }

            getCachedImage(article) {
                const key = this.getCacheKey(article);
                const cached = this.imageCache.get(key);

                if (cached) {
                    const now = Date.now();
                    const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                    if (now - cached.timestamp < expiryTime) {
                        console.log(`✅ Using cached image for: ${article.title.substring(0, 30)}...`);
                        return cached.imageUrl;
                    } else {
                        this.imageCache.delete(key);
                        console.log(`⏰ Cache expired for: ${article.title.substring(0, 30)}...`);
                    }
                }

                return null;
            }

            setCachedImage(article, imageUrl) {
                const key = this.getCacheKey(article);
                this.imageCache.set(key, {
                    imageUrl: imageUrl,
                    timestamp: Date.now(),
                    domain: Utils.getDomain(article.url),
                    title: article.title.substring(0, 50)
                });

                clearTimeout(this.cacheSaveTimeout);
                this.cacheSaveTimeout = setTimeout(() => this.saveImageCache(), 1000);

                console.log(`💾 Cached image for: ${article.title.substring(0, 30)}...`);
            }

            clearImageCache() {
                if (confirm('Clear all cached images?\n\nThis will:\n- Clear local cache\n- Remove stored images from articles\n- Force re-downloading images next time')) {
                    this.imageCache.clear();
                    localStorage.removeItem(this.cacheKey);
                    NotificationManager.success('Image cache cleared. Images will be re-downloaded.');
                    console.log('🗑️ All image data cleared');
                    return true;
                }
                return false;
            }

            getCacheStats() {
                const timestamps = Array.from(this.imageCache.values()).map(entry => entry.timestamp);
                return {
                    total: this.imageCache.size,
                    memoryUsage: JSON.stringify(Object.fromEntries(this.imageCache)).length,
                    oldestEntry: timestamps.length > 0 ? Math.min(...timestamps) : null,
                    newestEntry: timestamps.length > 0 ? Math.max(...timestamps) : null
                };
            }

            async convertImageToBase64(imageUrl) {
                try {
                    console.log(`📸 Converting image to base64: ${imageUrl.substring(0, 50)}...`);

                    const img = new Image();
                    img.crossOrigin = 'anonymous';

                    return new Promise((resolve, reject) => {
                        img.onload = () => {
                            try {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');

                                const maxWidth = 400;
                                const maxHeight = 250;

                                let { width, height } = img;

                                if (width > maxWidth) {
                                    height = (height * maxWidth) / width;
                                    width = maxWidth;
                                }
                                if (height > maxHeight) {
                                    width = (width * maxHeight) / height;
                                    height = maxHeight;
                                }

                                canvas.width = width;
                                canvas.height = height;

                                ctx.drawImage(img, 0, 0, width, height);
                                const base64 = canvas.toDataURL('image/jpeg', 0.8);

                                const sizeKB = Math.round(base64.length * 0.75 / 1024);

                                if (sizeKB > this.maxImageSizeKB) {
                                    console.log(`⚠️ Image too large (${sizeKB}KB), using URL only`);
                                    resolve({ url: imageUrl, size: sizeKB, stored: false });
                                } else {
                                    console.log(`✅ Image converted (${sizeKB}KB): ${imageUrl.substring(0, 30)}...`);
                                    resolve({ base64: base64, url: imageUrl, size: sizeKB, stored: true });
                                }
                            } catch (error) {
                                console.log(`❌ Canvas conversion failed: ${error.message}`);
                                resolve({ url: imageUrl, stored: false });
                            }
                        };

                        img.onerror = () => {
                            console.log(`❌ Image load failed: ${imageUrl}`);
                            resolve({ url: imageUrl, stored: false });
                        };

                        img.src = imageUrl;
                    });
                } catch (error) {
                    console.error('Image conversion error:', error);
                    return { url: imageUrl, stored: false };
                }
            }
        }

        // Enhanced MyPocket Web Reader (Main Class)
        class MyPocketWebReader {
            constructor() {
                // Initialize managers
                this.authManager = new AuthenticationManager();
                this.imageCacheManager = new ImageCacheManager();
                this.loadingManager = new LoadingStateManager();
                
                // Article data
                this.articles = [];
                this.currentDisplayedArticles = [];
                this.currentArticle = null;
                
                // UI state
                this.searchQuery = '';
                this.isSearchVisible = false;
                
                // Debounced search
                this.debouncedSearch = Utils.debounce(
                    (query) => this.performSearch(query), 
                    CONFIG.UI.SEARCH_DEBOUNCE_MS
                );

                this.init();
            }

            async init() {
                try {
                    this.setupEventListeners();
                    this.setupAccessibility();
                    this.loadThemePreference();
                    
                    // Check for auth callback first
                    const authSuccess = await this.authManager.checkAuthFromURL();
                    
                    if (!authSuccess) {
                        // Try to load stored token
                        if (this.authManager.loadStoredToken()) {
                            this.updateConnectionStatus(true);
                            await this.loadArticles();
                        }
                    } else {
                        this.updateConnectionStatus(true);
                        await this.loadArticles();
                    }
                } catch (error) {
                    ErrorManager.handleError(error, 'initialization', 'Failed to initialize application');
                }
            }

            setupEventListeners() {
                // Button events
                document.getElementById('connectBtn').addEventListener('click', () => this.handleConnect());
                document.getElementById('refreshBtn').addEventListener('click', () => this.loadArticles());
                document.getElementById('searchToggleBtn').addEventListener('click', () => this.toggleSearch());
                document.getElementById('clearCacheBtn').addEventListener('click', () => this.clearImageCache());
                document.getElementById('syncBtn').addEventListener('click', () => this.forceSyncImages());
                document.getElementById('retryFailedBtn').addEventListener('click', () => this.retryFailedImages());
                document.getElementById('helpBtn').addEventListener('click', () => this.showImageHelp());
                document.getElementById('debugBtn').addEventListener('click', () => this.showDebugInfo());
                document.getElementById('testBtn').addEventListener('click', () => this.toggleTestMode());
                document.getElementById('darkModeBtn').addEventListener('click', () => this.toggleDarkMode());

                // Search events
                document.getElementById('searchInput').addEventListener('input', (e) => {
                    this.debouncedSearch(e.target.value);
                });
                document.querySelector('.search-close-btn').addEventListener('click', () => this.toggleSearch(false));

                // Reader events
                document.getElementById('closeReader').addEventListener('click', () => this.closeReader());
                document.getElementById('openOriginal').addEventListener('click', () => this.openOriginal());

                // Keyboard navigation
                this.setupKeyboardNavigation();

                // Click outside to close search
                document.addEventListener('click', (e) => {
                    const searchContainer = document.getElementById('searchContainer');
                    const searchToggleBtn = document.getElementById('searchToggleBtn');

                    if (this.isSearchVisible &&
                        !searchContainer.contains(e.target) &&
                        !searchToggleBtn.contains(e.target)) {
                        this.toggleSearch(false);
                    }
                });
            }

            setupKeyboardNavigation() {
                document.addEventListener('keydown', (e) => {
                    // Don't interfere if user is typing in an input
                    if (this.isInputFocused()) return;

                    switch (e.key) {
                        case '/':
                        case 'k':
                            if (e.ctrlKey || e.metaKey || e.key === '/') {
                                e.preventDefault();
                                this.toggleSearch(true);
                            }
                            break;
                        case 'Escape':
                            if (this.isSearchVisible) {
                                this.toggleSearch(false);
                            } else {
                                this.closeReader();
                            }
                            break;
                        case 'j':
                            e.preventDefault();
                            this.navigateArticles('next');
                            break;
                        case 'k':
                            e.preventDefault();
                            this.navigateArticles('prev');
                            break;
                        case 'Enter':
                            if (document.activeElement?.closest('.article-card')) {
                                e.preventDefault();
                                document.activeElement.click();
                            }
                            break;
                    }
                });
            }

            setupAccessibility() {
                // Add proper roles and labels
                document.querySelectorAll('.article-card').forEach((card, index) => {
                    card.setAttribute('role', 'article');
                    card.setAttribute('tabindex', '0');
                    card.setAttribute('aria-label', `Article ${index + 1}`);
                });

                // Enhanced focus management
                document.addEventListener('focusin', (e) => {
                    if (e.target.closest('.article-card')) {
                        e.target.closest('.article-card').classList.add('keyboard-focused');
                    }
                });

                document.addEventListener('focusout', (e) => {
                    if (e.target.closest('.article-card')) {
                        e.target.closest('.article-card').classList.remove('keyboard-focused');
                    }
                });
            }

            navigateArticles(direction) {
                const articles = document.querySelectorAll('.article-card');
                const currentIndex = Array.from(articles).findIndex(card => card === document.activeElement);
                
                let nextIndex;
                if (direction === 'next') {
                    nextIndex = currentIndex < articles.length - 1 ? currentIndex + 1 : 0;
                } else {
                    nextIndex = currentIndex > 0 ? currentIndex - 1 : articles.length - 1;
                }

                if (articles[nextIndex]) {
                    articles[nextIndex].focus();
                    articles[nextIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            isInputFocused() {
                const activeElement = document.activeElement;
                return activeElement && (
                    activeElement.tagName === 'INPUT' || 
                    activeElement.tagName === 'TEXTAREA' ||
                    activeElement.isContentEditable
                );
            }

            async handleConnect() {
                try {
                    if (!this.authManager.accessToken) {
                        await this.authManager.authenticate();
                    } else {
                        // Already connected, offer to disconnect
                        if (confirm('Already connected. Disconnect and clear stored data?')) {
                            this.authManager.clearTokens();
                            this.imageCacheManager.clearImageCache();
                            this.updateConnectionStatus(false);
                            this.articles = [];
                            this.currentDisplayedArticles = [];
                            this.displayEmptyState();
                            NotificationManager.success('Disconnected successfully');
                        }
                    }
                } catch (error) {
                    ErrorManager.handleError(error, 'handleConnect', 'Connection failed');
                }
            }

            updateConnectionStatus(connected) {
                const connectBtn = document.getElementById('connectBtn');
                const connectIcon = document.getElementById('connectIcon');
                const connectText = document.getElementById('connectText');
                const refreshBtn = document.getElementById('refreshBtn');
                const syncBtn = document.getElementById('syncBtn');
                const retryFailedBtn = document.getElementById('retryFailedBtn');

                if (connected) {
                    connectIcon.textContent = '✅';
                    connectText.textContent = 'Connected (PKCE)';
                    connectBtn.style.background = 'rgba(39, 174, 96, 0.8)';
                    refreshBtn.style.display = 'inline-flex';
                    syncBtn.style.display = 'inline-flex';
                    retryFailedBtn.style.display = 'inline-flex';
                } else {
                    connectIcon.textContent = '🔐';
                    connectText.textContent = 'Secure Connect';
                    connectBtn.style.background = 'rgba(255,255,255,0.2)';
                    refreshBtn.style.display = 'none';
                    syncBtn.style.display = 'none';
                    retryFailedBtn.style.display = 'none';
                }
            }

            toggleSearch(forceState = null) {
                const searchContainer = document.getElementById('searchContainer');
                const searchInput = document.getElementById('searchInput');
                const searchToggleBtn = document.getElementById('searchToggleBtn');

                const shouldShow = forceState !== null ? forceState : !this.isSearchVisible;

                if (shouldShow && !this.isSearchVisible) {
                    // Show search
                    this.isSearchVisible = true;
                    searchContainer.style.display = 'block';
                    setTimeout(() => {
                        searchContainer.classList.add('visible');
                        searchInput.focus();
                    }, 10);

                    searchToggleBtn.innerHTML = '<span>🔍</span> Close Search';
                    searchToggleBtn.style.background = 'var(--primary-color)';
                    searchToggleBtn.style.color = 'white';

                    this.updateStatus('🔍 Search mode active - Type to search or press Escape to close', 'success');
                } else if (!shouldShow && this.isSearchVisible) {
                    // Hide search
                    this.isSearchVisible = false;
                    searchContainer.classList.remove('visible');
                    setTimeout(() => {
                        if (!this.isSearchVisible) {
                            searchContainer.style.display = 'none';
                        }
                    }, CONFIG.UI.ANIMATION_DURATION);

                    searchToggleBtn.innerHTML = '<span>🔍</span> Search';
                    searchToggleBtn.style.background = '';
                    searchToggleBtn.style.color = '';

                    // Clear search if closing
                    if (searchInput.value) {
                        searchInput.value = '';
                        this.performSearch('');
                    }

                    searchInput.blur();
                }
            }

            performSearch(query) {
                this.searchQuery = query.trim();
                console.log(`🔍 Searching for: "${this.searchQuery}"`);

                if (!this.searchQuery) {
                    this.currentDisplayedArticles = this.articles;
                    this.displayArticles(this.articles);
                    if (this.articles.length > 0) {
                        this.updateStatus(`Showing all ${this.articles.length} articles`, 'success');
                    }
                    return;
                }

                const searchTerm = this.searchQuery.toLowerCase();
                const filtered = this.articles.filter(article => {
                    const titleMatch = article.title && article.title.toLowerCase().includes(searchTerm);
                    const excerptMatch = article.excerpt && article.excerpt.toLowerCase().includes(searchTerm);
                    const contentFields = ['content', 'textContent', 'html', 'fullContent', 'body', 'readableContent'];
                    const contentMatch = contentFields.some(field =>
                        article[field] && typeof article[field] === 'string' &&
                        article[field].toLowerCase().includes(searchTerm)
                    );
                    const authorMatch = article.author && article.author.toLowerCase().includes(searchTerm);
                    const domainMatch = Utils.getDomain(article.url).toLowerCase().includes(searchTerm);
                    const urlMatch = article.url && article.url.toLowerCase().includes(searchTerm);
                    const tagsMatch = article.tags && Array.isArray(article.tags) &&
                        article.tags.some(tag => tag.toLowerCase().includes(searchTerm));

                    return titleMatch || excerptMatch || contentMatch || authorMatch || domainMatch || urlMatch || tagsMatch;
                });

                console.log(`🎯 Search results: ${filtered.length}/${this.articles.length} articles`);

                this.currentDisplayedArticles = filtered;
                this.displayArticles(filtered);

                if (filtered.length === 0) {
                    this.updateStatus(`No articles found matching "${query}". Try different keywords.`, 'error');
                } else if (filtered.length === 1) {
                    this.updateStatus(`Found 1 article matching "${query}"`, 'success');
                } else {
                    this.updateStatus(`Found ${filtered.length} articles matching "${query}"`, 'success');
                }
            }

            async loadArticles() {
                try {
                    const hasValidToken = await this.authManager.ensureValidToken();
                    if (!hasValidToken) {
                        this.updateConnectionStatus(false);
                        this.updateStatus('Authentication expired. Please reconnect.', 'error');
                        return;
                    }

                    this.loadingManager.show('articles', 'Loading articles from OneDrive...');
                    this.updateStatus('Loading articles... ⏳', 'loading');

                    const listResponse = await Utils.withRetry(async () => {
                        const response = await fetch(`${CONFIG.API.GRAPH_API_BASE}/me/drive/root:/MyPocket:/children`, {
                            headers: {
                                'Authorization': `Bearer ${this.authManager.accessToken}`,
                                'Content-Type': 'application/json'
                            }
                        });

                        if (!response.ok) {
                            if (response.status === 401) {
                                const refreshSuccess = await this.authManager.refreshAccessToken();
                                if (refreshSuccess) {
                                    throw new Error('RETRY_WITH_NEW_TOKEN');
                                } else {
                                    this.authManager.clearTokens();
                                    this.updateConnectionStatus(false);
                                    throw new Error('Session expired. Please reconnect.');
                                }
                            }
                            throw new Error(`Failed to list files: ${response.status}`);
                        }

                        return response;
                    }, 3);

                    const fileList = await listResponse.json();
                    const backupFiles = fileList.value.filter(file =>
                        file.name.startsWith('mypocket-backup-') && file.name.endsWith('.json')
                    );

                    if (backupFiles.length === 0) {
                        this.loadingManager.hide('articles');
                        this.updateStatus('No backup files found. Save some articles with the browser extension first.', 'error');
                        this.displayEmptyState();
                        return;
                    }

                    const latestFile = backupFiles.sort((a, b) =>
                        new Date(b.lastModifiedDateTime) - new Date(a.lastModifiedDateTime)
                    )[0];

                    this.loadingManager.updateProgress('articles', 50);

                    const downloadResponse = await fetch(`${CONFIG.API.GRAPH_API_BASE}/me/drive/items/${latestFile.id}/content`, {
                        headers: {
                            'Authorization': `Bearer ${this.authManager.accessToken}`
                        }
                    });

                    if (!downloadResponse.ok) {
                        throw new Error(`Failed to download backup: ${downloadResponse.status}`);
                    }

                    const backupContent = await downloadResponse.text();
                    const backup = JSON.parse(backupContent);

                    this.articles = backup.articles || [];
                    this.currentDisplayedArticles = this.articles;
                    
                    this.loadingManager.updateProgress('articles', 100);
                    this.loadingManager.hide('articles');

                    this.displayArticles(this.articles);

                    const cacheStats = this.imageCacheManager.getCacheStats();
                    const storedImages = this.articles.filter(a => a.cachedImage).length;
                    this.updateStatus(`✅ Loaded ${this.articles.length} articles from ${latestFile.name} (${storedImages} with stored images, ${cacheStats.total} locally cached)`, 'success');

                } catch (error) {
                    this.loadingManager.hide('articles');
                    ErrorManager.handleError(error, 'loadArticles', `Error loading articles: ${error.message}`);
                }
            }

            displayArticles(articles) {
                const container = document.getElementById('articlesContainer');

                if (articles.length === 0) {
                    this.displayEmptyState();
                    return;
                }

                this.currentDisplayedArticles = articles;

                const isMobile = window.innerWidth <= 768;
                let imagesFromBackup = 0;
                let imagesFromCache = 0;
                let imagesNeedLoading = 0;

                console.log('🎯 DISPLAYING ARTICLES - Image Source Priority Check:');

                const articlesHTML = articles.map((article, displayIndex) => {
                    let imageHTML = '';
                    let cacheStatus = 'loading';
                    let statusText = '🔄 Loading';
                    let imageSource = 'none';

                    // Priority 1: Synced base64 images
                    if (article.cachedImage && article.cachedImage.base64) {
                        imageHTML = this.createImageHTML(article.cachedImage.base64, true);
                        cacheStatus = 'synced';
                        statusText = '🌐 Synced';
                        imageSource = 'synced_base64';
                        imagesFromBackup++;
                    }
                    // Priority 2: Synced URLs
                    else if (article.cachedImage && article.cachedImage.url && !article.cachedImage.base64) {
                        imageHTML = this.createImageHTML(article.cachedImage.url, true);
                        cacheStatus = 'synced';
                        statusText = '🔗 Synced URL';
                        imageSource = 'synced_url';
                        imagesFromBackup++;
                    }
                    // Priority 3: Local cache
                    else if (this.imageCacheManager.getCachedImage(article)) {
                        imageHTML = this.createImageHTML(this.imageCacheManager.getCachedImage(article), true);
                        cacheStatus = 'cached';
                        statusText = '💾 Local Cache';
                        imageSource = 'local_cache';
                        imagesFromCache++;
                    }
                    // Priority 4: Article metadata
                    else if (this.getBestArticleImage(article)) {
                        const savedImage = this.getBestArticleImage(article);
                        imageHTML = this.createImageHTML(savedImage, false);
                        cacheStatus = 'metadata';
                        statusText = '📄 Metadata';
                        imageSource = 'metadata';
                        setTimeout(() => this.setArticleImageAndCache(article, displayIndex, savedImage, 'saved'), 100);
                    }
                    // Priority 5: Need to extract
                    else {
                        imageHTML = this.createPlaceholderHTML();
                        cacheStatus = 'loading';
                        statusText = isMobile ? '📱 Loading...' : '🔄 Loading';
                        imageSource = 'needs_extraction';
                        imagesNeedLoading++;
                    }

                    return `
                    <article class="article-card" data-index="${displayIndex}" data-image-source="${imageSource}" 
                             tabindex="0" role="article" aria-label="Article: ${Utils.escapeHtml(article.title)}">
                        <div class="article-image" id="image-${displayIndex}">
                            ${imageHTML}
                            <div class="cache-indicator ${cacheStatus}">
                                ${statusText}
                            </div>
                        </div>
                        <div class="article-content" onclick="webReader.openReaderByDisplayIndex(${displayIndex})">
                            <h2 class="article-title">${Utils.escapeHtml(article.title)}</h2>
                            <p class="article-excerpt">${Utils.escapeHtml(article.excerpt || '')}</p>
                            <div class="article-meta">
                                <span class="article-domain">🌐 ${Utils.getDomain(article.url)}</span>
                                <span class="article-date">📅 ${Utils.formatDate(article.dateAdded)}</span>
                            </div>
                            <div class="article-stats">
                                <span>⏱️ ${article.readTime || 1} min read</span>
                                <span>📝 ${article.wordCount || 0} words</span>
                            </div>
                        </div>
                        <div class="article-actions">
                            <button class="action-btn read-btn" onclick="event.stopPropagation(); webReader.openReaderByDisplayIndex(${displayIndex})" 
                                    title="Read article" aria-label="Read article">
                                📖
                            </button>
                            <button class="action-btn refresh-image-btn" onclick="event.stopPropagation(); webReader.refreshSingleImage(${displayIndex})" 
                                    title="Refresh this image" aria-label="Refresh image">
                                🖼️
                            </button>
                            <button class="action-btn export-btn" onclick="event.stopPropagation(); webReader.exportArticleByDisplayIndex(${displayIndex})" 
                                    title="Export article" aria-label="Export article">
                                📤
                            </button>
                            <button class="action-btn delete-btn" onclick="event.stopPropagation(); webReader.deleteArticleByDisplayIndex(${displayIndex})" 
                                    title="Delete article" aria-label="Delete article">
                                🗑️
                            </button>
                        </div>
                    </article>
                `}).join('');

                container.innerHTML = `<div class="articles-grid" role="main" aria-label="Articles list">${articlesHTML}</div>`;

                // Re-setup accessibility for new elements
                this.setupAccessibility();

                const totalReady = imagesFromBackup + imagesFromCache;

                console.log(`📊 IMAGE SUMMARY: ${imagesFromBackup} synced, ${imagesFromCache} cached, ${imagesNeedLoading} need loading`);

                if (imagesNeedLoading === 0) {
                    const message = isMobile ?
                        `📱 ALL images ready! ${totalReady}/${articles.length} synced perfectly ✨` :
                        `✅ ALL images ready! ${imagesFromBackup} synced, ${imagesFromCache} cached ✨`;
                    this.updateStatus(message, 'success');
                } else {
                    const message = isMobile ?
                        `📱 ${totalReady} ready instantly, extracting ${imagesNeedLoading} more...` :
                        `⚡ ${totalReady} ready instantly, extracting ${imagesNeedLoading} more...`;
                    this.updateStatus(message, 'loading');

                    if (isMobile) {
                        setTimeout(() => this.loadMissingImages(articles), 500);
                    } else {
                        this.loadMissingImages(articles);
                    }
                }
            }

            createImageHTML(imageUrl, fromCache = false) {
                return `
                    <img src="${imageUrl}" 
                         alt="Article image" 
                         style="
                            opacity: 0; 
                            transition: opacity 0.8s ease;
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: inherit;
                         "
                         onload="
                            this.style.opacity='1';
                            console.log('✅ Image loaded ${fromCache ? 'from cache' : 'successfully'}');
                         " 
                         onerror="
                            console.log('⚠️ Image failed, tracking for retry');
                            const cardElement = this.closest('.article-card');
                            if (cardElement) {
                                const index = parseInt(cardElement.dataset.index);
                                if (!isNaN(index)) {
                                    webReader.imageCacheManager.failedImages.add(index);
                                    const indicator = this.parentElement.querySelector('.cache-indicator');
                                    if (indicator) {
                                        indicator.textContent = '❌ Failed';
                                        indicator.className = 'cache-indicator error';
                                    }
                                }
                            }
                            this.src='https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                         ">
                `;
            }

            createPlaceholderHTML() {
                return `
                    <div style="
                        width: 100%; 
                        height: 100%; 
                        background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                                   linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                                   linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                                   linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
                        background-size: 20px 20px;
                        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: #999;
                        animation: shimmer 1.5s ease-in-out infinite;
                    ">
                        <div style="text-align: center;">
                            <div style="font-size: 1.2em; margin-bottom: 5px;">🖼️</div>
                            <div style="font-size: 0.7em;">Loading image...</div>
                        </div>
                    </div>
                `;
            }

            async loadMissingImages(articles) {
                console.log('🎨 Loading missing images...');

                const articlesNeedingImages = articles.filter((article, index) => {
                    const hasStoredImage = article.cachedImage && article.cachedImage.base64;
                    const hasCachedImage = this.imageCacheManager.getCachedImage(article);
                    return !hasStoredImage && !hasCachedImage;
                });

                if (articlesNeedingImages.length === 0) {
                    this.updateStatus(`✅ All images loaded!`, 'success');
                    return;
                }

                const isMobile = window.innerWidth <= 768;
                let successCount = 0;
                const totalNew = articlesNeedingImages.length;

                console.log(`🔄 Loading ${totalNew} images${isMobile ? ' (mobile optimized)' : ''}`);

                const batchSize = isMobile ? 2 : 5;
                const delayBetweenImages = isMobile ? 800 : 300;

                for (let i = 0; i < articlesNeedingImages.length; i += batchSize) {
                    const batch = articlesNeedingImages.slice(i, i + batchSize);

                    await Promise.all(batch.map(async (article) => {
                        const displayIndex = this.currentDisplayedArticles.findIndex(a => a === article);

                        try {
                            const success = await this.extractAndCacheRealImage(article, displayIndex);
                            if (success) successCount++;
                        } catch (error) {
                            console.error(`Failed to extract image for article ${displayIndex}:`, error);
                            const fallbackImage = this.getCategoryBasedImage(article, displayIndex);
                            this.setArticleImageAndCache(article, displayIndex, fallbackImage, 'fallback');
                            successCount++;
                        }
                    }));

                    const progress = Math.round(((i + batchSize) / totalNew) * 100);
                    if (isMobile) {
                        this.updateStatus(`📱 Loading images... ${Math.min(i + batchSize, totalNew)}/${totalNew}`, 'loading');
                    } else {
                        this.updateStatus(`🔍 Loading new images... ${Math.min(i + batchSize, totalNew)}/${totalNew} (${progress}%)`, 'loading');
                    }

                    if (i + batchSize < articlesNeedingImages.length) {
                        await new Promise(resolve => setTimeout(resolve, delayBetweenImages));
                    }
                }

                const totalCached = this.imageCacheManager.getCacheStats().total;

                if (isMobile) {
                    this.updateStatus(`📱 ${successCount} images loaded! Same as desktop 🎉`, 'success');
                } else {
                    this.updateStatus(`✅ Loaded ${successCount}/${totalNew} new images! (${totalCached} total cached)`, 'success');
                }

                console.log(`🎨 Image loading complete: ${successCount}/${totalNew} images processed`);
            }

            async extractAndCacheRealImage(article, index) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return false;

                console.log(`🔍 Extracting image for: ${Utils.getDomain(article.url)}`);

                // Strategy 1: Try saved article images first
                const savedImage = this.getBestArticleImage(article);
                if (savedImage) {
                    console.log(`✅ Using saved image: ${article.title.substring(0, 30)}...`);
                    this.setArticleImageAndCache(article, index, savedImage, 'saved');
                    return true;
                }

                // Strategy 2: Extract from website
                try {
                    const extractedImage = await this.fetchRealImageFromWebsite(article.url);
                    if (extractedImage) {
                        console.log(`✅ Extracted real image: ${article.title.substring(0, 30)}...`);
                        this.setArticleImageAndCache(article, index, extractedImage, 'extracted');
                        return true;
                    }
                } catch (error) {
                    console.log(`⚠️ Could not extract from website: ${error.message}`);
                }

                // Strategy 3: Use intelligent fallback
                console.log(`🎨 Using intelligent fallback: ${article.title.substring(0, 30)}...`);
                const fallbackImage = this.getCategoryBasedImage(article, index);
                this.setArticleImageAndCache(article, index, fallbackImage, 'fallback');
                return true;
            }

            async setArticleImageAndCache(article, index, imageUrl, source) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return;

                // Update DOM immediately
                imageElement.innerHTML = this.createImageHTML(imageUrl, false);

                // Update cache indicator
                const cacheIndicator = imageElement.querySelector('.cache-indicator');
                if (cacheIndicator) {
                    if (source === 'extracted') {
                        cacheIndicator.textContent = '🌐 Fresh';
                        cacheIndicator.className = 'cache-indicator fresh';
                    } else if (source === 'refreshed') {
                        cacheIndicator.textContent = '🔄 Refreshed';
                        cacheIndicator.className = 'cache-indicator fresh';
                    } else {
                        cacheIndicator.textContent = '💾 Cached';
                        cacheIndicator.className = 'cache-indicator cached';
                    }
                }

                // Store in local cache
                this.imageCacheManager.setCachedImage(article, imageUrl);

                // Store base64 data for cross-device sync
                if (source === 'extracted' || source === 'saved' || source === 'fallback' || source === 'refreshed') {
                    try {
                        console.log(`🔄 Converting image for cross-device storage: ${article.title.substring(0, 30)}...`);
                        const imageData = await this.imageCacheManager.convertImageToBase64(imageUrl);

                        if (imageData.stored) {
                            const articleIndex = this.articles.findIndex(a => a.url === article.url);
                            if (articleIndex !== -1) {
                                this.articles[articleIndex].cachedImage = {
                                    base64: imageData.base64,
                                    url: imageData.url,
                                    timestamp: Date.now(),
                                    size: imageData.size,
                                    source: source
                                };

                                console.log(`💾 Stored ${imageData.size}KB image in backup for cross-device sync`);

                                if (cacheIndicator) {
                                    cacheIndicator.textContent = '🌐 Synced';
                                    cacheIndicator.className = 'cache-indicator synced';
                                }

                                // Auto-save to OneDrive
                                if (this.authManager.accessToken) {
                                    console.log('💾 Auto-saving to OneDrive...');
                                    try {
                                        await this.updateOneDriveBackup();
                                        console.log('✅ OneDrive backup updated');
                                    } catch (error) {
                                        console.error('⚠️ Failed to auto-save backup:', error);
                                    }
                                }
                            }
                        } else {
                            console.log(`⚠️ Image too large for cross-device storage: ${imageData.size}KB`);
                        }
                    } catch (error) {
                        console.error('Error storing image for cross-device sync:', error);
                    }
                }
            }

            getBestArticleImage(article) {
                if (article.images && article.images.length > 0) {
                    let bestImage = article.images[0];

                    for (const img of article.images) {
                        if (img.width && img.height) {
                            if (img.width >= 300 && img.height >= 150) {
                                bestImage = img;
                                break;
                            }
                        }
                    }

                    return bestImage.src || bestImage.url || bestImage;
                }

                if (article.featuredImage) return article.featuredImage;
                if (article.image) return article.image;

                if (article.content) {
                    const imgMatch = article.content.match(/<img[^>]+src="([^"]+)"/i);
                    if (imgMatch && imgMatch[1]) return imgMatch[1];
                }

                return null;
            }

            async fetchRealImageFromWebsite(url) {
                try {
                    console.log(`🌐 Fetching webpage to extract image: ${url}`);

                    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                    const response = await fetch(proxyUrl);

                    if (!response.ok) {
                        throw new Error('Failed to fetch webpage');
                    }

                    const data = await response.json();
                    const html = data.contents;

                    if (!html || html.length < 500) {
                        throw new Error('No substantial HTML content received');
                    }

                    const extractedImageUrl = this.parseHTMLForBestImage(html, url);

                    if (extractedImageUrl) {
                        console.log(`🎯 Found image: ${extractedImageUrl}`);
                        return extractedImageUrl;
                    }

                    throw new Error('No suitable image found in webpage');

                } catch (error) {
                    console.log(`❌ Website image extraction failed: ${error.message}`);
                    throw error;
                }
            }

            parseHTMLForBestImage(html, baseUrl) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    // Strategy 1: Open Graph image
                    const ogImage = doc.querySelector('meta[property="og:image"]');
                    if (ogImage) {
                        const imageUrl = Utils.makeAbsoluteUrl(ogImage.getAttribute('content'), baseUrl);
                        if (this.isValidImageUrl(imageUrl)) {
                            console.log(`🎯 Found Open Graph image: ${imageUrl}`);
                            return imageUrl;
                        }
                    }

                    // Strategy 2: Twitter card image
                    const twitterImage = doc.querySelector('meta[name="twitter:image"], meta[property="twitter:image"]');
                    if (twitterImage) {
                        const imageUrl = Utils.makeAbsoluteUrl(twitterImage.getAttribute('content'), baseUrl);
                        if (this.isValidImageUrl(imageUrl)) {
                            console.log(`🎯 Found Twitter card image: ${imageUrl}`);
                            return imageUrl;
                        }
                    }

                    // Strategy 3: Featured image selectors
                    const featuredSelectors = [
                        '.featured-image img', '.hero-image img', '.post-thumbnail img',
                        '.article-image img', '.entry-image img', '.wp-post-image',
                        'article img:first-of-type', '.content img:first-of-type', '.post-content img:first-of-type'
                    ];

                    for (const selector of featuredSelectors) {
                        const img = doc.querySelector(selector);
                        if (img) {
                            const src = img.getAttribute('src') || img.getAttribute('data-src') || img.getAttribute('data-lazy-src');
                            if (src) {
                                const imageUrl = Utils.makeAbsoluteUrl(src, baseUrl);
                                if (this.isValidImageUrl(imageUrl) && !this.isIconOrLogo(src)) {
                                    console.log(`🎯 Found featured image: ${imageUrl}`);
                                    return imageUrl;
                                }
                            }
                        }
                    }

                    // Strategy 4: First substantial image
                    const allImages = Array.from(doc.querySelectorAll('img')).filter(img => {
                        const src = img.getAttribute('src') || img.getAttribute('data-src');
                        const width = img.getAttribute('width') || img.style.width;
                        const height = img.getAttribute('height') || img.style.height;

                        return src &&
                            !this.isIconOrLogo(src) &&
                            !this.isSmallImage(width, height) &&
                            !src.includes('avatar') &&
                            !src.includes('profile');
                    });

                    for (const img of allImages) {
                        const src = img.getAttribute('src') || img.getAttribute('data-src');
                        if (src) {
                            const imageUrl = Utils.makeAbsoluteUrl(src, baseUrl);
                            if (this.isValidImageUrl(imageUrl)) {
                                console.log(`🎯 Found content image: ${imageUrl}`);
                                return imageUrl;
                            }
                        }
                    }

                    console.log(`❌ No suitable image found in HTML`);
                    return null;

                } catch (error) {
                    console.error('HTML parsing error:', error);
                    return null;
                }
            }

            isValidImageUrl(url) {
                if (!url || typeof url !== 'string') return false;

                try {
                    new URL(url);
                } catch {
                    return false;
                }

                const imagePattern = /\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i;
                const imageServices = ['unsplash.com', 'images.unsplash.com', 'picsum.photos', 'via.placeholder.com'];

                return imagePattern.test(url) || imageServices.some(service => url.includes(service));
            }

            isIconOrLogo(src) {
                if (!src) return false;

                const iconPatterns = [
                    'icon', 'logo', 'avatar', 'profile', 'favicon', 'sprite',
                    'button', 'badge', 'social', 'thumb', 'thumbnail',
                    '/icons/', '/images/icons/', 'gravatar', 'user-content'
                ];

                const srcLower = src.toLowerCase();
                return iconPatterns.some(pattern => srcLower.includes(pattern)) ||
                    srcLower.includes('.ico') ||
                    (srcLower.includes('64x64') || srcLower.includes('32x32'));
            }

            isSmallImage(width, height) {
                if (!width && !height) return false;

                const w = parseInt(width) || 0;
                const h = parseInt(height) || 0;

                return (w > 0 && w < 200) || (h > 0 && h < 150);
            }

            getCategoryBasedImage(article, index) {
                const domain = Utils.getDomain(article.url).toLowerCase();
                const title = article.title.toLowerCase();

                // Create consistent seed based on article content
                const articleSeed = article.url + article.title;
                let hash = 0;
                for (let i = 0; i < articleSeed.length; i++) {
                    const char = articleSeed.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                const consistentIndex = Math.abs(hash);

                // Technology/Programming
                if (domain.includes('github') || domain.includes('stackoverflow') || domain.includes('dev.to') ||
                    title.includes('code') || title.includes('programming') || title.includes('javascript') || title.includes('react')) {
                    return `https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }

                // Business/Finance
                if (domain.includes('business') || domain.includes('finance') || domain.includes('linkedin') ||
                    title.includes('business') || title.includes('finance') || title.includes('startup') || title.includes('entrepreneur')) {
                    return `https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }

                // Design/Creative
                if (domain.includes('dribbble') || domain.includes('behance') ||
                    title.includes('design') || title.includes('ui') || title.includes('ux') || title.includes('creative')) {
                    return `https://images.unsplash.com/photo-1561070791-2526d30994b5?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }

                // News/Media
                if (domain.includes('news') || domain.includes('bbc') || domain.includes('cnn') ||
                    title.includes('news') || title.includes('politics') || title.includes('media')) {
                    return `https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }

                // Default beautiful images based on consistent hash
                const defaultImages = [
                    'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1511593358241-7eea1f3c84e5?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1519681393784-d120267933ba?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1470115636492-6d2b56f9146d?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1503023345310-bd7c1de61c7d?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1558618047-3c8c76ca7d13?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1506744038136-46273834b3fb?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1518837695005-2083093ee35b?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                ];

                return defaultImages[consistentIndex % defaultImages.length];
            }

            // Article Operations
            openReaderByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                this.currentArticle = article;
                const overlay = document.getElementById('readerOverlay');

                document.getElementById('readerTitle').textContent = article.title;
                document.getElementById('readerDate').textContent = Utils.formatDate(article.dateAdded);
                document.getElementById('readerDomain').textContent = Utils.getDomain(article.url);
                document.getElementById('readerTime').textContent = `${article.readTime || 1} min read`;

                document.getElementById('readerContent').innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="spinner" style="margin: 0 auto 20px;"></div>
                        <p>Checking for article content...</p>
                    </div>
                `;

                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';

                // Focus management for accessibility
                overlay.focus();

                setTimeout(() => this.loadArticleContent(article), 100);
            }

            async loadArticleContent(article) {
                console.log('🚀 Loading article content...');
                const contentElement = document.getElementById('readerContent');

                let content = this.getArticleContent(article);

                if (!content) {
                    console.log('🌐 No saved content found. Attempting to fetch from original URL...');

                    try {
                        contentElement.innerHTML = `
                            <div style="text-align: center; padding: 40px;">
                                <div class="spinner" style="margin: 0 auto 20px;"></div>
                                <p><strong>🌐 Fetching article content...</strong></p>
                                <p style="font-size: 0.9em; color: var(--text-secondary);">
                                    Loading from ${Utils.getDomain(article.url)}
                                </p>
                            </div>
                        `;

                        const fetchedContent = await this.fetchArticleContent(article.url);

                        if (fetchedContent && fetchedContent.trim()) {
                            content = fetchedContent;
                            console.log('✅ Successfully fetched article content');
                            this.updateStatus('✅ Article content loaded successfully!', 'success');
                        } else {
                            throw new Error('No content extracted from fetched page');
                        }

                    } catch (error) {
                        console.log('❌ Failed to fetch content:', error.message);
                        this.updateStatus('❌ Could not fetch article content. Using fallback.', 'error');
                        content = this.getFallbackContent(article, error.message);
                    }
                } else {
                    console.log('✅ Using saved content');
                    this.updateStatus('✅ Article loaded from saved content', 'success');
                }

                contentElement.innerHTML = content;
            }

            async fetchArticleContent(url) {
                try {
                    console.log(`🌐 Starting fetch for: ${url}`);

                    // Try AllOrigins proxy
                    try {
                        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                        const response = await fetch(proxyUrl);

                        if (response.ok) {
                            const data = await response.json();
                            const html = data.contents;

                            if (html && html.length > 1000) {
                                console.log(`✅ AllOrigins success: ${html.length} chars`);
                                const extractedContent = this.extractContentFromHTML(html, url);
                                if (extractedContent && extractedContent.length > 500) {
                                    return extractedContent;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`AllOrigins failed: ${error.message}`);
                    }

                    // Try CORS proxy
                    try {
                        const corsProxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                        const response = await fetch(corsProxyUrl);

                        if (response.ok) {
                            const html = await response.text();

                            if (html && html.length > 1000) {
                                console.log(`✅ CORS proxy success: ${html.length} chars`);
                                const extractedContent = this.extractContentFromHTML(html, url);
                                if (extractedContent && extractedContent.length > 500) {
                                    return extractedContent;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`CORS proxy failed: ${error.message}`);
                    }

                    throw new Error('All proxy methods failed to fetch content');

                } catch (error) {
                    console.error('❌ All fetch methods failed:', error);
                    throw error;
                }
            }

            extractContentFromHTML(html, url) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    // Remove unwanted elements
                    const unwantedSelectors = [
                        'script', 'style', 'nav', 'header', 'footer',
                        '.sidebar', '.menu', '.navigation', '.comments',
                        '.advertisement', '.ads', '.social-share',
                        '[role="banner"]', '[role="navigation"]', '[role="complementary"]'
                    ];

                    unwantedSelectors.forEach(selector => {
                        doc.querySelectorAll(selector).forEach(el => el.remove());
                    });

                    // Find main content
                    const contentSelectors = [
                        'article', '[role="main"]', '.post-content', '.entry-content', '.article-content',
                        '.content', '.main-content', '.post-body', '.entry', '.post', '.article-body',
                        'main', '#content', '#main'
                    ];

                    let contentElement = null;

                    for (const selector of contentSelectors) {
                        contentElement = doc.querySelector(selector);
                        if (contentElement && contentElement.textContent.trim().length > 200) {
                            break;
                        }
                    }

                    if (!contentElement || contentElement.textContent.trim().length < 200) {
                        const paragraphs = Array.from(doc.querySelectorAll('p'))
                            .filter(p => p.textContent.trim().length > 50)
                            .slice(0, 20);

                        if (paragraphs.length > 0) {
                            const div = doc.createElement('div');
                            paragraphs.forEach(p => div.appendChild(p.cloneNode(true)));
                            contentElement = div;
                        }
                    }

                    if (contentElement) {
                        let content = contentElement.innerHTML;

                        // Fix relative URLs
                        const baseUrl = new URL(url).origin;
                        content = content.replace(/src="\/([^"]+)"/g, `src="${baseUrl}/$1"`);
                        content = content.replace(/href="\/([^"]+)"/g, `href="${baseUrl}/$1"`);

                        content = `
                            <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                                <p style="margin: 0; font-size: 0.9em;">
                                    <strong>📡 Content fetched from original source</strong><br>
                                    This article content was retrieved in real-time from <a href="${url}" target="_blank" style="color: #1976d2;">${Utils.getDomain(url)}</a>
                                </p>
                            </div>
                            ${content}
                        `;

                        return content;
                    }

                    throw new Error('Could not extract readable content from page');

                } catch (error) {
                    console.error('Content extraction error:', error);
                    throw error;
                }
            }

            getArticleContent(article) {
                console.log('📖 Checking for saved content...');

                const contentFields = ['content', 'html', 'fullContent', 'textContent', 'body', 'readableContent', 'articleContent', 'savedContent'];

                for (const field of contentFields) {
                    if (article[field] && article[field].trim()) {
                        console.log(`✅ Found content in ${field} (${article[field].length} chars)`);
                        return article[field];
                    }
                }

                for (const [key, value] of Object.entries(article)) {
                    if (typeof value === 'string' && value.length > 200 && key !== 'excerpt' && key !== 'url') {
                        console.log(`✅ Found substantial content in ${key} (${value.length} chars)`);
                        return value;
                    }
                }

                console.log('❌ No saved content found');
                return null;
            }

            getFallbackContent(article, errorMessage) {
                return `
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h3>📄 Content Not Available</h3>
                        <p>We couldn't load the full article content. This can happen because:</p>
                        <ul style="margin: 15px 0;">
                            <li>The website blocks automated content fetching</li>
                            <li>CORS (Cross-Origin) restrictions prevent access</li>
                            <li>The article content wasn't saved by the browser extension</li>
                            <li>Network connectivity issues</li>
                        </ul>
                        
                        <p><strong>What you can do:</strong></p>
                        <ol style="margin: 15px 0;">
                            <li><strong>Visit the original article</strong> using the button below</li>
                            <li><strong>Re-save the article</strong> with your browser extension</li>
                            <li><strong>Check extension settings</strong> for content extraction options</li>
                        </ol>
                        
                        <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <p><strong>Available excerpt:</strong></p>
                            <p style="font-style: italic;">${article.excerpt || 'No excerpt available'}</p>
                        </div>
                        
                        <div style="text-align: center; margin: 20px 0;">
                            <a href="${article.url}" target="_blank" style="display: inline-block; background: #ee5a24; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                                🔗 Read Full Article
                            </a>
                        </div>
                        
                        <details style="margin-top: 20px;">
                            <summary style="cursor: pointer; color: #666;">Technical Details</summary>
                            <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
                                Error: ${errorMessage}
                            </p>
                        </details>
                    </div>
                `;
            }

            closeReader() {
                const overlay = document.getElementById('readerOverlay');
                overlay.classList.remove('active');
                document.body.style.overflow = 'auto';
                
                // Return focus to main content for accessibility
                document.querySelector('.articles-section').focus();
            }

            openOriginal() {
                if (this.currentArticle) {
                    window.open(this.currentArticle.url, '_blank');
                }
            }

            exportArticleByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                try {
                    const html = this.createArticleHTML(article);
                    const filename = `${Utils.sanitizeFilename(article.title)}.html`;
                    this.downloadFile(html, filename, 'text/html');
                    NotificationManager.success(`Article "${article.title}" exported successfully!`);
                } catch (error) {
                    ErrorManager.handleError(error, 'exportArticle', `Failed to export article: ${error.message}`);
                }
            }

            async deleteArticleByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                if (confirm(`Delete "${article.title}"?\n\nThis will permanently remove the article from your OneDrive backup.`)) {
                    try {
                        this.loadingManager.show('delete', 'Deleting article...');

                        const originalIndex = this.articles.findIndex(a =>
                            a.url === article.url && a.title === article.title
                        );

                        if (originalIndex === -1) {
                            throw new Error('Could not find article in main collection');
                        }

                        // Remove from cache
                        const cacheKey = this.imageCacheManager.getCacheKey(article);
                        this.imageCacheManager.imageCache.delete(cacheKey);
                        this.imageCacheManager.saveImageCache();

                        // Remove from arrays
                        this.articles.splice(originalIndex, 1);
                        this.currentDisplayedArticles.splice(displayIndex, 1);

                        if (this.authManager.accessToken) {
                            await this.updateOneDriveBackup();
                            NotificationManager.success(`Article deleted and backup updated. ${this.articles.length} articles remaining.`);
                        } else {
                            NotificationManager.warning('Article deleted locally but OneDrive backup not updated (not connected).');
                        }

                        this.loadingManager.hide('delete');
                        this.displayArticles(this.currentDisplayedArticles);

                    } catch (error) {
                        this.loadingManager.hide('delete');
                        ErrorManager.handleError(error, 'deleteArticle', `Failed to delete article: ${error.message}`);
                    }
                }
            }

            async refreshSingleImage(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                const imageElement = document.getElementById(`image-${displayIndex}`);
                if (!imageElement) {
                    console.error('Image element not found for index:', displayIndex);
                    return;
                }

                const proceed = confirm(`Refresh image for "${article.title.substring(0, 50)}..."?\n\nThis will clear the current image and try to find a better one.\n\nProceed?`);

                if (!proceed) return;

                console.log(`🔄 Refreshing single image for: ${article.title.substring(0, 30)}...`);

                try {
                    this.loadingManager.show('refresh', 'Refreshing image...');

                    // Clear cache
                    const cacheKey = this.imageCacheManager.getCacheKey(article);
                    this.imageCacheManager.imageCache.delete(cacheKey);

                    // Clear stored image
                    const mainArticleIndex = this.articles.findIndex(a =>
                        a.url === article.url && a.title === article.title
                    );
                    if (mainArticleIndex !== -1 && this.articles[mainArticleIndex].cachedImage) {
                        delete this.articles[mainArticleIndex].cachedImage;
                    }

                    // Show loading placeholder
                    imageElement.innerHTML = `
                        ${this.createPlaceholderHTML()}
                        <div class="cache-indicator loading">
                            🔄 Refreshing...
                        </div>
                    `;

                    // Try fresh extraction
                    let success = false;
                    try {
                        const extractedImage = await this.fetchRealImageFromWebsite(article.url);
                        if (extractedImage) {
                            await this.setArticleImageAndCache(article, displayIndex, extractedImage, 'refreshed');
                            success = true;
                        }
                    } catch (error) {
                        console.log(`⚠️ Fresh extraction failed: ${error.message}`);
                    }

                    if (!success) {
                        const fallbackImage = this.getCategoryBasedImage(article, displayIndex + Date.now());
                        await this.setArticleImageAndCache(article, displayIndex, fallbackImage, 'refreshed');
                        success = true;
                    }

                    this.loadingManager.hide('refresh');

                    if (success) {
                        NotificationManager.success(`Image refreshed successfully for "${article.title.substring(0, 40)}..."`);

                        if (this.authManager.accessToken) {
                            try {
                                await this.updateOneDriveBackup();
                                console.log('✅ Updated backup with refreshed image');
                            } catch (error) {
                                console.error('⚠️ Failed to update backup:', error);
                            }
                        }
                    } else {
                        throw new Error('All refresh strategies failed');
                    }

                } catch (error) {
                    this.loadingManager.hide('refresh');
                    ErrorManager.handleError(error, 'refreshSingleImage', `Failed to refresh image: ${error.message}`);
                }
            }

            async retryFailedImages() {
                if (!this.authManager.accessToken) {
                    NotificationManager.error('Please connect to OneDrive first');
                    return;
                }

                const articlesWithFailedImages = this.articles.filter((article, index) => {
                    const isExplicitlyFailed = this.imageCacheManager.failedImages.has(index);
                    const imageElement = document.getElementById(`image-${index}`);
                    const cacheIndicator = imageElement?.querySelector('.cache-indicator');
                    const hasFailedIndicator = cacheIndicator && cacheIndicator.textContent.includes('❌ Failed');

                    return isExplicitlyFailed || hasFailedIndicator;
                });

                if (articlesWithFailedImages.length === 0) {
                    NotificationManager.success('No explicitly failed images found. Use "Sync Images" for broader updates.');
                    return;
                }

                const proceed = confirm(`Retry ${articlesWithFailedImages.length} explicitly failed images?\n\nThis will ONLY affect images marked with "❌ Failed" status.\n\nProceed?`);

                if (!proceed) return;

                try {
                    this.loadingManager.show('retry', 'Retrying failed images...', { progress: true });

                    let retriedCount = 0;
                    let successCount = 0;

                    for (const article of articlesWithFailedImages) {
                        const originalIndex = this.articles.findIndex(a => a === article);
                        if (originalIndex === -1) continue;

                        try {
                            retriedCount++;
                            console.log(`🔄 Retrying FAILED image ${retriedCount}/${articlesWithFailedImages.length}: ${article.title.substring(0, 30)}...`);

                            this.imageCacheManager.failedImages.delete(originalIndex);

                            const success = await this.extractAndCacheRealImage(article, originalIndex);
                            if (success) {
                                successCount++;
                                console.log(`✅ Successfully recovered image: ${article.title.substring(0, 30)}...`);
                            }

                            const progress = (retriedCount / articlesWithFailedImages.length) * 100;
                            this.loadingManager.updateProgress('retry', progress);

                            await new Promise(resolve => setTimeout(resolve, 300));

                        } catch (error) {
                            console.error(`Failed to retry image for ${article.title}:`, error);
                            this.imageCacheManager.failedImages.add(originalIndex);
                        }
                    }

                    this.loadingManager.hide('retry');

                    const message = successCount > 0
                        ? `Retry complete! Recovered ${successCount}/${articlesWithFailedImages.length} failed images.`
                        : `Could not recover the failed images - they may be permanently unavailable.`;

                    if (successCount > 0) {
                        NotificationManager.success(message);

                        if (this.authManager.accessToken) {
                            try {
                                await this.updateOneDriveBackup();
                                console.log('✅ OneDrive backup updated with recovered images');
                            } catch (error) {
                                console.error('⚠️ Failed to save recovered images to backup:', error);
                            }
                        }
                    } else {
                        NotificationManager.warning(message);
                    }

                } catch (error) {
                    this.loadingManager.hide('retry');
                    ErrorManager.handleError(error, 'retryFailedImages', 'Failed to retry images');
                }
            }

            async forceSyncImages() {
                if (!this.authManager.accessToken) {
                    NotificationManager.error('Please connect to OneDrive first');
                    return;
                }

                try {
                    this.loadingManager.show('sync', 'Force syncing all images to OneDrive...', { progress: true });

                    let syncedCount = 0;
                    const totalArticles = this.articles.length;

                    for (let i = 0; i < this.articles.length; i++) {
                        const article = this.articles[i];

                        if (!article.cachedImage) {
                            let imageUrl = this.imageCacheManager.getCachedImage(article);

                            if (!imageUrl) {
                                imageUrl = this.getBestArticleImage(article);
                            }

                            if (!imageUrl) {
                                imageUrl = this.getCategoryBasedImage(article, i);
                            }

                            if (imageUrl) {
                                try {
                                    const imageData = await this.imageCacheManager.convertImageToBase64(imageUrl);
                                    if (imageData.stored) {
                                        article.cachedImage = {
                                            base64: imageData.base64,
                                            url: imageData.url,
                                            timestamp: Date.now(),
                                            size: imageData.size,
                                            source: 'force_sync'
                                        };
                                        syncedCount++;
                                    }
                                } catch (error) {
                                    console.error(`Failed to sync image for ${article.title}:`, error);
                                }
                            }
                        } else {
                            syncedCount++;
                        }

                        if (i % 5 === 0) {
                            const progress = (i / totalArticles) * 100;
                            this.loadingManager.updateProgress('sync', progress);
                        }
                    }

                    await this.updateOneDriveBackup();

                    this.loadingManager.hide('sync');
                    NotificationManager.success(`Force sync complete! ${syncedCount}/${totalArticles} images synced to OneDrive`);

                    this.displayArticles(this.articles);

                } catch (error) {
                    this.loadingManager.hide('sync');
                    ErrorManager.handleError(error, 'forceSyncImages', `Force sync failed: ${error.message}`);
                }
            }

            clearImageCache() {
                if (this.imageCacheManager.clearImageCache()) {
                    this.articles.forEach(article => {
                        if (article.cachedImage) {
                            delete article.cachedImage;
                        }
                    });
                    this.displayArticles(this.articles);
                }
            }

            async updateOneDriveBackup() {
                if (!this.authManager.accessToken) {
                    throw new Error('Not connected to OneDrive');
                }

                const articlesWithImages = this.articles.filter(a => a.cachedImage);
                const totalImageSizeKB = articlesWithImages.reduce((total, article) => {
                    return total + (article.cachedImage ? article.cachedImage.size || 0 : 0);
                }, 0);

                console.log(`📦 Creating backup with ${articlesWithImages.length} stored images (${Math.round(totalImageSizeKB)}KB)`);

                const backup = {
                    articles: this.articles,
                    settings: {
                        storeImagesInBackup: true,
                        maxImageSizeKB: CONFIG.CACHE.MAX_IMAGE_SIZE_KB
                    },
                    exportDate: new Date().toISOString(),
                    version: "5.0",
                    deviceInfo: {
                        browser: "Enhanced Web Reader with PKCE Security + Cross-Device Images",
                        platform: navigator.platform,
                        timestamp: Date.now(),
                        articleCount: this.articles.length,
                        storedImages: articlesWithImages.length,
                        totalImageSizeKB: Math.round(totalImageSizeKB),
                        authMethod: "Authorization Code + PKCE"
                    }
                };

                const fileName = `mypocket-backup-${new Date().toISOString().split('T')[0]}.json`;
                const fileContent = JSON.stringify(backup, null, 2);

                const backupSizeMB = fileContent.length / (1024 * 1024);
                if (backupSizeMB > 10) {
                    console.warn(`⚠️ Large backup detected: ${backupSizeMB.toFixed(1)}MB`);
                }

                const uploadUrl = `${CONFIG.API.GRAPH_API_BASE}/me/drive/root:/MyPocket/${fileName}:/content`;

                const uploadResponse = await fetch(uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${this.authManager.accessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: fileContent
                });

                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    throw new Error(`Failed to update OneDrive backup: ${uploadResponse.status} - ${errorText}`);
                }

                console.log(`✅ Backup saved with ${articlesWithImages.length} images (${Math.round(totalImageSizeKB)}KB)`);
                return await uploadResponse.json();
            }

            createArticleHTML(article) {
                return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${Utils.escapeHtml(article.title)}</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 40px 20px; 
            line-height: 1.7; 
            color: #333;
        }
        .header { 
            border-bottom: 3px solid #ee5a24; 
            margin-bottom: 32px; 
            padding-bottom: 24px; 
        }
        .title { 
            font-size: 2.4em; 
            font-weight: bold; 
            margin-bottom: 16px; 
            color: #2c3e50; 
            line-height: 1.2; 
        }
        .meta { 
            color: #7f8c8d; 
            font-size: 0.95em; 
            margin-bottom: 24px; 
        }
        .content { 
            font-size: 1.15em; 
            line-height: 1.8; 
        }
        .content img { 
            max-width: 100%; 
            height: auto; 
            margin: 24px 0; 
            border-radius: 8px; 
        }
        .content p { 
            margin-bottom: 1.4em; 
        }
        .footer { 
            margin-top: 48px; 
            padding-top: 24px; 
            border-top: 2px solid #f0f0f0; 
            color: #666; 
            font-size: 0.9em; 
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">${Utils.escapeHtml(article.title)}</h1>
        <div class="meta">
            <div style="margin-bottom: 8px;">🌐 From: <a href="${article.url}" style="color: #ee5a24;">${Utils.getDomain(article.url)}</a></div>
            ${article.author ? `<div style="margin-bottom: 8px;">✍️ By: ${Utils.escapeHtml(article.author)}</div>` : ''}
            <div style="margin-bottom: 8px;">📅 Saved: ${Utils.formatDate(article.dateAdded)}</div>
            <div>⏱️ Reading time: ${article.readTime || 1} minutes</div>
        </div>
    </div>
    <div class="content">
        ${article.content || article.excerpt || 'Content not available'}
    </div>
    <div class="footer">
        <p><strong>✨ Exported from MyPocket Enhanced Reader (PKCE Secured)</strong></p>
        <p>Original URL: <a href="${article.url}" style="color: #ee5a24;">${article.url}</a></p>
        <p>Export Date: ${new Date().toLocaleDateString()}</p>
    </div>
</body>
</html>`;
            }

            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                URL.revokeObjectURL(url);
            }

            displayEmptyState() {
                const container = document.getElementById('articlesContainer');
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">📖</div>
                        <h3>No articles found</h3>
                        <p>Use the MyPocket browser extension to save articles, then refresh this page.</p>
                    </div>`;
            }

            updateStatus(message, type = '') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }

            // UI Features
            toggleTestMode() {
                document.body.classList.toggle('test-mode');
                const isTestMode = document.body.classList.contains('test-mode');

                const testBtn = document.getElementById('testBtn');
                if (testBtn) {
                    testBtn.innerHTML = isTestMode
                        ? '<span>👁️</span> Hide Buttons'
                        : '<span>👁️</span> Show Buttons';
                }

                NotificationManager.success(
                    isTestMode
                        ? 'Test mode ON - Action buttons always visible'
                        : 'Test mode OFF - Action buttons show on hover'
                );
            }

            toggleDarkMode() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem(CONFIG.STORAGE.KEYS.THEME, newTheme);

                this.updateDarkModeButton(newTheme);
                NotificationManager.success(
                    newTheme === 'dark' ? 'Dark mode enabled' : 'Light mode enabled'
                );
            }

            loadThemePreference() {
                const savedTheme = localStorage.getItem(CONFIG.STORAGE.KEYS.THEME) || 'light';
                document.documentElement.setAttribute('data-theme', savedTheme);
                this.updateDarkModeButton(savedTheme);
            }

            updateDarkModeButton(theme) {
                const darkModeBtn = document.getElementById('darkModeBtn');
                if (darkModeBtn) {
                    darkModeBtn.innerHTML = theme === 'dark'
                        ? '<span>☀️</span> Light Mode'
                        : '<span>🌙</span> Dark Mode';
                }
            }

            showImageHelp() {
                const helpText = `
MyPocket Enhanced Image System Help:
====================================

🖼️ IMAGE STATUS INDICATORS:
• 🌐 Synced - Stored across all devices
• 💾 Cached - Stored locally on this device  
• 🔄 Refreshed - Recently updated image
• ❌ Failed - Could not load image

🔧 AVAILABLE ACTIONS:

1️⃣ INDIVIDUAL IMAGE REFRESH (🖼️ button):
   • Use when an image loaded but shows wrong content
   • Click the 🖼️ button on any article card
   • Tries to find the correct image for that article

2️⃣ RETRY FAILED IMAGES (Retry Failed button):
   • Only processes images marked "❌ Failed"
   • Leaves working images untouched

3️⃣ SYNC ALL IMAGES (Sync Images button):
   • Forces refresh of ALL images
   • Stores images for cross-device access

🎯 WHEN TO USE EACH:
Wrong but Working Image → Use 🖼️ (Individual Refresh)
Red "❌ Failed" Status → Use "Retry Failed" button  
Want All Fresh Images → Use "Sync Images" button

⌨️ KEYBOARD SHORTCUTS:
• / or Ctrl/Cmd+K - Open search
• j/k - Navigate between articles
• Enter - Open focused article
• Esc - Close search/reader

🔧 ENHANCED FEATURES:
• Improved error handling with notifications
• Better loading states with progress bars
• Enhanced accessibility with keyboard navigation
• Smart image caching with cross-device sync
• Debounced search for better performance
                `;

                alert(helpText);
            }

            showDebugInfo() {
                const cacheStats = this.imageCacheManager.getCacheStats();
                const storedImages = this.articles.filter(a => a.cachedImage).length;
                const totalStoredSizeKB = this.articles.reduce((total, article) => {
                    return total + (article.cachedImage ? article.cachedImage.size || 0 : 0);
                }, 0);

                const hasRefreshToken = !!this.authManager.getRefreshToken();
                const tokenTimestamp = localStorage.getItem(CONFIG.STORAGE.KEYS.TOKEN_TIMESTAMP);
                const tokenAge = tokenTimestamp ? Math.round((Date.now() - parseInt(tokenTimestamp)) / 1000 / 60) : 'Unknown';

                const info = `
MyPocket Enhanced Web Reader Debug Info:
========================================

Current URL: ${window.location.href}
Redirect URI: ${this.authManager.redirectUri}
Client ID: ${this.authManager.clientId}
Version: 5.0 (Enhanced)

🔐 SECURITY (PKCE):
- Authentication Method: Authorization Code + PKCE
- Security Level: HIGH (recommended for SPAs)
- Anti-CSRF Protection: Enabled (state parameter)
- Code Challenge Method: SHA256
- Token Storage: localStorage (access), sessionStorage (PKCE params)

🎫 TOKEN STATUS:
- Has Access Token: ${!!this.authManager.accessToken}
- Has Refresh Token: ${hasRefreshToken}
- Token Age: ${tokenAge} minutes
- Auto-Refresh: Enabled

📚 ARTICLES & IMAGES:
- Articles Loaded: ${this.articles.length}
- Currently Displayed: ${this.currentDisplayedArticles.length}
- Articles with Stored Images: ${storedImages}
- Total Stored Image Size: ${Math.round(totalStoredSizeKB)}KB
- Failed Images: ${this.imageCacheManager.failedImages.size}

🔍 SEARCH STATUS:
- Search Visible: ${this.isSearchVisible}
- Search Query: "${this.searchQuery}"
- Debounce Delay: ${CONFIG.UI.SEARCH_DEBOUNCE_MS}ms

💾 LOCAL CACHE:
- Total Cached Images: ${cacheStats.total}
- Memory Usage: ${Math.round(cacheStats.memoryUsage / 1024)} KB
- Cache Expiry: ${CONFIG.CACHE.EXPIRY_DAYS} days

🎨 ENHANCEMENTS:
- Modular Architecture: ✅
- Error Management: ✅
- Loading States: ✅
- Notifications: ✅
- Accessibility: ✅
- Keyboard Navigation: ✅
- Debounced Search: ✅
- Progress Indicators: ✅

⚡ PERFORMANCE:
- Utils debouncing: ${CONFIG.UI.SEARCH_DEBOUNCE_MS}ms
- Animation duration: ${CONFIG.UI.ANIMATION_DURATION}ms
- Notification duration: ${CONFIG.UI.NOTIFICATION_DURATION}ms
- Retry mechanism: 3 attempts with exponential backoff

Cross-Device Features:
- Enhanced image storage with better compression
- Automatic OneDrive sync after image updates
- Consistent fallback images across devices
- Improved error recovery
                `;

                alert(info);
                console.log('🔧 Enhanced Debug Info:', {
                    version: '5.0',
                    architecture: 'Modular',
                    enhancements: [
                        'Error Management',
                        'Loading States',
                        'Notifications',
                        'Accessibility',
                        'Keyboard Navigation',
                        'Debounced Search'
                    ],
                    articleStats: {
                        total: this.articles.length,
                        displayed: this.currentDisplayedArticles.length,
                        withImages: storedImages
                    },
                    config: CONFIG
                });
            }
        }

        // Initialize the application
        let webReader;
        document.addEventListener('DOMContentLoaded', () => {
            webReader = new MyPocketWebReader();
            window.webReader = webReader; // For backward compatibility with onclick handlers
        });
    </script>
</body>

</html>
