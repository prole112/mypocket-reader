<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyPocket - Enhanced AI Reader with Advanced Categorization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #ee5a24;
            --secondary-color: #667eea;
            --ai-primary: #9c27b0;
            --ai-secondary: #673ab7;
            --background: #f8f9fa;
            --surface: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --border: #e9ecef;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.15);
            --ai-glow: 0 0 20px rgba(156, 39, 176, 0.3);
        }

        /* Enhanced Dark mode with better contrast */
        [data-theme="dark"] {
            --primary-color: #ff6b35;
            --secondary-color: #7b88f7;
            --ai-primary: #ba68c8;
            --ai-secondary: #9575cd;
            --background: #0d1117;
            --surface: #161b22;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --border: #30363d;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.6);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.8);
            --ai-glow: 0 0 20px rgba(186, 104, 200, 0.4);
        }

        /* Dark mode specific improvements */
        [data-theme="dark"] .article-card {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .article-card:hover {
            border-color: #484f58;
            transform: translateY(-2px) scale(1.02);
        }

        [data-theme="dark"] .search-input {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .search-input:focus {
            border-color: var(--primary-color);
            background: var(--surface);
        }

        [data-theme="dark"] .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.8;
        }

        [data-theme="dark"] .search-close-btn:hover {
            background: #21262d;
            color: var(--text-primary);
        }

        [data-theme="dark"] .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border-color: var(--border);
        }

        [data-theme="dark"] .btn-secondary:hover {
            background: #21262d;
            border-color: #484f58;
            color: var(--text-primary);
        }

        [data-theme="dark"] .action-btn {
            background: rgba(22, 27, 34, 0.95);
            border-color: var(--border);
            color: var(--text-primary);
            backdrop-filter: blur(10px);
        }

        [data-theme="dark"] .action-btn:hover {
            background: rgba(33, 38, 45, 0.95);
            border-color: #484f58;
        }

        [data-theme="dark"] .read-btn:hover {
            background: rgba(13, 110, 253, 0.2);
            border-color: #0d6efd;
            color: #58a6ff;
        }

        [data-theme="dark"] .export-btn:hover {
            background: rgba(25, 135, 84, 0.2);
            border-color: #198754;
            color: #3fb950;
        }

        [data-theme="dark"] .refresh-image-btn:hover {
            background: rgba(255, 152, 0, 0.2);
            border-color: #ff9800;
            color: #ffb74d;
        }

        [data-theme="dark"] .delete-btn:hover {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #f85149;
        }

        [data-theme="dark"] .reader-container {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .reader-header {
            background: var(--background);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .reader-content {
            color: var(--text-primary);
        }

        [data-theme="dark"] .reader-content h1,
        [data-theme="dark"] .reader-content h2,
        [data-theme="dark"] .reader-content h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .reader-content blockquote {
            background: var(--background);
            border-left-color: var(--primary-color);
        }

        [data-theme="dark"] .close-reader {
            background: var(--primary-color);
        }

        [data-theme="dark"] .empty-state {
            color: var(--text-secondary);
        }

        [data-theme="dark"] .empty-state h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .connection-status.connected {
            background: rgba(25, 135, 84, 0.2);
            border-color: #198754;
            color: #3fb950;
        }

        [data-theme="dark"] .connection-status.disconnected {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #f85149;
        }

        /* Enhanced AI indicators */
        [data-theme="dark"] .cache-indicator.ai-categorized {
            background: var(--ai-primary);
            color: white;
            box-shadow: var(--ai-glow);
        }

        [data-theme="dark"] .cache-indicator.smart-categorized {
            background: var(--ai-secondary);
            color: white;
            box-shadow: var(--ai-glow);
        }

        [data-theme="dark"] .cache-indicator.advanced-ai {
            background: linear-gradient(45deg, var(--ai-primary), var(--ai-secondary));
            color: white;
            box-shadow: var(--ai-glow);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--background);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color), var(--ai-primary));
            color: white;
            padding: 20px 0;
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-left: 60px;
        }

        .logo {
            font-size: 1.8em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ai-badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.7em;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* Left Sidebar - Enhanced AI Style */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 300px;
            height: 100vh;
            background: var(--surface);
            border-right: 1px solid var(--border);
            z-index: 101;
            overflow-y: auto;
            transition: transform 0.3s ease;
            box-shadow: var(--shadow);
        }

        .sidebar.collapsed {
            transform: translateX(-240px);
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(135deg, var(--ai-primary), var(--ai-secondary));
            color: white;
        }

        .sidebar-brand {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.2em;
            font-weight: 600;
        }

        .ai-status {
            font-size: 0.8em;
            opacity: 0.9;
            margin-top: 5px;
        }

        .sidebar-toggle {
            position: absolute;
            right: -40px;
            top: 20px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0 8px 8px 0;
            padding: 8px;
            cursor: pointer;
            color: var(--text-primary);
            transition: all 0.2s ease;
            z-index: 102;
        }

        .sidebar-toggle:hover {
            background: var(--ai-primary);
            color: white;
            box-shadow: var(--ai-glow);
        }

        .sidebar-nav {
            padding: 20px 0;
        }

        .nav-section {
            margin-bottom: 30px;
        }

        .nav-section-title {
            padding: 0 20px 10px;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            letter-spacing: 0.5px;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            color: var(--text-primary);
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 14px;
        }

        .nav-item:hover {
            background: var(--background);
            color: var(--ai-primary);
            box-shadow: inset 3px 0 0 var(--ai-primary);
        }

        .nav-item.active {
            background: linear-gradient(90deg, var(--ai-primary), var(--ai-secondary));
            color: white;
            border-right: 3px solid var(--ai-primary);
            box-shadow: var(--ai-glow);
        }

        .nav-item .icon {
            width: 20px;
            text-align: center;
            font-size: 16px;
        }

        .nav-item .text {
            flex: 1;
        }

        .nav-item .badge {
            background: var(--border);
            color: var(--text-secondary);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: 500;
        }

        .nav-item.active .badge {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .ai-nav-item {
            background: linear-gradient(135deg, rgba(156, 39, 176, 0.1), rgba(103, 58, 183, 0.1));
            border-left: 3px solid var(--ai-primary);
        }

        .ai-nav-item:hover {
            background: linear-gradient(135deg, rgba(156, 39, 176, 0.2), rgba(103, 58, 183, 0.2));
            box-shadow: var(--ai-glow);
        }

        /* Connection Status in Sidebar */
        .connection-panel {
            padding: 15px 20px;
            margin: 10px 0;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
        }

        .connection-status-sidebar {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9em;
        }

        .connection-status-sidebar.connected {
            color: #27ae60;
        }

        .connection-status-sidebar.disconnected {
            color: #e74c3c;
        }

        .connect-btn-sidebar {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .connect-btn-sidebar:hover {
            background: var(--ai-primary);
            box-shadow: var(--ai-glow);
            transform: translateY(-1px);
        }

        .connect-btn-sidebar.connected {
            background: #27ae60;
        }

        /* Main Content Area */
        .main-content {
            margin-left: 300px;
            min-height: 100vh;
            transition: margin-left 0.3s ease;
        }

        .main-content.sidebar-collapsed {
            margin-left: 60px;
        }

        /* Mobile Sidebar */
        .mobile-header {
            display: none;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
            transform: translateY(-1px);
        }

        .btn-ai {
            background: linear-gradient(135deg, var(--ai-primary), var(--ai-secondary));
            color: white;
            border: 2px solid var(--ai-primary);
            box-shadow: var(--ai-glow);
        }

        .btn-ai:hover {
            background: linear-gradient(135deg, var(--ai-secondary), var(--ai-primary));
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(156, 39, 176, 0.4);
        }

        /* Enhanced Search Container */
        .search-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: linear-gradient(135deg, var(--surface), rgba(156, 39, 176, 0.05));
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 90;
            padding: 30px 0;
            box-shadow: var(--shadow);
        }

        .search-container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .search-container.hidden {
            opacity: 0;
            transform: translateY(-10px);
        }

        /* Enhanced Category Filter */
        .category-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: linear-gradient(135deg, var(--surface), rgba(156, 39, 176, 0.05));
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 89;
            padding: 25px 0;
            box-shadow: var(--shadow);
        }

        .category-container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .category-container.hidden {
            opacity: 0;
            transform: translateY(-10px);
        }

        .category-filter {
            max-width: 1000px;
            margin: 0 auto;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .category-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.3em;
            background: linear-gradient(135deg, var(--ai-primary), var(--ai-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .ai-stats {
            font-size: 0.8em;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        .category-close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .category-close-btn:hover {
            background: var(--ai-primary);
            color: white;
            transform: scale(1.1);
            box-shadow: var(--ai-glow);
        }

        .category-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }

        .category-chip {
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 25px;
            padding: 10px 18px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
            position: relative;
            overflow: hidden;
        }

        .category-chip::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .category-chip:hover::before {
            left: 100%;
        }

        .category-chip:hover {
            border-color: var(--ai-primary);
            background: linear-gradient(135deg, var(--ai-primary), var(--ai-secondary));
            color: white;
            transform: translateY(-3px);
            box-shadow: var(--ai-glow);
        }

        .category-chip.active {
            background: linear-gradient(135deg, var(--ai-primary), var(--ai-secondary));
            border-color: var(--ai-primary);
            color: white;
            box-shadow: var(--ai-glow);
        }

        .category-chip.show-all {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            border-color: var(--secondary-color);
            color: white;
            font-weight: 600;
            box-shadow: var(--shadow);
        }

        .category-chip.show-all:hover {
            background: linear-gradient(135deg, var(--primary-color), var(--ai-primary));
            border-color: var(--ai-primary);
            box-shadow: var(--ai-glow);
        }

        .category-count {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 3px 8px;
            font-size: 0.8em;
            font-weight: bold;
            min-width: 20px;
            text-align: center;
        }

        .category-chip:not(.active) .category-count {
            background: var(--border);
            color: var(--text-secondary);
        }

        /* Enhanced AI indicators for categories */
        .category-chip.ai-enhanced {
            border-color: var(--ai-primary);
            background: linear-gradient(45deg, var(--background), rgba(156, 39, 176, 0.1));
            position: relative;
        }

        .category-chip.ai-enhanced::after {
            content: "🤖";
            position: absolute;
            top: -5px;
            right: -5px;
            background: var(--ai-primary);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6em;
            box-shadow: var(--ai-glow);
        }

        .category-chip.advanced-ai {
            background: linear-gradient(135deg, rgba(156, 39, 176, 0.15), rgba(103, 58, 183, 0.15));
            border: 2px solid var(--ai-primary);
            box-shadow: var(--ai-glow);
        }

        .category-chip.advanced-ai::after {
            content: "🧠";
            background: linear-gradient(135deg, var(--ai-primary), var(--ai-secondary));
        }

        .search-box {
            position: relative;
            max-width: 700px;
            margin: 0 auto;
        }

        .search-input {
            width: 100%;
            padding: 18px 60px 18px 25px;
            border: 2px solid var(--border);
            border-radius: 30px;
            font-size: 16px;
            background: var(--background);
            transition: all 0.3s ease;
            box-shadow: var(--shadow);
        }

        .search-input:focus {
            outline: none;
            border-color: var(--ai-primary);
            box-shadow: var(--ai-glow);
            background: var(--surface);
        }

        .search-close-btn {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
        }

        .search-close-btn:hover {
            background: var(--ai-primary);
            color: white;
            transform: translateY(-50%) scale(1.1);
            box-shadow: var(--ai-glow);
        }

        /* Status */
        .status {
            padding: 20px 0;
            text-align: center;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .status.loading {
            color: var(--ai-primary);
        }

        .status.error {
            color: #e74c3c;
        }

        .status.success {
            color: #27ae60;
        }

        .status.ai-processing {
            background: linear-gradient(135deg, rgba(156, 39, 176, 0.1), rgba(103, 58, 183, 0.1));
            color: var(--ai-primary);
            border: 1px solid var(--ai-primary);
            border-radius: 10px;
            margin: 10px 20px;
        }

        /* Enhanced Articles Grid */
        .articles-section {
            padding: 40px 0;
            min-height: 60vh;
        }

        .articles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
            margin-top: 20px;
        }

        /* Enhanced Article Cards with AI indicators */
        .article-card {
            background: var(--surface);
            border-radius: 20px;
            overflow: visible;
            box-shadow: var(--shadow);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border: 1px solid var(--border);
            position: relative;
            display: flex;
            flex-direction: column;
            transform-origin: center center;
        }

        .article-card:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-8px) scale(1.02);
            border-color: var(--ai-primary);
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
        }

        /* AI-enhanced article indicators */
        .article-card.ai-categorized {
            border-color: var(--ai-primary);
            box-shadow: var(--ai-glow);
        }

        .article-card.ai-categorized::before {
            content: "🤖 AI Enhanced";
            position: absolute;
            top: 8px;
            left: 12px;
            background: linear-gradient(135deg, var(--ai-primary), var(--ai-secondary));
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: 600;
            z-index: 10;
            box-shadow: var(--ai-glow);
        }

        .article-card.advanced-ai::before {
            content: "🧠 Advanced AI";
            background: linear-gradient(135deg, var(--ai-secondary), #7b1fa2);
        }

        .article-image {
            width: 100%;
            height: 160px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            color: white;
            position: relative;
            overflow: hidden;
            border-radius: 20px 20px 0 0;
        }

        .article-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.4s ease, opacity 0.3s ease;
        }

        .article-image:hover img {
            transform: scale(1.08);
        }

        .article-content {
            padding: 20px;
            flex: 1;
            cursor: pointer;
        }

        .article-title {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 10px;
            line-height: 1.4;
            color: var(--text-primary);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-excerpt {
            color: var(--text-secondary);
            font-size: 0.9em;
            line-height: 1.5;
            margin-bottom: 15px;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            color: var(--text-secondary);
            font-size: 0.8em;
            margin-bottom: 10px;
        }

        .article-domain {
            font-weight: 500;
        }

        .article-date {
            opacity: 0.8;
        }

        .article-stats {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            font-size: 0.75em;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        /* Enhanced category badge with AI indicators */
        .article-category {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: var(--primary-color);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.7em;
            font-weight: 600;
            margin-bottom: 10px;
            position: relative;
            overflow: hidden;
        }

        .article-category.ai-category {
            background: linear-gradient(135deg, var(--ai-primary), var(--ai-secondary));
            box-shadow: var(--ai-glow);
        }

        .article-category.advanced-ai-category {
            background: linear-gradient(135deg, var(--ai-secondary), #7b1fa2);
            animation: aiPulse 2s ease-in-out infinite;
        }

        @keyframes aiPulse {
            0%, 100% { 
                box-shadow: var(--ai-glow);
            }
            50% { 
                box-shadow: 0 0 30px rgba(156, 39, 176, 0.5);
            }
        }

        .ai-confidence {
            background: rgba(255, 255, 255, 0.3);
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.6em;
            margin-left: 4px;
        }

        /* Enhanced floating action buttons */
        .article-actions {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 8px;
            opacity: 0 !important;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid var(--border);
            border-radius: 50%;
            padding: 12px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow);
            min-width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn:hover {
            transform: translateY(-4px) scale(1.15);
            box-shadow: var(--shadow-hover);
        }

        .read-btn:hover {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .export-btn:hover {
            background: #e8f5e8;
            border-color: #4caf50;
        }

        .refresh-image-btn:hover {
            background: #fff3e0;
            border-color: #ff9800;
        }

        .delete-btn {
            color: #f44336;
        }

        .delete-btn:hover {
            background: #ffebee;
            border-color: #f44336;
            color: #d32f2f;
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
        }

        /* Enhanced cache indicators with AI status */
        .cache-indicator {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            z-index: 5;
            font-weight: 600;
        }

        .cache-indicator.ai-categorized {
            background: linear-gradient(135deg, var(--ai-primary), var(--ai-secondary));
            color: white;
            box-shadow: var(--ai-glow);
        }

        .cache-indicator.advanced-ai {
            background: linear-gradient(135deg, var(--ai-secondary), #7b1fa2);
            color: white;
            box-shadow: var(--ai-glow);
            animation: aiPulse 2s ease-in-out infinite;
        }

        .cache-indicator.smart-categorized {
            background: linear-gradient(135deg, #673ab7, #9c27b0);
            color: white;
            box-shadow: var(--ai-glow);
        }

        /* Reader View */
        .reader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            overflow-y: auto;
        }

        .reader-overlay.active {
            display: block;
        }

        .reader-container {
            max-width: 800px;
            margin: 40px auto;
            background: var(--surface);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: var(--shadow-hover);
        }

        .reader-header {
            padding: 30px;
            border-bottom: 1px solid var(--border);
            background: var(--background);
        }

        .reader-title {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 15px;
            line-height: 1.3;
        }

        .reader-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .reader-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .reader-content {
            padding: 40px;
            font-size: 1.1em;
            line-height: 1.8;
            max-width: none;
        }

        .reader-content h1,
        .reader-content h2,
        .reader-content h3 {
            margin: 30px 0 15px;
            color: var(--text-primary);
        }

        .reader-content p {
            margin-bottom: 20px;
        }

        .reader-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
        }

        .reader-content blockquote {
            border-left: 4px solid var(--ai-primary);
            margin: 20px 0;
            padding: 15px 20px;
            background: var(--background);
            font-style: italic;
        }

        .close-reader {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--ai-primary);
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: var(--ai-glow);
        }

        .close-reader:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(156, 39, 176, 0.5);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 50%;
            border-top-color: var(--ai-primary);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* AI Processing Animation */
        .ai-processing-spinner {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 3px solid transparent;
            border-radius: 50%;
            border-top: 3px solid var(--ai-primary);
            border-right: 3px solid var(--ai-secondary);
            animation: aiSpin 1.5s linear infinite;
        }

        @keyframes aiSpin {
            0% {
                transform: rotate(0deg);
                filter: hue-rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
                filter: hue-rotate(360deg);
            }
        }

        /* Enhanced Mobile Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 0 12px;
            }

            .sidebar {
                transform: translateX(-100%);
                width: 100%;
                max-width: 300px;
                z-index: 105;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .sidebar.collapsed {
                transform: translateX(-100%);
            }

            .sidebar-toggle {
                display: none;
            }

            .header {
                padding: 15px 0;
                position: fixed;
                width: 100%;
                top: 0;
                z-index: 104;
            }

            .header-content {
                padding-left: 20px;
                padding-right: 20px;
            }

            .mobile-menu-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 6px;
                color: white;
                padding: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .mobile-menu-btn:hover {
                background: rgba(255, 255, 255, 0.3);
            }

            .main-content {
                margin-left: 0;
                padding-top: 80px;
            }

            .main-content.sidebar-collapsed {
                margin-left: 0;
            }

            .sidebar-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 103;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s ease;
            }

            .sidebar-overlay.active {
                opacity: 1;
                visibility: visible;
            }

            .logo {
                font-size: 1.4em;
            }

            .header-right {
                gap: 10px;
            }

            .mobile-menu-btn {
                display: none;
                align-items: center;
                justify-content: center;
                background: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 6px;
                color: white;
                padding: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-size: 18px;
                width: 36px;
                height: 36px;
            }

            .mobile-menu-btn:hover {
                background: rgba(255, 255, 255, 0.3);
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
                border-radius: 20px;
            }

            .search-container {
                padding: 20px 0;
                top: 80px;
            }

            .search-input {
                font-size: 16px !important;
                padding: 12px 45px 12px 16px;
                border-radius: 20px;
            }

            .search-close-btn {
                right: 12px;
                width: 28px;
                height: 28px;
                font-size: 16px;
            }

            .category-container {
                padding: 15px 0;
                top: 80px;
            }

            .category-header h3 {
                font-size: 1.1em;
            }

            .category-chips {
                gap: 8px;
            }

            .category-chip {
                padding: 6px 12px;
                font-size: 0.8em;
                border-radius: 16px;
            }

            .category-count {
                font-size: 0.7em;
                padding: 1px 4px;
            }

            .status {
                padding: 15px 0;
                font-size: 14px;
                line-height: 1.4;
            }

            .articles-section {
                padding: 20px 0;
            }

            .articles-grid {
                display: block;
                margin-top: 15px;
            }

            .article-card {
                display: block !important;
                width: 100% !important;
                margin-bottom: 20px !important;
                border-radius: 20px !important;
                overflow: hidden;
                background: var(--surface);
                border: 1px solid var(--border);
                box-shadow: var(--shadow);
                transform: none !important;
                animation: none !important;
            }

            .article-card:hover {
                transform: none !important;
                box-shadow: var(--shadow-hover);
            }

            .article-image {
                width: 100% !important;
                height: 140px !important;
                border-radius: 20px 20px 0 0 !important;
                position: relative;
            }

            .article-content {
                padding: 20px !important;
                cursor: pointer;
            }

            .article-title {
                font-size: 1.25em !important;
                font-weight: 600;
                margin-bottom: 10px !important;
                line-height: 1.4 !important;
                color: var(--text-primary);
                display: block !important;
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-excerpt {
                font-size: 1em !important;
                line-height: 1.5 !important;
                margin-bottom: 15px !important;
                color: var(--text-secondary);
                display: block !important;
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-meta {
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-wrap: wrap;
                gap: 8px;
                color: var(--text-secondary);
                font-size: 0.9em !important;
                margin-bottom: 10px;
            }

            .article-stats {
                display: flex;
                gap: 15px;
                font-size: 0.85em !important;
                color: var(--text-secondary);
                margin-bottom: 10px;
            }

            .article-category {
                font-size: 0.8em !important;
                padding: 4px 10px;
                margin-bottom: 10px;
            }

            .article-actions {
                position: static !important;
                opacity: 1 !important;
                visibility: visible !important;
                display: flex !important;
                justify-content: center;
                gap: 12px;
                padding: 15px 20px;
                background: var(--background);
                border-radius: 0;
                margin: 0;
                border-top: 1px solid var(--border);
            }

            .action-btn {
                min-width: 45px !important;
                height: 45px !important;
                font-size: 18px !important;
                border-radius: 50% !important;
                padding: 0;
                background: var(--surface);
                border: 2px solid var(--border);
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .action-btn:hover,
            .action-btn:active {
                border-radius: 50% !important;
                transform: scale(1.05);
                background: var(--ai-primary);
                color: white;
                border-color: var(--ai-primary);
                box-shadow: var(--ai-glow);
            }

            .reader-overlay {
                padding: 0;
                z-index: 106;
            }

            .reader-container {
                margin: 0 !important;
                border-radius: 0 !important;
                height: 100vh;
                max-width: none;
                display: flex;
                flex-direction: column;
            }

            .reader-header {
                padding: 20px;
                border-radius: 0;
                flex-shrink: 0;
            }

            .reader-title {
                font-size: 1.4em !important;
                line-height: 1.3;
                margin-bottom: 15px;
            }

            .reader-meta {
                font-size: 0.9em;
                gap: 15px;
            }

            .reader-content {
                padding: 20px;
                font-size: 1.1em !important;
                line-height: 1.7 !important;
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            .close-reader {
                top: 15px;
                right: 15px;
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .search-input {
                font-size: 16px !important;
                padding: 14px 50px 14px 18px;
            }

            .empty-state {
                padding: 40px 20px;
            }

            .empty-state-icon {
                font-size: 3em;
                margin-bottom: 15px;
            }

            .empty-state h3 {
                font-size: 1.3em;
                margin-bottom: 8px;
            }

            .empty-state p {
                font-size: 1em;
                line-height: 1.5;
            }
        }

        @media (max-width: 480px) {
            .article-title {
                font-size: 1.15em !important;
            }

            .article-excerpt {
                font-size: 0.95em !important;
            }

            .article-content {
                padding: 16px !important;
            }

            .header-actions {
                gap: 6px;
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        /* Connection Status */
        .connection-status {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 15px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .connection-status.connected {
            border-color: #27ae60;
            background: #d4edda;
        }

        .connection-status.disconnected {
            border-color: #e74c3c;
            background: #f8d7da;
        }
    </style>
</head>

<body>
    <!-- Left Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-brand">
                <span>🧠</span>
                <span>MyPocket Advanced AI</span>
            </div>
            <div class="ai-status">Enhanced categorization with 20+ intelligent categories</div>
        </div>

        <!-- Connection Status -->
        <div class="connection-panel">
            <div class="connection-status-sidebar" id="connectionStatusSidebar">
                <span id="connectionIcon">🔐</span>
                <span id="connectionText">Not Connected</span>
            </div>
            <button id="connectBtnSidebar" class="connect-btn-sidebar">
                Secure Connect
            </button>
        </div>

        <!-- Navigation -->
        <nav class="sidebar-nav">
            <!-- Main Actions -->
            <div class="nav-section">
                <div class="nav-section-title">AI Library</div>
                <button class="nav-item" id="allArticlesNav" onclick="webReader.showAllArticles()">
                    <span class="icon">📖</span>
                    <span class="text">All Articles</span>
                    <span class="badge" id="allArticlesBadge">0</span>
                </button>
                <button class="nav-item" id="searchNavBtn" onclick="webReader.toggleSearch()">
                    <span class="icon">🔍</span>
                    <span class="text">Smart Search</span>
                </button>
                <button class="nav-item ai-nav-item" id="categoriesNavBtn" onclick="webReader.toggleCategoryFilter()">
                    <span class="icon">🧠</span>
                    <span class="text">AI Categories</span>
                    <span class="badge" id="categoryBadge">0</span>
                </button>
            </div>

            <!-- AI Tools -->
            <div class="nav-section">
                <div class="nav-section-title">AI Tools</div>
                <button class="nav-item ai-nav-item" id="aiAnalyzeBtn" onclick="webReader.runAdvancedAIAnalysis()">
                    <span class="icon">🤖</span>
                    <span class="text">Advanced AI Analysis</span>
                </button>
                <button class="nav-item ai-nav-item" id="semanticSearchBtn" onclick="webReader.toggleSemanticSearch()">
                    <span class="icon">🧠</span>
                    <span class="text">Semantic Search</span>
                </button>
                <button class="nav-item" id="refreshNavBtn" onclick="webReader.loadArticles()">
                    <span class="icon">🔄</span>
                    <span class="text">Refresh</span>
                </button>
                <button class="nav-item" id="syncNavBtn" onclick="webReader.forceSyncImages()">
                    <span class="icon">🌐</span>
                    <span class="text">Sync Images</span>
                </button>
                <button class="nav-item" id="retryNavBtn" onclick="webReader.retryFailedImages()">
                    <span class="icon">🔁</span>
                    <span class="text">Retry Failed</span>
                </button>
            </div>

            <!-- Settings -->
            <div class="nav-section">
                <div class="nav-section-title">Settings</div>
                <button class="nav-item" onclick="webReader.clearImageCache()">
                    <span class="icon">🗑️</span>
                    <span class="text">Clear Cache</span>
                </button>
                <button class="nav-item" onclick="webReader.toggleDarkMode()">
                    <span class="icon" id="darkModeIcon">🌙</span>
                    <span class="text" id="darkModeText">Dark Mode</span>
                </button>
                <button class="nav-item" onclick="webReader.toggleTestMode()">
                    <span class="icon">👁️</span>
                    <span class="text">Show Buttons</span>
                </button>
                <button class="nav-item" onclick="webReader.showAIHelp()">
                    <span class="icon">🤖</span>
                    <span class="text">AI Help</span>
                </button>
                <button class="nav-item" onclick="webReader.showDebugInfo()">
                    <span class="icon">🔧</span>
                    <span class="text">Debug Info</span>
                </button>
            </div>
        </nav>

        <!-- Sidebar Toggle -->
        <button class="sidebar-toggle" id="sidebarToggle" onclick="webReader.toggleSidebar()">
            <span id="sidebarToggleIcon">◀</span>
        </button>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="webReader.closeMobileSidebar()"></div>

    <!-- Main Content Area -->
    <div class="main-content" id="mainContent">
        <!-- Header -->
        <header class="header">
            <div class="container">
                <div class="header-content">
                    <!-- Mobile Menu Button -->
                    <button class="mobile-menu-btn" id="mobileMenuBtn" onclick="webReader.openMobileSidebar()"
                        style="display: none;">
                        <span>☰</span>
                    </button>

                    <div class="logo">
                        <span>🧠</span>
                        MyPocket Advanced AI Reader
                        <span class="ai-badge">20+ AI Categories</span>
                    </div>

                    <div class="header-right">
                        <span id="headerStatus" class="header-status">🧠 Advanced AI Enhanced</span>
                    </div>
                </div>
            </div>
        </header>

        <!-- Search (Initially Hidden) -->
        <section class="search-container" id="searchContainer" style="display: none;">
            <div class="container">
                <div class="search-box">
                    <input type="text" id="searchInput" class="search-input"
                        placeholder="🧠 Advanced AI-powered semantic search... (Try: 'machine learning tutorials' or 'startup funding advice')" autocomplete="off">
                    <button class="search-close-btn" onclick="webReader.toggleSearch()" title="Close search">✕</button>
                </div>
            </div>
        </section>

        <!-- Category Filter (Initially Hidden) -->
        <section class="category-container" id="categoryContainer" style="display: none;">
            <div class="container">
                <div class="category-filter">
                    <div class="category-header">
                        <div>
                            <h3>🧠 Advanced AI Categories</h3>
                            <div class="ai-stats" id="aiStats">20+ intelligent categories with semantic analysis</div>
                        </div>
                        <button class="category-close-btn" onclick="webReader.toggleCategoryFilter()"
                            title="Close categories">✕</button>
                    </div>
                    <div class="category-chips" id="categoryChips">
                        <!-- Categories will be populated here -->
                    </div>
                </div>
            </div>
        </section>

        <!-- Status -->
        <div class="status" id="status">
            Connect to OneDrive to view your saved articles with advanced AI categorization
        </div>

        <!-- Articles -->
        <section class="articles-section">
            <div class="container">
                <div id="articlesContainer">
                    <div class="empty-state">
                        <div class="empty-state-icon">🧠</div>
                        <h3>Welcome to MyPocket Advanced AI Reader</h3>
                        <p>Connect to OneDrive to access your saved articles with 20+ intelligent AI categories and semantic analysis!</p>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <!-- Reader Overlay -->
    <div class="reader-overlay" id="readerOverlay">
        <div class="reader-container">
            <button class="close-reader" id="closeReader">✕</button>
            <div class="reader-header">
                <h1 class="reader-title" id="readerTitle">Article Title</h1>
                <div class="reader-meta" id="readerMeta">
                    <span>📅 <span id="readerDate">Date</span></span>
                    <span>🌐 <span id="readerDomain">Domain</span></span>
                    <span>⏱️ <span id="readerTime">5 min read</span></span>
                </div>
                <div class="reader-actions">
                    <button class="btn btn-secondary" id="openOriginal">
                        🔗 Open Original
                    </button>
                </div>
            </div>
            <div class="reader-content" id="readerContent">
                Article content will appear here...
            </div>
        </div>
    </div>

    <script>
        console.log('🚀 MyPocket Advanced AI Reader with Enhanced Categorization starting...');

        // Advanced AI categorization system
        class AdvancedAICategorizationEngine {
            constructor() {
                this.categories = this.initializeAdvancedCategories();
                this.semanticPatterns = this.initializeSemanticPatterns();
                this.contextAnalyzer = this.initializeContextAnalyzer();
                this.confidenceThresholds = this.initializeConfidenceThresholds();
                this.categoryHierarchy = this.initializeCategoryHierarchy();
                this.sentimentAnalyzer = this.initializeSentimentAnalyzer();
                this.topicModeling = this.initializeTopicModeling();
                
                console.log('🧠 Advanced AI Categorization Engine initialized with 20+ categories');
            }

            // Initialize 20+ intelligent categories with advanced patterns
            initializeAdvancedCategories() {
                return {
                    'Technology': {
                        icon: '💻',
                        confidence: 'high',
                        priority: 1,
                        keywords: [
                            // Core tech
                            'technology', 'tech', 'programming', 'code', 'coding', 'software', 'developer', 'development',
                            'javascript', 'python', 'react', 'vue', 'angular', 'node', 'api', 'github', 'stackoverflow',
                            'algorithm', 'database', 'web', 'mobile', 'app', 'application', 'framework', 'library',
                            'bug', 'debug', 'frontend', 'backend', 'fullstack', 'devops', 'cloud', 'aws', 'azure',
                            'docker', 'kubernetes', 'microservices', 'serverless', 'automation', 'testing',
                            // Advanced tech
                            'machine learning', 'artificial intelligence', 'ai', 'ml', 'neural network', 'deep learning',
                            'data science', 'blockchain', 'cryptocurrency', 'bitcoin', 'cybersecurity', 'security',
                            'hacking', 'penetration testing', 'open source', 'git', 'version control', 'ci/cd',
                            'quantum computing', 'edge computing', 'iot', 'internet of things', 'robotics',
                            'computer vision', 'nlp', 'natural language processing', 'big data', 'analytics'
                        ],
                        domains: ['github.com', 'stackoverflow.com', 'dev.to', 'techcrunch.com', 'theverge.com', 'arstechnica.com'],
                        semanticContext: ['innovation', 'digital transformation', 'emerging tech', 'tech trends'],
                        relatedCategories: ['Science', 'Business', 'Education']
                    },
                    'Artificial Intelligence': {
                        icon: '🤖',
                        confidence: 'high',
                        priority: 1,
                        keywords: [
                            'artificial intelligence', 'ai', 'machine learning', 'ml', 'deep learning', 'neural network',
                            'chatgpt', 'gpt', 'llm', 'large language model', 'transformer', 'bert', 'opencv',
                            'tensorflow', 'pytorch', 'keras', 'scikit-learn', 'pandas', 'numpy', 'jupyter',
                            'computer vision', 'nlp', 'natural language processing', 'sentiment analysis',
                            'reinforcement learning', 'supervised learning', 'unsupervised learning',
                            'generative ai', 'prompt engineering', 'fine tuning', 'model training',
                            'data mining', 'predictive analytics', 'recommendation system', 'chatbot',
                            'voice recognition', 'image recognition', 'pattern recognition', 'automation',
                            'cognitive computing', 'expert system', 'knowledge graph', 'ai ethics'
                        ],
                        domains: ['openai.com', 'deepmind.com', 'ai.google', 'research.facebook.com', 'arxiv.org'],
                        semanticContext: ['intelligent systems', 'automation', 'cognitive technology', 'ai research'],
                        relatedCategories: ['Technology', 'Science', 'Philosophy', 'Psychology']
                    },
                    'Business': {
                        icon: '💼',
                        confidence: 'high',
                        priority: 2,
                        keywords: [
                            'business', 'startup', 'entrepreneur', 'entrepreneurship', 'finance', 'financial',
                            'investment', 'investing', 'marketing', 'sales', 'strategy', 'management', 'leadership',
                            'company', 'revenue', 'profit', 'corporate', 'economics', 'market', 'industry',
                            'venture', 'funding', 'ipo', 'stocks', 'trading', 'cryptocurrency', 'fintech',
                            'saas', 'b2b', 'b2c', 'productivity', 'workflow', 'remote work', 'freelancing',
                            'consulting', 'networking', 'career', 'job', 'hiring', 'hr', 'human resources',
                            'innovation', 'disruption', 'scaling', 'growth hacking', 'customer acquisition',
                            'retention', 'conversion', 'roi', 'kpi', 'metrics', 'analytics', 'digital marketing'
                        ],
                        domains: ['linkedin.com', 'forbes.com', 'bloomberg.com', 'businessinsider.com', 'hbr.org'],
                        semanticContext: ['commercial success', 'market dynamics', 'economic growth', 'corporate strategy'],
                        relatedCategories: ['Technology', 'Economics', 'Psychology']
                    },
                    'Science': {
                        icon: '🔬',
                        confidence: 'high',
                        priority: 1,
                        keywords: [
                            'science', 'scientific', 'research', 'study', 'data', 'analysis', 'experiment',
                            'discovery', 'theory', 'hypothesis', 'biology', 'chemistry', 'physics', 'medicine',
                            'medical', 'health', 'healthcare', 'climate', 'environment', 'environmental',
                            'space', 'astronomy', 'genetics', 'neuroscience', 'quantum', 'nuclear',
                            'biochemistry', 'biotechnology', 'pharmaceutical', 'vaccine', 'covid', 'pandemic',
                            'evolution', 'ecology', 'sustainability', 'renewable energy', 'solar', 'wind energy',
                            'genomics', 'bioengineering', 'nanotechnology', 'materials science', 'particle physics',
                            'cosmology', 'astrophysics', 'molecular biology', 'microbiology', 'immunology'
                        ],
                        domains: ['arxiv.org', 'nature.com', 'science.org', 'plos.org', 'ncbi.nlm.nih.gov'],
                        semanticContext: ['scientific method', 'peer review', 'empirical evidence', 'research methodology'],
                        relatedCategories: ['Technology', 'Health', 'Environment', 'Philosophy']
                    },
                    'Politics': {
                        icon: '🏛️',
                        confidence: 'medium',
                        priority: 3,
                        keywords: [
                            'politics', 'political', 'government', 'policy', 'election', 'vote', 'voting',
                            'democracy', 'republican', 'democrat', 'conservative', 'liberal', 'senate',
                            'congress', 'president', 'prime minister', 'parliament', 'legislation', 'law',
                            'constitution', 'supreme court', 'judge', 'campaign', 'candidate', 'poll',
                            'debate', 'immigration', 'healthcare reform', 'tax policy', 'foreign policy',
                            'diplomacy', 'war', 'peace', 'conflict', 'international relations', 'sovereignty',
                            'nationalism', 'globalization', 'activism', 'protest', 'rally', 'geopolitics',
                            'governance', 'public policy', 'civil rights', 'social justice', 'electoral system'
                        ],
                        domains: ['politico.com', 'washingtonpost.com', 'nytimes.com', 'cnn.com', 'bbc.com'],
                        semanticContext: ['governance', 'civic engagement', 'political discourse', 'democratic process'],
                        relatedCategories: ['News', 'Philosophy', 'Society', 'Law']
                    },
                    'Philosophy': {
                        icon: '🤔',
                        confidence: 'medium',
                        priority: 4,
                        keywords: [
                            'philosophy', 'philosophical', 'ethics', 'moral', 'morality', 'epistemology',
                            'metaphysics', 'logic', 'reasoning', 'consciousness', 'existentialism', 'stoicism',
                            'buddhism', 'mindfulness', 'meditation', 'wisdom', 'truth', 'reality', 'existence',
                            'meaning', 'purpose', 'free will', 'determinism', 'phenomenology', 'nihilism',
                            'absurdism', 'pragmatism', 'rationalism', 'empiricism', 'virtue', 'justice',
                            'freedom', 'rights', 'utilitarianism', 'deontology', 'virtue ethics', 'critical thinking',
                            'philosophical inquiry', 'ontology', 'axiology', 'aesthetics', 'philosophy of mind',
                            'philosophy of science', 'social philosophy', 'political philosophy'
                        ],
                        domains: ['plato.stanford.edu', 'philpapers.org', 'philosophynow.org', 'aeon.co'],
                        semanticContext: ['intellectual inquiry', 'fundamental questions', 'conceptual analysis', 'wisdom'],
                        relatedCategories: ['Psychology', 'Science', 'Religion', 'Politics']
                    },
                    'Psychology': {
                        icon: '🧠',
                        confidence: 'medium',
                        priority: 3,
                        keywords: [
                            'psychology', 'psychological', 'mental health', 'therapy', 'counseling', 'behavior',
                            'cognitive', 'emotion', 'personality', 'depression', 'anxiety', 'stress', 'trauma',
                            'ptsd', 'mindfulness', 'self-help', 'motivation', 'habit', 'addiction', 'neurology',
                            'brain', 'mind', 'learning', 'memory', 'perception', 'development', 'social psychology',
                            'behavioral economics', 'decision making', 'bias', 'persuasion', 'influence',
                            'relationships', 'communication', 'leadership psychology', 'cognitive science',
                            'neuropsychology', 'clinical psychology', 'positive psychology', 'resilience'
                        ],
                        domains: ['psychologytoday.com', 'apa.org', 'psych.org', 'mindful.org'],
                        semanticContext: ['human behavior', 'mental processes', 'psychological well-being', 'therapy'],
                        relatedCategories: ['Health', 'Philosophy', 'Science', 'Self-Development']
                    },
                    'Design': {
                        icon: '🎨',
                        confidence: 'high',
                        priority: 2,
                        keywords: [
                            'design', 'designer', 'ui', 'ux', 'user experience', 'user interface', 'interface',
                            'visual', 'graphic', 'creative', 'art', 'artist', 'illustration', 'typography',
                            'color', 'layout', 'prototype', 'wireframe', 'figma', 'sketch', 'photoshop',
                            'adobe', 'branding', 'logo', 'icon', 'website design', 'web design', 'mobile design',
                            'app design', 'product design', 'industrial design', 'fashion', 'architecture',
                            'interior design', 'photography', 'video', 'animation', 'motion graphics',
                            'accessibility', 'usability', 'design thinking', 'human-centered design'
                        ],
                        domains: ['dribbble.com', 'behance.net', 'medium.com', 'uxdesign.cc', 'designbetter.co'],
                        semanticContext: ['visual communication', 'aesthetic appeal', 'user-centered design', 'creativity'],
                        relatedCategories: ['Technology', 'Art', 'Psychology']
                    },
                    'News': {
                        icon: '📰',
                        confidence: 'medium',
                        priority: 3,
                        keywords: [
                            'news', 'breaking', 'breaking news', 'report', 'reporter', 'journalist', 'journalism',
                            'media', 'current events', 'headline', 'press', 'investigation', 'crisis', 'conflict',
                            'war', 'peace', 'diplomacy', 'economy', 'economic', 'recession', 'inflation', 'gdp',
                            'unemployment', 'stock market', 'urgent', 'live', 'update', 'scandal', 'controversy',
                            'exclusive', 'interview', 'analysis', 'opinion', 'editorial', 'fact-check',
                            'misinformation', 'fake news', 'media literacy', 'press freedom'
                        ],
                        domains: ['bbc.com', 'cnn.com', 'nytimes.com', 'washingtonpost.com', 'reuters.com'],
                        semanticContext: ['current affairs', 'information dissemination', 'public awareness', 'journalism'],
                        relatedCategories: ['Politics', 'Society', 'Economics']
                    },
                    'Education': {
                        icon: '🎓',
                        confidence: 'high',
                        priority: 2,
                        keywords: [
                            'education', 'educational', 'learning', 'learn', 'course', 'courses', 'tutorial',
                            'tutorials', 'lesson', 'lessons', 'teach', 'teaching', 'teacher', 'student',
                            'university', 'college', 'school', 'academic', 'academia', 'knowledge', 'skill',
                            'skills', 'training', 'certification', 'certificate', 'degree', 'bachelor',
                            'master', 'phd', 'doctorate', 'mooc', 'online learning', 'e-learning', 'study',
                            'studying', 'exam', 'test', 'quiz', 'homework', 'assignment', 'research',
                            'curriculum', 'pedagogy', 'educational technology', 'distance learning'
                        ],
                        domains: ['coursera.org', 'edx.org', 'khanacademy.org', 'udemy.com', 'wikipedia.org'],
                        semanticContext: ['knowledge acquisition', 'skill development', 'academic achievement', 'learning'],
                        relatedCategories: ['Technology', 'Science', 'Philosophy']
                    },
                    'Entertainment': {
                        icon: '🎬',
                        confidence: 'medium',
                        priority: 4,
                        keywords: [
                            'entertainment', 'movie', 'movies', 'film', 'films', 'cinema', 'tv', 'television',
                            'show', 'shows', 'series', 'episode', 'season', 'music', 'song', 'album', 'artist',
                            'band', 'concert', 'festival', 'game', 'games', 'gaming', 'video games', 'esports',
                            'streaming', 'netflix', 'amazon prime', 'disney', 'hulu', 'spotify', 'apple music',
                            'youtube', 'twitch', 'celebrity', 'celebrities', 'hollywood', 'broadway', 'theater',
                            'comedy', 'humor', 'funny', 'meme', 'viral', 'pop culture', 'social media'
                        ],
                        domains: ['youtube.com', 'netflix.com', 'spotify.com', 'imdb.com', 'ign.com'],
                        semanticContext: ['leisure activities', 'cultural content', 'mass media', 'popular culture'],
                        relatedCategories: ['Technology', 'Art', 'Society']
                    },
                    'Health': {
                        icon: '🏥',
                        confidence: 'high',
                        priority: 2,
                        keywords: [
                            'health', 'healthy', 'healthcare', 'medical', 'medicine', 'doctor', 'physician',
                            'patient', 'hospital', 'clinic', 'treatment', 'therapy', 'disease', 'illness',
                            'symptoms', 'diagnosis', 'cure', 'medication', 'drug', 'pharmaceutical', 'fitness',
                            'exercise', 'workout', 'gym', 'running', 'yoga', 'nutrition', 'diet', 'food',
                            'vitamins', 'supplements', 'wellness', 'mental health', 'sleep', 'weight loss',
                            'weight gain', 'muscle', 'cardio', 'prevention', 'immunization', 'public health',
                            'epidemiology', 'telemedicine', 'health technology', 'medical research'
                        ],
                        domains: ['mayoclinic.org', 'webmd.com', 'healthline.com', 'nih.gov', 'who.int'],
                        semanticContext: ['medical care', 'physical wellness', 'health management', 'disease prevention'],
                        relatedCategories: ['Science', 'Psychology', 'Technology']
                    },
                    'Economics': {
                        icon: '📈',
                        confidence: 'medium',
                        priority: 3,
                        keywords: [
                            'economics', 'economic', 'economy', 'market', 'markets', 'finance', 'financial',
                            'inflation', 'deflation', 'recession', 'growth', 'gdp', 'unemployment', 'employment',
                            'labor', 'trade', 'import', 'export', 'currency', 'exchange rate', 'monetary policy',
                            'fiscal policy', 'central bank', 'federal reserve', 'interest rates', 'bonds',
                            'commodities', 'supply chain', 'demand', 'supply', 'microeconomics', 'macroeconomics',
                            'behavioral economics', 'economic theory', 'capitalism', 'socialism', 'free market'
                        ],
                        domains: ['economist.com', 'bloomberg.com', 'wsj.com', 'ft.com', 'federalreserve.gov'],
                        semanticContext: ['economic systems', 'market forces', 'financial analysis', 'economic policy'],
                        relatedCategories: ['Business', 'Politics', 'Mathematics']
                    },
                    'Environment': {
                        icon: '🌱',
                        confidence: 'medium',
                        priority: 3,
                        keywords: [
                            'environment', 'environmental', 'climate', 'climate change', 'global warming',
                            'sustainability', 'sustainable', 'renewable energy', 'solar', 'wind', 'green',
                            'eco', 'ecology', 'ecosystem', 'biodiversity', 'conservation', 'pollution',
                            'carbon', 'emissions', 'greenhouse gas', 'fossil fuels', 'clean energy', 'recycling',
                            'waste', 'plastic', 'ocean', 'forest', 'deforestation', 'wildlife', 'endangered species',
                            'carbon footprint', 'renewable', 'organic', 'environmental science', 'green technology',
                            'climate action', 'environmental policy', 'ecological footprint'
                        ],
                        domains: ['greenpeace.org', 'wwf.org', 'epa.gov', 'unfccc.int', 'ipcc.ch'],
                        semanticContext: ['environmental protection', 'sustainability', 'climate action', 'conservation'],
                        relatedCategories: ['Science', 'Politics', 'Technology']
                    },
                    'Society': {
                        icon: '👥',
                        confidence: 'medium',
                        priority: 3,
                        keywords: [
                            'society', 'social', 'community', 'culture', 'cultural', 'sociology', 'anthropology',
                            'social justice', 'equality', 'inequality', 'diversity', 'inclusion', 'racism',
                            'discrimination', 'human rights', 'civil rights', 'gender', 'feminism', 'lgbtq',
                            'immigration', 'refugee', 'poverty', 'homelessness', 'education', 'healthcare',
                            'social media', 'digital society', 'urbanization', 'demographics', 'population',
                            'social change', 'social movements', 'activism', 'social issues', 'public policy',
                            'social welfare', 'social psychology', 'group dynamics', 'social behavior'
                        ],
                        domains: ['sociologyguide.com', 'asa.org', 'chronicle.com'],
                        semanticContext: ['social structures', 'human interaction', 'cultural patterns', 'social change'],
                        relatedCategories: ['Politics', 'Psychology', 'Philosophy']
                    },
                    'Religion': {
                        icon: '🙏',
                        confidence: 'low',
                        priority: 4,
                        keywords: [
                            'religion', 'religious', 'faith', 'belief', 'spiritual', 'spirituality', 'god',
                            'christianity', 'islam', 'judaism', 'buddhism', 'hinduism', 'church', 'mosque',
                            'temple', 'prayer', 'worship', 'bible', 'quran', 'torah', 'meditation', 'pilgrimage',
                            'theology', 'scripture', 'doctrine', 'denomination', 'clergy', 'priest', 'pastor',
                            'imam', 'rabbi', 'religious studies', 'comparative religion', 'mysticism',
                            'secularism', 'atheism', 'agnosticism', 'interfaith', 'religious freedom'
                        ],
                        domains: ['religionfacts.com', 'patheos.com', 'beliefnet.com'],
                        semanticContext: ['spiritual beliefs', 'religious practices', 'faith traditions', 'theology'],
                        relatedCategories: ['Philosophy', 'Society', 'History']
                    },
                    'History': {
                        icon: '📜',
                        confidence: 'medium',
                        priority: 3,
                        keywords: [
                            'history', 'historical', 'ancient', 'medieval', 'modern', 'contemporary', 'past',
                            'civilization', 'empire', 'war', 'battle', 'revolution', 'discovery', 'exploration',
                            'archaeology', 'artifact', 'monument', 'museum', 'heritage', 'tradition', 'culture',
                            'timeline', 'chronology', 'period', 'era', 'dynasty', 'ruler', 'king', 'queen',
                            'emperor', 'historical figure', 'biography', 'documentary', 'primary source',
                            'secondary source', 'historiography', 'social history', 'cultural history',
                            'political history', 'military history', 'economic history'
                        ],
                        domains: ['history.com', 'smithsonianmag.com', 'nationalgeographic.com', 'britannica.com'],
                        semanticContext: ['historical events', 'past civilizations', 'historical analysis', 'heritage'],
                        relatedCategories: ['Politics', 'Society', 'Education']
                    },
                    'Sports': {
                        icon: '⚽',
                        confidence: 'medium',
                        priority: 4,
                        keywords: [
                            'sports', 'sport', 'football', 'soccer', 'basketball', 'baseball', 'tennis', 'golf',
                            'hockey', 'olympics', 'athlete', 'team', 'game', 'match', 'tournament', 'championship',
                            'league', 'player', 'coach', 'training', 'fitness', 'competition', 'score', 'win',
                            'lose', 'victory', 'defeat', 'mvp', 'draft', 'trade', 'playoff', 'season', 'stadium',
                            'fan', 'espn', 'nfl', 'nba', 'mlb', 'nhl', 'fifa', 'uefa', 'athletic performance',
                            'sports science', 'sports psychology', 'sports medicine', 'professional sports'
                        ],
                        domains: ['espn.com', 'sports.yahoo.com', 'bleacherreport.com', 'si.com'],
                        semanticContext: ['athletic competition', 'physical performance', 'team dynamics', 'sportsmanship'],
                        relatedCategories: ['Health', 'Entertainment', 'Psychology']
                    },
                    'Travel': {
                        icon: '✈️',
                        confidence: 'medium',
                        priority: 4,
                        keywords: [
                            'travel', 'traveling', 'trip', 'vacation', 'holiday', 'tourism', 'tourist',
                            'destination', 'flight', 'flights', 'airline', 'airport', 'hotel', 'accommodation',
                            'booking', 'airbnb', 'hostel', 'resort', 'adventure', 'explore', 'exploring',
                            'backpacking', 'hiking', 'camping', 'road trip', 'cruise', 'culture', 'cultural',
                            'country', 'city', 'guide', 'travel guide', 'itinerary', 'budget travel',
                            'luxury travel', 'solo travel', 'family travel', 'business travel', 'nomad',
                            'wanderlust', 'sightseeing', 'landmark', 'national park'
                        ],
                        domains: ['tripadvisor.com', 'booking.com', 'airbnb.com', 'lonelyplanet.com'],
                        semanticContext: ['exploration', 'cultural experience', 'leisure travel', 'adventure'],
                        relatedCategories: ['Geography', 'Culture', 'Entertainment']
                    },
                    'Food': {
                        icon: '🍳',
                        confidence: 'medium',
                        priority: 4,
                        keywords: [
                            'food', 'recipe', 'recipes', 'cooking', 'cook', 'chef', 'kitchen', 'restaurant',
                            'restaurants', 'dining', 'cuisine', 'culinary', 'ingredient', 'ingredients', 'meal',
                            'meals', 'dish', 'dishes', 'baking', 'bake', 'bread', 'cake', 'dessert', 'nutrition',
                            'diet', 'healthy eating', 'vegetarian', 'vegan', 'gluten-free', 'organic',
                            'local food', 'farm to table', 'foodie', 'wine', 'beer', 'cocktail', 'beverage',
                            'coffee', 'tea', 'breakfast', 'lunch', 'dinner', 'gastronomy', 'food science',
                            'molecular gastronomy', 'food culture', 'food sustainability'
                        ],
                        domains: ['allrecipes.com', 'foodnetwork.com', 'epicurious.com', 'bonappetit.com'],
                        semanticContext: ['culinary arts', 'gastronomy', 'food culture', 'nutrition'],
                        relatedCategories: ['Health', 'Culture', 'Science']
                    },
                    'Self-Development': {
                        icon: '🌟',
                        confidence: 'medium',
                        priority: 3,
                        keywords: [
                            'self development', 'personal development', 'self improvement', 'growth', 'mindset',
                            'motivation', 'inspiration', 'goals', 'productivity', 'habits', 'discipline',
                            'self help', 'coaching', 'mentoring', 'leadership', 'success', 'achievement',
                            'confidence', 'self esteem', 'resilience', 'emotional intelligence', 'mindfulness',
                            'meditation', 'self awareness', 'personal growth', 'life skills', 'time management',
                            'organization', 'planning', 'decision making', 'problem solving', 'creativity',
                            'innovation', 'learning', 'skill building', 'career development', 'life coaching'
                        ],
                        domains: ['ted.com', 'medium.com', 'psychologytoday.com', 'mindful.org'],
                        semanticContext: ['personal growth', 'self-improvement', 'life enhancement', 'skill development'],
                        relatedCategories: ['Psychology', 'Philosophy', 'Education']
                    }
                };
            }

            // Initialize semantic patterns for advanced understanding
            initializeSemanticPatterns() {
                return {
                    questionPatterns: [
                        /^(how|what|why|when|where|who|which|can|should|will|would|could|is|are|do|does|did)/i,
                        /\b(tutorial|guide|explanation|introduction|overview)\b/i
                    ],
                    tutorialPatterns: [
                        /\b(tutorial|guide|how to|step by step|walkthrough|beginner|learn|master)\b/i,
                        /\b(getting started|introduction to|basics of)\b/i
                    ],
                    newsPatterns: [
                        /\b(breaking|urgent|update|report|announces|reveals|discovers)\b/i,
                        /\b(yesterday|today|this week|recently|latest|new)\b/i
                    ],
                    opinionPatterns: [
                        /\b(opinion|thoughts|review|analysis|commentary|perspective|critique)\b/i,
                        /\b(i think|in my opinion|personally|arguably|controversial)\b/i
                    ],
                    technicalPatterns: [
                        /\b(implementation|architecture|framework|algorithm|methodology)\b/i,
                        /\b(performance|optimization|scalability|security|testing)\b/i
                    ],
                    researchPatterns: [
                        /\b(study|research|findings|results|conclusion|methodology|hypothesis)\b/i,
                        /\b(data|analysis|statistics|survey|experiment|peer reviewed)\b/i
                    ]
                };
            }

            // Initialize context analyzer for better understanding
            initializeContextAnalyzer() {
                return {
                    domainContext: {
                        'github.com': { primary: 'Technology', secondary: ['Open Source', 'Programming'] },
                        'arxiv.org': { primary: 'Science', secondary: ['Research', 'Academic'] },
                        'medium.com': { primary: 'Technology', secondary: ['Opinion', 'Tutorial'] },
                        'stackoverflow.com': { primary: 'Technology', secondary: ['Programming', 'Problem Solving'] },
                        'youtube.com': { primary: 'Entertainment', secondary: ['Education', 'Tutorial'] },
                        'linkedin.com': { primary: 'Business', secondary: ['Professional', 'Career'] },
                        'ted.com': { primary: 'Education', secondary: ['Inspiration', 'Ideas'] }
                    },
                    titlePatterns: {
                        'Ultimate Guide': { boost: ['Education'], confidence: 0.3 },
                        'How to': { boost: ['Education'], confidence: 0.4 },
                        'Introduction to': { boost: ['Education'], confidence: 0.3 },
                        'Breaking': { boost: ['News'], confidence: 0.5 },
                        'Review': { boost: ['Entertainment', 'Technology'], confidence: 0.2 },
                        'Analysis': { boost: ['Science', 'Business'], confidence: 0.3 },
                        'Deep Dive': { boost: ['Education', 'Technology'], confidence: 0.4 },
                        'Best Practices': { boost: ['Technology', 'Business'], confidence: 0.3 },
                        'Case Study': { boost: ['Business', 'Education'], confidence: 0.4 },
                        'Tutorial': { boost: ['Education', 'Technology'], confidence: 0.5 },
                        'Research': { boost: ['Science'], confidence: 0.4 },
                        'Opinion': { boost: ['Politics', 'Philosophy'], confidence: 0.2 }
                    },
                    contentLength: {
                        short: { threshold: 500, bias: ['News', 'Social Media'] },
                        medium: { threshold: 2000, bias: ['Technology', 'Business'] },
                        long: { threshold: 5000, bias: ['Science', 'Education', 'Philosophy'] }
                    }
                };
            }

            // Initialize confidence thresholds for different categories
            initializeConfidenceThresholds() {
                return {
                    high: { threshold: 80, categories: ['Technology', 'Science', 'Health'] },
                    medium: { threshold: 60, categories: ['Business', 'Education', 'Design'] },
                    low: { threshold: 40, categories: ['Politics', 'Philosophy', 'Entertainment'] },
                    fallback: { threshold: 20, categories: ['Society', 'Lifestyle'] }
                };
            }

            // Initialize category hierarchy for better relationships
            initializeCategoryHierarchy() {
                return {
                    'Technology': {
                        parent: null,
                        children: ['Artificial Intelligence', 'Design'],
                        related: ['Science', 'Business', 'Education']
                    },
                    'Artificial Intelligence': {
                        parent: 'Technology',
                        children: [],
                        related: ['Science', 'Philosophy', 'Psychology']
                    },
                    'Science': {
                        parent: null,
                        children: ['Health', 'Environment'],
                        related: ['Technology', 'Education', 'Philosophy']
                    },
                    'Business': {
                        parent: null,
                        children: ['Economics'],
                        related: ['Technology', 'Psychology', 'Society']
                    }
                };
            }

            // Initialize sentiment analyzer for context
            initializeSentimentAnalyzer() {
                return {
                    positive: ['amazing', 'excellent', 'great', 'wonderful', 'fantastic', 'outstanding', 'brilliant', 'innovative'],
                    negative: ['terrible', 'awful', 'bad', 'poor', 'disappointing', 'frustrating', 'broken', 'failed'],
                    neutral: ['interesting', 'notable', 'significant', 'important', 'relevant', 'useful', 'practical'],
                    technical: ['implementation', 'architecture', 'performance', 'scalability', 'efficiency', 'optimization']
                };
            }

            // Initialize topic modeling patterns
            initializeTopicModeling() {
                return {
                    clusters: {
                        'AI_ML': ['artificial intelligence', 'machine learning', 'neural network', 'deep learning', 'ai model'],
                        'WEB_DEV': ['javascript', 'react', 'frontend', 'backend', 'web development', 'api'],
                        'DATA_SCIENCE': ['data science', 'analytics', 'big data', 'statistics', 'data mining'],
                        'BLOCKCHAIN': ['blockchain', 'cryptocurrency', 'bitcoin', 'ethereum', 'smart contract'],
                        'CLIMATE': ['climate change', 'global warming', 'sustainability', 'renewable energy'],
                        'HEALTH_TECH': ['digital health', 'telemedicine', 'health app', 'medical technology'],
                        'FINTECH': ['fintech', 'digital banking', 'payment', 'financial technology'],
                        'POLITICS_NEWS': ['election', 'government', 'policy', 'political news', 'legislation']
                    },
                    weights: {
                        'AI_ML': { 'Artificial Intelligence': 0.9, 'Technology': 0.7, 'Science': 0.3 },
                        'WEB_DEV': { 'Technology': 0.8, 'Design': 0.4, 'Education': 0.3 },
                        'DATA_SCIENCE': { 'Technology': 0.7, 'Science': 0.6, 'Business': 0.4 },
                        'BLOCKCHAIN': { 'Technology': 0.8, 'Business': 0.6, 'Economics': 0.5 },
                        'CLIMATE': { 'Environment': 0.9, 'Science': 0.7, 'Politics': 0.4 },
                        'HEALTH_TECH': { 'Health': 0.8, 'Technology': 0.6, 'Science': 0.4 },
                        'FINTECH': { 'Business': 0.8, 'Technology': 0.6, 'Economics': 0.5 },
                        'POLITICS_NEWS': { 'Politics': 0.8, 'News': 0.6, 'Society': 0.4 }
                    }
                };
            }

            // Advanced AI categorization with semantic understanding
            categorizeWithAdvancedAI(article) {
                console.log(`🧠 Advanced AI categorization for: "${article.title.substring(0, 40)}..."`);
                
                const title = (article.title || '').toLowerCase();
                const excerpt = (article.excerpt || '').toLowerCase();
                const url = (article.url || '').toLowerCase();
                const domain = this.getDomain(article.url).toLowerCase();
                const content = this.getArticleContentForAnalysis(article).toLowerCase();
                
                // Enhanced text analysis with more context
                const fullText = `${title} ${title} ${excerpt} ${content}`.substring(0, 8000);
                
                const scores = new Map();
                let analysisDetails = {};
                let contextFactors = this.analyzeContext(article, domain, title, fullText);
                
                // Multi-layered scoring system
                for (const [categoryName, categoryData] of Object.entries(this.categories)) {
                    let score = 0;
                    let reasons = [];
                    let confidenceFactors = [];
                    
                    // Layer 1: Domain and URL analysis (highest priority)
                    const domainScore = this.analyzeDomain(domain, url, categoryData);
                    score += domainScore.score;
                    if (domainScore.score > 0) {
                        reasons.push(...domainScore.reasons);
                        confidenceFactors.push('domain_match');
                    }
                    
                    // Layer 2: Semantic title analysis
                    const titleScore = this.analyzeTitle(title, categoryData, categoryName);
                    score += titleScore.score;
                    if (titleScore.score > 0) {
                        reasons.push(...titleScore.reasons);
                        confidenceFactors.push('title_semantic');
                    }
                    
                    // Layer 3: Content semantic analysis
                    const contentScore = this.analyzeContent(fullText, categoryData, categoryName);
                    score += contentScore.score;
                    if (contentScore.score > 0) {
                        reasons.push(...contentScore.reasons);
                        confidenceFactors.push('content_semantic');
                    }
                    
                    // Layer 4: Topic modeling and clustering
                    const topicScore = this.analyzeTopics(fullText, categoryName);
                    score += topicScore.score;
                    if (topicScore.score > 0) {
                        reasons.push(...topicScore.reasons);
                        confidenceFactors.push('topic_modeling');
                    }
                    
                    // Layer 5: Context and pattern recognition
                    const contextScore = this.analyzeContextPatterns(fullText, title, categoryName, contextFactors);
                    score += contextScore.score;
                    if (contextScore.score > 0) {
                        reasons.push(...contextScore.reasons);
                        confidenceFactors.push('context_patterns');
                    }
                    
                    // Layer 6: Relationship and hierarchy bonuses
                    const relationshipScore = this.analyzeRelationships(scores, categoryName);
                    score += relationshipScore;
                    
                    scores.set(categoryName, score);
                    analysisDetails[categoryName] = {
                        score: Math.round(score),
                        reasons: reasons,
                        confidence: categoryData.confidence || 'medium',
                        confidenceFactors: confidenceFactors,
                        priority: categoryData.priority || 5
                    };
                }
                
                // Advanced decision making with AI logic
                const decision = this.makeAdvancedDecision(scores, analysisDetails, contextFactors, article);
                
                // Store enhanced analysis results
                article.category = decision.category;
                article.categoryScore = decision.score;
                article.categoryConfidence = decision.confidence;
                article.aiEnhanced = decision.aiEnhanced;
                article.advancedAI = decision.advancedAI;
                article.categoryAnalysis = decision.analysis;
                article.semanticTags = decision.semanticTags;
                
                console.log(`🎯 Advanced AI: "${article.title.substring(0, 30)}..." → ${decision.category} (score: ${decision.score}, confidence: ${decision.confidence}%)`);
                
                return decision.category;
            }

            // Analyze domain with advanced patterns
            analyzeDomain(domain, url, categoryData) {
                let score = 0;
                let reasons = [];
                
                // Exact domain matches
                for (const d of categoryData.domains || []) {
                    if (domain === d || domain.includes(d)) {
                        score += 400; // Increased from 300
                        reasons.push(`exact_domain: ${d}`);
                        break;
                    }
                }
                
                // Context-aware domain patterns
                const domainContext = this.contextAnalyzer.domainContext[domain];
                if (domainContext && categoryData.relatedCategories?.includes(domainContext.primary)) {
                    score += 200;
                    reasons.push(`domain_context: ${domainContext.primary}`);
                }
                
                // URL path analysis
                for (const keyword of categoryData.keywords || []) {
                    if (url.includes(keyword)) {
                        score += 25;
                        reasons.push(`url_keyword: ${keyword}`);
                    }
                }
                
                return { score, reasons };
            }

            // Advanced title analysis with semantic understanding
            analyzeTitle(title, categoryData, categoryName) {
                let score = 0;
                let reasons = [];
                
                const titleWords = title.split(/\s+/);
                
                // Semantic phrase matching
                for (const keyword of categoryData.keywords || []) {
                    // Multi-word phrase matching
                    if (keyword.includes(' ') && title.includes(keyword)) {
                        score += 200; // Higher score for phrase matches
                        reasons.push(`title_phrase: "${keyword}"`);
                    }
                    // Single word matches with context
                    else if (titleWords.some(word => word === keyword || word.includes(keyword))) {
                        score += 120;
                        reasons.push(`title_word: "${keyword}"`);
                    }
                    // Partial matches with semantic similarity
                    else if (titleWords.some(word => this.areSemanticallySimilar(word, keyword))) {
                        score += 80;
                        reasons.push(`title_semantic: "${keyword}"`);
                    }
                }
                
                // Title pattern analysis
                for (const [pattern, config] of Object.entries(this.contextAnalyzer.titlePatterns)) {
                    if (title.includes(pattern.toLowerCase())) {
                        if (config.boost.includes(categoryName)) {
                            score += config.confidence * 300;
                            reasons.push(`title_pattern: "${pattern}"`);
                        }
                    }
                }
                
                // Question pattern detection
                for (const pattern of this.semanticPatterns.questionPatterns) {
                    if (pattern.test(title)) {
                        if (['Education', 'Technology'].includes(categoryName)) {
                            score += 100;
                            reasons.push('question_pattern');
                        }
                        break;
                    }
                }
                
                return { score, reasons };
            }

            // Advanced content analysis with NLP-inspired techniques
            analyzeContent(content, categoryData, categoryName) {
                let score = 0;
                let reasons = [];
                
                // Keyword density analysis
                const contentWords = content.split(/\s+/);
                const totalWords = contentWords.length;
                
                for (const keyword of categoryData.keywords || []) {
                    const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                    const matches = content.match(regex);
                    if (matches) {
                        const density = matches.length / totalWords;
                        const densityScore = Math.min(density * 5000, 150); // Cap at 150
                        score += densityScore;
                        
                        if (matches.length > 2) {
                            reasons.push(`content_density: "${keyword}" (${matches.length}x, ${(density * 100).toFixed(2)}%)`);
                        }
                    }
                }
                
                // Semantic context analysis
                if (categoryData.semanticContext) {
                    for (const context of categoryData.semanticContext) {
                        if (content.includes(context)) {
                            score += 80;
                            reasons.push(`semantic_context: "${context}"`);
                        }
                    }
                }
                
                // Technical pattern recognition
                for (const pattern of this.semanticPatterns.technicalPatterns) {
                    if (pattern.test(content)) {
                        if (['Technology', 'Science', 'Business'].includes(categoryName)) {
                            score += 60;
                            reasons.push('technical_pattern');
                        }
                    }
                }
                
                return { score, reasons };
            }

            // Topic modeling and clustering analysis
            analyzeTopics(content, categoryName) {
                let score = 0;
                let reasons = [];
                
                for (const [clusterName, keywords] of Object.entries(this.topicModeling.clusters)) {
                    let clusterMatches = 0;
                    for (const keyword of keywords) {
                        if (content.includes(keyword)) {
                            clusterMatches++;
                        }
                    }
                    
                    if (clusterMatches >= 2) {
                        const weights = this.topicModeling.weights[clusterName];
                        if (weights && weights[categoryName]) {
                            const clusterScore = clusterMatches * weights[categoryName] * 100;
                            score += clusterScore;
                            reasons.push(`topic_cluster: ${clusterName} (${clusterMatches} matches)`);
                        }
                    }
                }
                
                return { score, reasons };
            }

            // Context pattern analysis
            analyzeContextPatterns(content, title, categoryName, contextFactors) {
                let score = 0;
                let reasons = [];
                
                // Tutorial and educational content detection
                if (this.semanticPatterns.tutorialPatterns.some(pattern => pattern.test(title + ' ' + content))) {
                    if (['Education', 'Technology'].includes(categoryName)) {
                        score += 100;
                        reasons.push('tutorial_pattern');
                    }
                }
                
                // News and current events detection
                if (this.semanticPatterns.newsPatterns.some(pattern => pattern.test(title + ' ' + content))) {
                    if (['News', 'Politics', 'Society'].includes(categoryName)) {
                        score += 120;
                        reasons.push('news_pattern');
                    }
                }
                
                // Research and academic content detection
                if (this.semanticPatterns.researchPatterns.some(pattern => pattern.test(content))) {
                    if (['Science', 'Education', 'Health'].includes(categoryName)) {
                        score += 150;
                        reasons.push('research_pattern');
                    }
                }
                
                // Opinion and analysis detection
                if (this.semanticPatterns.opinionPatterns.some(pattern => pattern.test(content))) {
                    if (['Politics', 'Philosophy', 'Society'].includes(categoryName)) {
                        score += 80;
                        reasons.push('opinion_pattern');
                    }
                }
                
                return { score, reasons };
            }

            // Analyze category relationships and hierarchies
            analyzeRelationships(scores, categoryName) {
                let bonus = 0;
                const hierarchy = this.categoryHierarchy[categoryName];
                
                if (hierarchy) {
                    // Parent-child relationship bonus
                    if (hierarchy.parent && scores.has(hierarchy.parent)) {
                        const parentScore = scores.get(hierarchy.parent);
                        if (parentScore > 100) {
                            bonus += parentScore * 0.3; // 30% of parent score
                        }
                    }
                    
                    // Related category bonus
                    if (hierarchy.related) {
                        for (const relatedCategory of hierarchy.related) {
                            if (scores.has(relatedCategory)) {
                                const relatedScore = scores.get(relatedCategory);
                                if (relatedScore > 50) {
                                    bonus += relatedScore * 0.15; // 15% of related score
                                }
                            }
                        }
                    }
                }
                
                return bonus;
            }

            // Advanced decision making with multiple factors
            makeAdvancedDecision(scores, analysisDetails, contextFactors, article) {
                const sortedScores = Array.from(scores.entries()).sort((a, b) => b[1] - a[1]);
                
                let bestCategory = 'Society'; // Default fallback
                let bestScore = 0;
                let secondBestScore = 0;
                let confidence = 0;
                let aiEnhanced = false;
                let advancedAI = false;
                
                if (sortedScores.length >= 1) {
                    bestScore = sortedScores[0][1];
                    bestCategory = sortedScores[0][0];
                }
                if (sortedScores.length >= 2) {
                    secondBestScore = sortedScores[1][1];
                }
                
                const confidenceGap = bestScore - secondBestScore;
                const categoryData = this.categories[bestCategory];
                const categoryPriority = categoryData?.priority || 5;
                
                // Advanced confidence calculation
                confidence = Math.min(
                    (bestScore / 10) + 
                    (confidenceGap / 5) + 
                    (categoryPriority === 1 ? 20 : categoryPriority === 2 ? 15 : 10),
                    95
                );
                
                // AI enhancement detection
                if (confidenceGap < 50 || bestScore < 200) {
                    aiEnhanced = true;
                    bestCategory = this.applyAIFallbackLogic(article, sortedScores, contextFactors);
                }
                
                // Advanced AI detection (very sophisticated analysis)
                if (analysisDetails[bestCategory]?.confidenceFactors?.length >= 4) {
                    advancedAI = true;
                }
                
                // Semantic tags extraction
                const semanticTags = this.extractSemanticTags(article, bestCategory, analysisDetails);
                
                return {
                    category: bestCategory,
                    score: Math.round(bestScore),
                    confidence: Math.round(confidence),
                    aiEnhanced: aiEnhanced,
                    advancedAI: advancedAI,
                    analysis: analysisDetails[bestCategory],
                    semanticTags: semanticTags
                };
            }

            // AI fallback logic with advanced patterns
            applyAIFallbackLogic(article, sortedScores, contextFactors) {
                const title = article.title.toLowerCase();
                const domain = this.getDomain(article.url).toLowerCase();
                
                // Advanced pattern matching
                const advancedPatterns = {
                    'how to': 'Education',
                    'tutorial': 'Education',
                    'guide to': 'Education',
                    'introduction to': 'Education',
                    'getting started': 'Education',
                    'beginner': 'Education',
                    'learn': 'Education',
                    'startup': 'Business',
                    'entrepreneur': 'Business',
                    'founder': 'Business',
                    'investment': 'Business',
                    'funding': 'Business',
                    'ai': 'Artificial Intelligence',
                    'machine learning': 'Artificial Intelligence',
                    'neural network': 'Artificial Intelligence',
                    'climate change': 'Environment',
                    'global warming': 'Environment',
                    'sustainability': 'Environment',
                    'election': 'Politics',
                    'government': 'Politics',
                    'policy': 'Politics',
                    'research': 'Science',
                    'study': 'Science',
                    'experiment': 'Science'
                };
                
                for (const [pattern, category] of Object.entries(advancedPatterns)) {
                    if (title.includes(pattern)) {
                        console.log(`🤖 AI fallback: "${pattern}" → ${category}`);
                        return category;
                    }
                }
                
                // Domain-based fallbacks
                const domainFallbacks = {
                    'github.com': 'Technology',
                    'stackoverflow.com': 'Technology',
                    'medium.com': 'Technology',
                    'dev.to': 'Technology',
                    'arxiv.org': 'Science',
                    'nature.com': 'Science',
                    'nih.gov': 'Health',
                    'who.int': 'Health',
                    'ted.com': 'Education',
                    'coursera.org': 'Education',
                    'linkedin.com': 'Business',
                    'forbes.com': 'Business'
                };
                
                for (const [d, category] of Object.entries(domainFallbacks)) {
                    if (domain.includes(d)) {
                        console.log(`🤖 AI domain fallback: ${d} → ${category}`);
                        return category;
                    }
                }
                
                // Use highest confidence category from top 3
                const topCategories = sortedScores.slice(0, 3);
                for (const [category, score] of topCategories) {
                    const categoryData = this.categories[category];
                    if (categoryData?.confidence === 'high' && score > 50) {
                        console.log(`🤖 AI confidence fallback: ${category}`);
                        return category;
                    }
                }
                
                return sortedScores[0][0]; // Default to best score
            }

            // Extract semantic tags for enhanced categorization
            extractSemanticTags(article, category, analysisDetails) {
                const tags = [];
                const analysis = analysisDetails[category];
                
                if (analysis?.confidenceFactors?.includes('domain_match')) {
                    tags.push('domain-verified');
                }
                if (analysis?.confidenceFactors?.includes('topic_modeling')) {
                    tags.push('topic-clustered');
                }
                if (analysis?.confidenceFactors?.includes('semantic_analysis')) {
                    tags.push('semantic-enhanced');
                }
                if (analysis?.score > 300) {
                    tags.push('high-confidence');
                }
                
                return tags;
            }

            // Semantic similarity check (simple implementation)
            areSemanticallySimilar(word1, word2) {
                // Simple similarity based on common roots and patterns
                const synonyms = {
                    'tech': ['technology', 'technical'],
                    'ai': ['artificial intelligence', 'machine learning'],
                    'dev': ['development', 'developer'],
                    'biz': ['business'],
                    'sci': ['science', 'scientific'],
                    'med': ['medical', 'medicine'],
                    'edu': ['education', 'educational']
                };
                
                for (const [root, variants] of Object.entries(synonyms)) {
                    if ((word1.includes(root) || variants.some(v => word1.includes(v))) &&
                        (word2.includes(root) || variants.some(v => word2.includes(v)))) {
                        return true;
                    }
                }
                
                return false;
            }

            // Analyze overall context
            analyzeContext(article, domain, title, content) {
                return {
                    domain: domain,
                    titleLength: title.length,
                    contentLength: content.length,
                    hasNumbers: /\d/.test(title),
                    hasQuestionMark: title.includes('?'),
                    isUpperCase: title === title.toUpperCase(),
                    wordCount: content.split(/\s+/).length
                };
            }

            // Get article content for analysis
            getArticleContentForAnalysis(article) {
                const contentFields = ['content', 'textContent', 'excerpt', 'description', 'summary', 'fullContent', 'body'];
                let combinedContent = '';
                
                for (const field of contentFields) {
                    if (article[field] && typeof article[field] === 'string') {
                        combinedContent += ' ' + article[field];
                    }
                }
                
                return combinedContent.trim() || article.title || '';
            }

            // Get domain from URL
            getDomain(url) {
                try {
                    return new URL(url).hostname.replace('www.', '');
                } catch (e) {
                    return url;
                }
            }
        }

        // Main Enhanced MyPocket Web Reader class
        class MyPocketWebReader {
            constructor() {
                console.log('🏗️ Creating Advanced AI MyPocketWebReader instance...');

                this.clientId = '436e8796-8c40-47c3-9ad5-b8882f3ef7f7';
                this.redirectUri = this.getRedirectUri();
                console.log('🔵 Redirect URI:', this.redirectUri);

                this.accessToken = null;
                this.articles = [];
                this.currentArticle = null;
                this.currentDisplayedArticles = [];
                this.failedImages = new Set();

                // Advanced AI categorization system
                this.aiEngine = new AdvancedAICategorizationEngine();
                this.categories = new Map();
                this.activeCategory = null;
                this.categoryAnalytics = new Map();
                this.aiCategoriesEnabled = true;
                this.semanticSearchEnabled = false;
                this.advancedAIMode = true;

                // Image cache system
                this.imageCache = new Map();
                this.cacheKey = 'mypocket_image_cache';
                this.cacheExpiryDays = 7;
                this.storeImagesInBackup = true;
                this.maxImageSizeKB = 500;
                this.cacheSaveTimeout = null;

                // PKCE-specific properties
                this.codeVerifier = null;
                this.codeChallenge = null;
                this.state = null;

                console.log('✅ Advanced AI MyPocketWebReader constructor complete');
                this.init();
            }

            getRedirectUri() {
                const currentUrl = window.location.href;
                const baseUrl = currentUrl.split('#')[0].split('?')[0];

                if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {
                    return baseUrl;
                } else {
                    return window.location.origin + window.location.pathname;
                }
            }

            init() {
                console.log('🚀 Initializing Advanced AI MyPocket Web Reader...');
                this.setupEventListeners();
                this.checkAuthFromURL();
                this.loadStoredToken();
                this.loadThemePreference();
                this.loadImageCache();
                this.initializeSidebar();
                console.log('✅ Advanced AI initialization complete');
            }

            setupEventListeners() {
                console.log('🔧 Setting up event listeners...');

                const connectBtnSidebar = document.getElementById('connectBtnSidebar');
                if (connectBtnSidebar) {
                    connectBtnSidebar.addEventListener('click', () => {
                        console.log('🔐 Connect button clicked');
                        this.authenticate();
                    });
                    console.log('✅ Connect button event listener added');
                } else {
                    console.error('❌ Connect button not found!');
                }

                const refreshNavBtn = document.getElementById('refreshNavBtn');
                if (refreshNavBtn) {
                    refreshNavBtn.addEventListener('click', () => this.loadArticles());
                }

                const syncNavBtn = document.getElementById('syncNavBtn');
                if (syncNavBtn) {
                    syncNavBtn.addEventListener('click', () => this.forceSyncImages());
                }

                const retryNavBtn = document.getElementById('retryNavBtn');
                if (retryNavBtn) {
                    retryNavBtn.addEventListener('click', () => this.retryFailedImages());
                }

                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => this.searchArticles(e.target.value));
                }

                const closeReader = document.getElementById('closeReader');
                if (closeReader) {
                    closeReader.addEventListener('click', () => this.closeReader());
                }

                const openOriginal = document.getElementById('openOriginal');
                if (openOriginal) {
                    openOriginal.addEventListener('click', () => this.openOriginal());
                }

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                        e.preventDefault();
                        this.toggleSearch(true);
                    } else if (e.key === '/' && !this.isInputFocused()) {
                        e.preventDefault();
                        this.toggleSearch(true);
                    } else if (e.key === 'Escape') {
                        this.toggleSearch(false);
                        this.toggleCategoryFilter(false);
                        this.closeMobileSidebar();
                    }
                });

                // Close panels when clicking outside
                document.addEventListener('click', (e) => {
                    const searchContainer = document.getElementById('searchContainer');
                    const searchNavBtn = document.getElementById('searchNavBtn');
                    const categoryContainer = document.getElementById('categoryContainer');
                    const categoriesNavBtn = document.getElementById('categoriesNavBtn');

                    if (searchContainer && searchNavBtn &&
                        searchContainer.style.display !== 'none' &&
                        !searchContainer.contains(e.target) &&
                        !searchNavBtn.contains(e.target)) {
                        this.toggleSearch(false);
                    }

                    if (categoryContainer && categoriesNavBtn &&
                        categoryContainer.style.display !== 'none' &&
                        !categoryContainer.contains(e.target) &&
                        !categoriesNavBtn.contains(e.target)) {
                        this.toggleCategoryFilter(false);
                    }
                });

                this.setupMobileMenu();
                console.log('✅ Event listeners setup complete');
            }

            // Initialize sidebar functionality
            initializeSidebar() {
                this.sidebarCollapsed = false;
                this.updateSidebarState();
                this.updateMobileMenu();
                this.updateArticleCounts();
            }

            // Update article counts in sidebar
            updateArticleCounts() {
                const allArticlesBadge = document.getElementById('allArticlesBadge');
                const categoryBadge = document.getElementById('categoryBadge');

                if (allArticlesBadge) {
                    allArticlesBadge.textContent = this.articles.length;
                }

                if (categoryBadge) {
                    categoryBadge.textContent = this.categories.size;
                }
            }

            // Setup mobile menu
            setupMobileMenu() {
                const mobileMenuBtn = document.getElementById('mobileMenuBtn');
                const isMobile = window.innerWidth <= 768;

                if (mobileMenuBtn) {
                    if (isMobile) {
                        mobileMenuBtn.style.display = 'flex';
                    } else {
                        mobileMenuBtn.style.display = 'none';
                    }
                }

                window.addEventListener('resize', () => {
                    this.updateMobileMenu();
                });
            }

            updateMobileMenu() {
                const mobileMenuBtn = document.getElementById('mobileMenuBtn');
                const isMobile = window.innerWidth <= 768;

                if (mobileMenuBtn) {
                    if (isMobile) {
                        mobileMenuBtn.style.display = 'flex';
                    } else {
                        mobileMenuBtn.style.display = 'none';
                        this.closeMobileSidebar();
                    }
                }
            }

            // Sidebar toggle functionality
            toggleSidebar() {
                this.sidebarCollapsed = !this.sidebarCollapsed;
                this.updateSidebarState();
            }

            updateSidebarState() {
                const sidebar = document.getElementById('sidebar');
                const mainContent = document.getElementById('mainContent');
                const toggleIcon = document.getElementById('sidebarToggleIcon');

                if (sidebar && mainContent && toggleIcon) {
                    if (this.sidebarCollapsed) {
                        sidebar.classList.add('collapsed');
                        mainContent.classList.add('sidebar-collapsed');
                        toggleIcon.textContent = '▶';
                    } else {
                        sidebar.classList.remove('collapsed');
                        mainContent.classList.remove('sidebar-collapsed');
                        toggleIcon.textContent = '◀';
                    }
                }
            }

            // Mobile sidebar functionality
            openMobileSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebarOverlay');

                if (sidebar) sidebar.classList.add('open');
                if (overlay) overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            }

            closeMobileSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebarOverlay');

                if (sidebar) sidebar.classList.remove('open');
                if (overlay) overlay.classList.remove('active');
                document.body.style.overflow = 'auto';
            }

            // Show all articles
            showAllArticles() {
                this.activeCategory = null;

                const searchInput = document.getElementById('searchInput');
                if (searchInput && searchInput.value) {
                    searchInput.value = '';
                }

                this.toggleSearch(false);
                this.toggleCategoryFilter(false);

                this.currentDisplayedArticles = this.articles;
                this.displayArticles(this.articles);
                this.updateNavigation();

                this.updateStatus(`📖 Showing all ${this.articles.length} articles with Advanced AI categorization`, 'success');
            }

            // Update navigation active states
            updateNavigation() {
                document.querySelectorAll('.nav-item').forEach(item => {
                    if (item) item.classList.remove('active');
                });

                const searchContainer = document.getElementById('searchContainer');
                const categoryContainer = document.getElementById('categoryContainer');
                const allArticlesNav = document.getElementById('allArticlesNav');
                const searchNavBtn = document.getElementById('searchNavBtn');
                const categoriesNavBtn = document.getElementById('categoriesNavBtn');

                if (!this.activeCategory && (!searchContainer || !searchContainer.classList.contains('visible'))) {
                    if (allArticlesNav) allArticlesNav.classList.add('active');
                } else if (searchContainer && searchContainer.classList.contains('visible')) {
                    if (searchNavBtn) searchNavBtn.classList.add('active');
                } else if (categoryContainer && categoryContainer.classList.contains('visible')) {
                    if (categoriesNavBtn) categoriesNavBtn.classList.add('active');
                }
            }

            isInputFocused() {
                const activeElement = document.activeElement;
                return activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');
            }

            // Advanced AI Analysis - NEW FEATURE
            async runAdvancedAIAnalysis() {
                if (this.articles.length === 0) {
                    this.updateStatus('❌ No articles to analyze. Load articles first.', 'error');
                    return;
                }

                console.log('🧠 Starting Advanced AI Analysis...');
                this.updateStatus('🧠 Running Advanced AI Analysis with semantic understanding...', 'ai-processing');

                this.categories.clear();
                this.categoryAnalytics.clear();

                let analyzedCount = 0;
                let advancedAICount = 0;
                let semanticTagsFound = 0;

                const batchSize = 5;
                for (let i = 0; i < this.articles.length; i += batchSize) {
                    const batch = this.articles.slice(i, i + batchSize);

                    for (const article of batch) {
                        const category = this.aiEngine.categorizeWithAdvancedAI(article);
                        this.categories.set(category, (this.categories.get(category) || 0) + 1);
                        analyzedCount++;

                        if (article.advancedAI) {
                            advancedAICount++;
                        }
                        if (article.semanticTags && article.semanticTags.length > 0) {
                            semanticTagsFound++;
                        }

                        this.updateCategoryAnalytics(category, article.categoryScore || 0, article.aiEnhanced || false, article.advancedAI || false);
                    }

                    const progress = Math.round((analyzedCount / this.articles.length) * 100);
                    this.updateStatus(`🧠 Advanced AI analyzing... ${analyzedCount}/${this.articles.length} (${progress}%)`, 'ai-processing');

                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                console.log(`🎯 Advanced AI analysis complete: ${this.categories.size} categories, ${advancedAICount} advanced AI enhanced`);

                this.updateCategoryUI();
                this.displayArticles(this.currentDisplayedArticles);
                this.updateArticleCounts();

                const message = `🧠 Advanced AI Analysis Complete! ${analyzedCount} articles analyzed, ${this.categories.size} categories found, ${advancedAICount} advanced AI enhanced, ${semanticTagsFound} with semantic tags`;
                this.updateStatus(message, 'success');

                if (this.accessToken) {
                    try {
                        await this.updateOneDriveBackup();
                        console.log('✅ Updated backup with Advanced AI analysis');
                    } catch (error) {
                        console.error('⚠️ Failed to update backup:', error);
                    }
                }
            }

            // Toggle semantic search - NEW FEATURE
            toggleSemanticSearch() {
                this.semanticSearchEnabled = !this.semanticSearchEnabled;
                
                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                    if (this.semanticSearchEnabled) {
                        searchInput.placeholder = "🧠 Semantic search active! Try: 'learning about AI' or 'business growth strategies'";
                        this.updateStatus('🧠 Semantic search enabled - Search understands context and meaning!', 'success');
                    } else {
                        searchInput.placeholder = "🧠 Advanced AI-powered semantic search... (Try: 'machine learning tutorials' or 'startup funding advice')";
                        this.updateStatus('🔍 Regular search active', 'success');
                    }
                }
                
                // Update button state
                const semanticSearchBtn = document.getElementById('semanticSearchBtn');
                if (semanticSearchBtn) {
                    if (this.semanticSearchEnabled) {
                        semanticSearchBtn.classList.add('active');
                    } else {
                        semanticSearchBtn.classList.remove('active');
                    }
                }
            }

            // Enhanced categorization with new AI engine
            categorizeArticle(article) {
                return this.aiEngine.categorizeWithAdvancedAI(article);
            }

            // Update category analytics with advanced metrics
            updateCategoryAnalytics(category, score, aiEnhanced, advancedAI = false) {
                if (!this.categoryAnalytics.has(category)) {
                    this.categoryAnalytics.set(category, {
                        count: 0,
                        totalScore: 0,
                        aiEnhanced: 0,
                        advancedAI: 0,
                        avgScore: 0,
                        confidence: 0
                    });
                }

                const analytics = this.categoryAnalytics.get(category);
                analytics.count++;
                analytics.totalScore += score;
                analytics.avgScore = Math.round(analytics.totalScore / analytics.count);
                if (aiEnhanced) analytics.aiEnhanced++;
                if (advancedAI) analytics.advancedAI++;
                analytics.confidence = Math.min(analytics.avgScore / 3, 100);

                this.categoryAnalytics.set(category, analytics);
            }

            // Enhanced category UI with advanced AI indicators
            updateCategoryUI() {
                const categoryChips = document.getElementById('categoryChips');
                const aiStats = document.getElementById('aiStats');
                
                if (!categoryChips) return;

                const sortedCategories = Array.from(this.categories.entries())
                    .sort((a, b) => b[1] - a[1]);

                const totalArticles = this.articles.length;
                const aiEnhancedTotal = this.articles.filter(a => a.aiEnhanced).length;
                const advancedAITotal = this.articles.filter(a => a.advancedAI).length;
                const semanticTagsTotal = this.articles.filter(a => a.semanticTags && a.semanticTags.length > 0).length;

                console.log(`🎨 Updating Advanced AI category UI with ${sortedCategories.length} categories`);

                if (aiStats) {
                    aiStats.textContent = `${sortedCategories.length} categories • ${aiEnhancedTotal} AI enhanced • ${advancedAITotal} advanced AI • ${semanticTagsTotal} semantic tags`;
                }

                categoryChips.innerHTML = `
                    <div class="category-chip show-all ${!this.activeCategory ? 'active' : ''}" 
                         data-category="null">
                        <span>🧠</span>
                        <span>All Articles</span>
                        <span class="category-count">${totalArticles}</span>
                    </div>
                    ${sortedCategories.map(([category, count]) => {
                    const categoryData = this.aiEngine.categories[category] || { icon: '📄' };
                    const isActive = this.activeCategory === category;
                    const analytics = this.categoryAnalytics.get(category);
                    const aiEnhancedCount = analytics ? analytics.aiEnhanced : 0;
                    const advancedAICount = analytics ? analytics.advancedAI : 0;
                    const avgScore = analytics ? analytics.avgScore : 0;
                    const confidence = analytics ? analytics.confidence : 0;
                    
                    let chipClass = 'category-chip';
                    if (isActive) chipClass += ' active';
                    if (aiEnhancedCount > 0) chipClass += ' ai-enhanced';
                    if (advancedAICount > 0) chipClass += ' advanced-ai';

                    return `
                            <div class="${chipClass}" 
                                 data-category="${category}"
                                 title="Show ${count} ${category.toLowerCase()} articles (${aiEnhancedCount} AI enhanced, ${advancedAICount} advanced AI, avg score: ${avgScore}, confidence: ${confidence}%)">
                                <span>${categoryData.icon}</span>
                                <span>${category}</span>
                                <span class="category-count">${count}</span>
                                ${advancedAICount > 0 ? '<span class="ai-indicator">🧠</span>' : ''}
                            </div>
                        `;
                }).join('')}
                `;

                categoryChips.querySelectorAll('.category-chip').forEach(chip => {
                    chip.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const category = chip.getAttribute('data-category');
                        console.log(`🖱️ Category chip clicked: "${category}"`);
                        this.filterByCategory(category === 'null' ? null : category);
                    });
                });

                console.log(`✅ Advanced AI category UI updated with event listeners`);
            }

            // Toggle category filter visibility
            toggleCategoryFilter(forceState = null) {
                const categoryContainer = document.getElementById('categoryContainer');
                const categoriesNavBtn = document.getElementById('categoriesNavBtn');

                if (!categoryContainer || !categoriesNavBtn) {
                    console.error('Category filter elements not found');
                    return;
                }

                const isCurrentlyVisible = categoryContainer.style.display !== 'none';
                const shouldShow = forceState !== null ? forceState : !isCurrentlyVisible;

                if (shouldShow) {
                    console.log('🏷️ Opening Advanced AI category filter...');

                    if (this.articles.length > 0 && this.categories.size === 0) {
                        this.runAdvancedAIAnalysis();
                    }

                    categoryContainer.style.display = 'block';
                    setTimeout(() => {
                        categoryContainer.classList.add('visible');
                    }, 10);

                    this.updateNavigation();
                    this.updateStatus('🧠 Advanced AI category filter active - Click a category to filter articles', 'success');
                } else {
                    console.log('🏷️ Closing category filter...');

                    categoryContainer.classList.remove('visible');
                    setTimeout(() => {
                        if (!categoryContainer.classList.contains('visible')) {
                            categoryContainer.style.display = 'none';
                        }
                    }, 300);

                    if (this.activeCategory) {
                        console.log('🏷️ Clearing active category filter');
                        this.filterByCategory(null);
                    }

                    this.updateNavigation();
                }
            }

            // Filter articles by category
            filterByCategory(category) {
                console.log(`🎯 FILTERING BY CATEGORY: "${category}"`);
                this.activeCategory = category;

                let filtered;
                if (!category) {
                    filtered = this.articles;
                    console.log(`📂 Showing all ${filtered.length} articles`);
                } else {
                    console.log(`🔍 Ensuring all articles are categorized before filtering...`);
                    this.articles.forEach((article, index) => {
                        if (!article.category) {
                            this.categorizeArticle(article);
                            console.log(`📂 Article ${index}: "${article.title.substring(0, 30)}..." categorized as "${article.category}"`);
                        }
                    });

                    filtered = this.articles.filter(article => {
                        const matches = article.category === category;
                        if (matches) {
                            console.log(`✅ MATCH: "${article.title.substring(0, 30)}..." is in category "${category}"`);
                        }
                        return matches;
                    });

                    console.log(`🎯 Found ${filtered.length} articles in category "${category}"`);
                }

                this.currentDisplayedArticles = filtered;
                this.displayArticles(filtered);
                this.updateCategoryUI();
                this.updateNavigation();

                if (!category) {
                    this.updateStatus(`📂 Showing all ${filtered.length} articles`, 'success');
                } else {
                    const categoryData = this.aiEngine.categories[category] || { icon: '📄' };
                    const analytics = this.categoryAnalytics.get(category);
                    const aiCount = analytics ? analytics.aiEnhanced : 0;
                    const advancedAICount = analytics ? analytics.advancedAI : 0;

                    if (filtered.length === 0) {
                        this.updateStatus(`❌ No articles found in "${category}" category. Try a different category.`, 'error');
                    } else {
                        const aiText = aiCount > 0 ? ` (${aiCount} AI enhanced, ${advancedAICount} advanced AI)` : '';
                        this.updateStatus(`${categoryData.icon} Showing ${filtered.length} ${category.toLowerCase()} articles${aiText}`, 'success');
                    }
                }

                console.log(`📂 Filter complete: ${filtered.length} articles displayed`);
            }

            // Show AI help
            showAIHelp() {
                const helpText = `
Advanced AI Categorization System Help:
=====================================

🧠 NEXT-GENERATION AI FEATURES:

1️⃣ ADVANCED AI CATEGORIZATION:
   • 20+ intelligent categories with semantic understanding
   • Multi-layered analysis: domain, title, content, context, relationships
   • Confidence scoring with advanced decision making
   • Topic modeling and clustering for better accuracy
   • Category hierarchy and relationship analysis

2️⃣ SEMANTIC UNDERSTANDING:
   • Context-aware pattern recognition
   • Advanced NLP-inspired techniques
   • Sentiment and opinion analysis
   • Tutorial and educational content detection
   • Research and academic content identification

3️⃣ ENHANCED CATEGORIES:
   📚 Core: Technology, Artificial Intelligence, Science, Business, Design
   🎯 Advanced: Politics, Philosophy, Psychology, Economics, Environment
   🌟 Specialized: Self-Development, Religion, History, Society
   📱 Lifestyle: Health, Sports, Travel, Food, Entertainment, Education

4️⃣ AI CONFIDENCE INDICATORS:
   • 🤖 AI Enhanced: Articles with ambiguous content resolved by AI
   • 🧠 Advanced AI: Multi-factor analysis with high confidence
   • Semantic tags for enhanced understanding
   • Confidence percentages and scoring metrics

5️⃣ ADVANCED FEATURES:
   • Advanced AI Analysis: Deep semantic understanding
   • Semantic Search: Context and meaning aware search
   • Category relationships and hierarchies
   • Cross-device synchronization with AI metadata
   • Real-time confidence and analytics tracking

🔍 SEMANTIC SEARCH:
   Enable semantic search to understand context and meaning:
   - "learning about AI" finds machine learning tutorials
   - "business growth strategies" finds startup and scaling content
   - "health and wellness tips" finds fitness and nutrition articles

🧠 AI ANALYSIS MODES:
   • Regular AI: Standard categorization with enhanced patterns
   • Advanced AI: Multi-layered semantic analysis with relationships
   • Topic Modeling: Clustering similar content for better accuracy
   • Context Analysis: Understanding article purpose and audience

💡 USAGE TIPS:
   - Use "Advanced AI Analysis" for most accurate categorization
   - Enable semantic search for better content discovery
   - Check AI indicators to understand categorization confidence
   - Advanced AI articles have the highest accuracy and context understanding

The system learns patterns from your content and continuously improves categorization accuracy with each analysis!
                `;

                alert(helpText);
            }

            // ===== PKCE IMPLEMENTATION =====

            generateCodeVerifier() {
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return this.base64URLEncode(array);
            }

            async generateCodeChallenge(codeVerifier) {
                const encoder = new TextEncoder();
                const data = encoder.encode(codeVerifier);
                const digest = await crypto.subtle.digest('SHA-256', data);
                return this.base64URLEncode(new Uint8Array(digest));
            }

            base64URLEncode(array) {
                return btoa(String.fromCharCode.apply(null, array))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            }

            generateState() {
                const array = new Uint8Array(16);
                crypto.getRandomValues(array);
                return this.base64URLEncode(array);
            }

            storePKCEParameters(codeVerifier, state) {
                sessionStorage.setItem('mypocket_code_verifier', codeVerifier);
                sessionStorage.setItem('mypocket_state', state);
                console.log('🔐 PKCE parameters stored securely');
            }

            retrievePKCEParameters() {
                const codeVerifier = sessionStorage.getItem('mypocket_code_verifier');
                const state = sessionStorage.getItem('mypocket_state');
                return { codeVerifier, state };
            }

            clearPKCEParameters() {
                sessionStorage.removeItem('mypocket_code_verifier');
                sessionStorage.removeItem('mypocket_state');
                console.log('🗑️ PKCE parameters cleared');
            }

            async authenticate() {
                console.log('🔐 Starting authentication process...');

                if (!this.redirectUri || (!this.redirectUri.startsWith('http://') && !this.redirectUri.startsWith('https://'))) {
                    const errorMsg = 'Invalid redirect URI. Please open this page via HTTP/HTTPS.';
                    console.error('🔴', errorMsg, 'Current URI:', this.redirectUri);
                    this.updateStatus(`❌ ${errorMsg}`, 'error');
                    alert(`Redirect URI Error:\n\nCurrent URI: ${this.redirectUri}\n\nPlease:\n1. Open this page via HTTP/HTTPS (not file://)\n2. Register this exact URI in Azure AD\n3. Use a web server to serve this file`);
                    return;
                }

                try {
                    this.updateStatus('🔐 Generating secure authentication parameters...', 'loading');
                    console.log('🔧 Generating PKCE parameters...');

                    this.codeVerifier = this.generateCodeVerifier();
                    this.codeChallenge = await this.generateCodeChallenge(this.codeVerifier);
                    this.state = this.generateState();

                    console.log('✅ PKCE parameters generated successfully');

                    this.storePKCEParameters(this.codeVerifier, this.state);

                    const authUrl = `https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize?` +
                        `client_id=${this.clientId}&` +
                        `response_type=code&` +
                        `redirect_uri=${encodeURIComponent(this.redirectUri)}&` +
                        `scope=${encodeURIComponent('Files.ReadWrite User.Read')}&` +
                        `state=${this.state}&` +
                        `code_challenge=${this.codeChallenge}&` +
                        `code_challenge_method=S256&` +
                        `response_mode=query`;

                    console.log('🔐 PKCE Auth URL generated');
                    this.updateStatus('🔄 Redirecting to secure Microsoft login...', 'loading');

                    setTimeout(() => {
                        console.log('🌐 Redirecting to Microsoft login...');
                        window.location.href = authUrl;
                    }, 1000);

                } catch (error) {
                    console.error('❌ PKCE generation error:', error);
                    this.updateStatus('❌ Error generating secure authentication. Please try again.', 'error');
                }
            }

            async checkAuthFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const state = urlParams.get('state');
                const error = urlParams.get('error');
                const errorDescription = urlParams.get('error_description');

                if (error) {
                    this.updateStatus(`❌ Authentication error: ${error} - ${errorDescription || 'Unknown error'}`, 'error');
                    this.clearPKCEParameters();
                    window.history.replaceState({}, document.title, window.location.pathname);
                    return;
                }

                if (code && state) {
                    try {
                        this.updateStatus('🔐 Exchanging authorization code for tokens...', 'loading');

                        const { codeVerifier, state: storedState } = this.retrievePKCEParameters();

                        if (!storedState || state !== storedState) {
                            throw new Error('State parameter mismatch. Possible CSRF attack.');
                        }

                        if (!codeVerifier) {
                            throw new Error('Code verifier not found. Please try authenticating again.');
                        }

                        const tokenResponse = await this.exchangeCodeForTokens(code, codeVerifier);

                        if (tokenResponse.access_token) {
                            console.log('✅ Token exchange successful');
                            this.accessToken = tokenResponse.access_token;
                            this.saveToken(tokenResponse.access_token);

                            if (tokenResponse.refresh_token) {
                                this.saveRefreshToken(tokenResponse.refresh_token);
                            }

                            console.log('🔄 Updating connection status...');
                            this.updateConnectionStatus(true);

                            console.log('📚 Loading articles...');
                            this.loadArticles();

                            this.clearPKCEParameters();
                            window.history.replaceState({}, document.title, window.location.pathname);

                            this.updateStatus('✅ Secure authentication successful!', 'success');
                        } else {
                            throw new Error('No access token received from authorization server');
                        }

                    } catch (error) {
                        console.error('❌ Token exchange error:', error);
                        this.updateStatus(`❌ Token exchange failed: ${error.message}`, 'error');
                        this.clearPKCEParameters();
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }
                }
            }

            async exchangeCodeForTokens(authorizationCode, codeVerifier) {
                const tokenEndpoint = 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                const tokenRequest = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        client_id: this.clientId,
                        scope: 'Files.ReadWrite User.Read',
                        code: authorizationCode,
                        redirect_uri: this.redirectUri,
                        grant_type: 'authorization_code',
                        code_verifier: codeVerifier
                    })
                };

                console.log('🔐 Exchanging authorization code for tokens...');

                const response = await fetch(tokenEndpoint, tokenRequest);

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Token exchange failed: ${errorData.error} - ${errorData.error_description}`);
                }

                const tokenData = await response.json();
                console.log('✅ Token exchange successful');

                return tokenData;
            }

            saveToken(token) {
                localStorage.setItem('mypocket_access_token', token);
                localStorage.setItem('mypocket_token_timestamp', Date.now().toString());
            }

            saveRefreshToken(refreshToken) {
                localStorage.setItem('mypocket_refresh_token', refreshToken);
            }

            getRefreshToken() {
                return localStorage.getItem('mypocket_refresh_token');
            }

            clearTokens() {
                localStorage.removeItem('mypocket_access_token');
                localStorage.removeItem('mypocket_refresh_token');
                localStorage.removeItem('mypocket_token_timestamp');
                this.accessToken = null;
            }

            async ensureValidToken() {
                if (!this.accessToken) {
                    return false;
                }

                const tokenTimestamp = localStorage.getItem('mypocket_token_timestamp');
                if (tokenTimestamp) {
                    const tokenAge = Date.now() - parseInt(tokenTimestamp);
                    const oneHour = 60 * 60 * 1000;

                    if (tokenAge > oneHour) {
                        console.log('🔄 Token expired, attempting refresh...');
                        const refreshSuccess = await this.refreshAccessToken();
                        if (!refreshSuccess) {
                            console.log('❌ Token refresh failed, need to re-authenticate');
                            return false;
                        }
                    }
                }

                return true;
            }

            async refreshAccessToken() {
                const refreshToken = this.getRefreshToken();
                if (!refreshToken) {
                    console.log('No refresh token available');
                    return false;
                }

                try {
                    const tokenEndpoint = 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                    const refreshRequest = {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: this.clientId,
                            scope: 'Files.ReadWrite User.Read',
                            refresh_token: refreshToken,
                            grant_type: 'refresh_token'
                        })
                    };

                    const response = await fetch(tokenEndpoint, refreshRequest);

                    if (!response.ok) {
                        console.log('Refresh token request failed');
                        return false;
                    }

                    const tokenData = await response.json();

                    if (tokenData.access_token) {
                        this.accessToken = tokenData.access_token;
                        this.saveToken(tokenData.access_token);

                        if (tokenData.refresh_token) {
                            this.saveRefreshToken(tokenData.refresh_token);
                        }

                        console.log('✅ Token refreshed successfully');
                        return true;
                    }

                    return false;

                } catch (error) {
                    console.error('Token refresh error:', error);
                    return false;
                }
            }

            loadStoredToken() {
                console.log('🔍 Loading stored token...');
                this.accessToken = localStorage.getItem('mypocket_access_token');
                if (this.accessToken) {
                    console.log('✅ Found stored token, updating connection status...');
                    this.updateConnectionStatus(true);
                    this.ensureValidToken().then(isValid => {
                        if (isValid) {
                            console.log('✅ Token is valid, loading articles...');
                            this.loadArticles();
                        } else {
                            console.log('❌ Token is invalid, updating connection status...');
                            this.updateConnectionStatus(false);
                            this.updateStatus('Stored token expired. Please reconnect.', 'error');
                        }
                    });
                } else {
                    console.log('ℹ️ No stored token found');
                }
            }

            updateConnectionStatus(connected) {
                const connectBtn = document.getElementById('connectBtnSidebar');
                const connectIcon = document.getElementById('connectionIcon');
                const connectText = document.getElementById('connectionText');
                const connectionStatusSidebar = document.getElementById('connectionStatusSidebar');

                if (connected) {
                    if (connectIcon) connectIcon.textContent = '✅';
                    if (connectText) connectText.textContent = 'Connected (Advanced AI)';
                    if (connectBtn) {
                        connectBtn.style.background = '#27ae60';
                        connectBtn.textContent = 'Connected ✅';
                    }
                    if (connectionStatusSidebar) {
                        connectionStatusSidebar.className = 'connection-status-sidebar connected';
                    }
                } else {
                    if (connectIcon) connectIcon.textContent = '🔐';
                    if (connectText) connectText.textContent = 'Not Connected';
                    if (connectBtn) {
                        connectBtn.style.background = '';
                        connectBtn.textContent = 'Secure Connect';
                    }
                    if (connectionStatusSidebar) {
                        connectionStatusSidebar.className = 'connection-status-sidebar disconnected';
                    }
                }
            }

            // Toggle search functionality
            toggleSearch(forceState = null) {
                const searchContainer = document.getElementById('searchContainer');
                const searchInput = document.getElementById('searchInput');
                const searchNavBtn = document.getElementById('searchNavBtn');

                if (!searchContainer || !searchInput || !searchNavBtn) {
                    console.error('Search elements not found');
                    return;
                }

                const isCurrentlyVisible = searchContainer.style.display !== 'none';
                const shouldShow = forceState !== null ? forceState : !isCurrentlyVisible;

                if (shouldShow) {
                    searchContainer.style.display = 'block';
                    setTimeout(() => {
                        searchContainer.classList.add('visible');
                        searchInput.focus();
                    }, 10);

                    this.updateNavigation();

                    const searchType = this.semanticSearchEnabled ? 'semantic' : 'AI-powered';
                    this.updateStatus(`🔍 ${searchType} search active - Type to search or press Escape to close`, 'success');
                } else {
                    searchContainer.classList.remove('visible');
                    setTimeout(() => {
                        if (!searchContainer.classList.contains('visible')) {
                            searchContainer.style.display = 'none';
                        }
                    }, 300);

                    if (searchInput.value) {
                        searchInput.value = '';
                        this.searchArticles('');
                    }

                    searchInput.blur();
                    this.updateNavigation();
                }
            }

            // Enhanced search with semantic understanding
            searchArticles(query) {
                if (this.activeCategory && query.trim() !== '') {
                    this.activeCategory = null;
                    this.updateCategoryUI();
                }

                if (!query || query.trim() === '') {
                    this.currentDisplayedArticles = this.articles;
                    this.displayArticles(this.articles);
                    if (this.articles.length > 0) {
                        this.updateStatus(`Showing all ${this.articles.length} articles`, 'success');
                    }
                    return;
                }

                const searchTerm = query.toLowerCase().trim();
                console.log(`🔍 ${this.semanticSearchEnabled ? 'Semantic' : 'Enhanced'} search for: "${searchTerm}"`);

                const filtered = this.articles.filter(article => {
                    if (this.semanticSearchEnabled) {
                        return this.semanticSearch(article, searchTerm);
                    } else {
                        return this.regularSearch(article, searchTerm);
                    }
                });

                console.log(`🎯 Search results: ${filtered.length}/${this.articles.length} articles`);

                this.currentDisplayedArticles = filtered;
                this.displayArticles(filtered);

                const searchType = this.semanticSearchEnabled ? 'Semantic' : 'Enhanced';
                if (filtered.length === 0) {
                    this.updateStatus(`🤖 No articles found matching "${query}". Try different keywords or enable semantic search.`, 'error');
                } else if (filtered.length === 1) {
                    this.updateStatus(`🔍 ${searchType} search found 1 article matching "${query}"`, 'success');
                } else {
                    this.updateStatus(`🔍 ${searchType} search found ${filtered.length} articles matching "${query}"`, 'success');
                }
            }

            // Regular enhanced search
            regularSearch(article, searchTerm) {
                const titleMatch = article.title && article.title.toLowerCase().includes(searchTerm);
                const excerptMatch = article.excerpt && article.excerpt.toLowerCase().includes(searchTerm);
                
                const contentFields = ['content', 'textContent', 'html', 'fullContent', 'body', 'readableContent'];
                const contentMatch = contentFields.some(field =>
                    article[field] && typeof article[field] === 'string' &&
                    article[field].toLowerCase().includes(searchTerm)
                );

                const authorMatch = article.author && article.author.toLowerCase().includes(searchTerm);
                const domainMatch = this.aiEngine.getDomain(article.url).toLowerCase().includes(searchTerm);
                const urlMatch = article.url && article.url.toLowerCase().includes(searchTerm);
                
                const tagsMatch = article.tags && Array.isArray(article.tags) &&
                    article.tags.some(tag => tag.toLowerCase().includes(searchTerm));

                if (!article.category) {
                    this.categorizeArticle(article);
                }
                const categoryMatch = article.category && article.category.toLowerCase().includes(searchTerm);

                // Enhanced: Semantic tags search
                const semanticTagsMatch = article.semanticTags && Array.isArray(article.semanticTags) &&
                    article.semanticTags.some(tag => tag.toLowerCase().includes(searchTerm));

                return titleMatch || excerptMatch || contentMatch || authorMatch || domainMatch || 
                       urlMatch || tagsMatch || categoryMatch || semanticTagsMatch;
            }

            // Advanced semantic search
            semanticSearch(article, searchTerm) {
                // Start with regular search
                if (this.regularSearch(article, searchTerm)) {
                    return true;
                }

                // Semantic understanding patterns
                const semanticPatterns = {
                    'learning': ['tutorial', 'guide', 'how to', 'education', 'course', 'lesson'],
                    'business growth': ['startup', 'scaling', 'expansion', 'revenue', 'growth hacking'],
                    'ai': ['artificial intelligence', 'machine learning', 'neural network', 'deep learning'],
                    'health tips': ['wellness', 'fitness', 'nutrition', 'exercise', 'healthy'],
                    'programming': ['coding', 'development', 'software', 'algorithm', 'debugging'],
                    'investment': ['finance', 'funding', 'venture capital', 'stocks', 'trading'],
                    'productivity': ['efficiency', 'time management', 'workflow', 'optimization'],
                    'innovation': ['technology', 'breakthrough', 'research', 'discovery', 'advancement']
                };

                // Check semantic patterns
                for (const [pattern, synonyms] of Object.entries(semanticPatterns)) {
                    if (searchTerm.includes(pattern)) {
                        for (const synonym of synonyms) {
                            if (this.regularSearch(article, synonym)) {
                                console.log(`🧠 Semantic match: "${pattern}" → "${synonym}"`);
                                return true;
                            }
                        }
                    }
                }

                // Context-aware category matching
                if (!article.category) {
                    this.categorizeArticle(article);
                }

                const categoryKeywords = this.aiEngine.categories[article.category]?.keywords || [];
                const searchWords = searchTerm.split(/\s+/);
                
                let semanticScore = 0;
                for (const searchWord of searchWords) {
                    for (const keyword of categoryKeywords) {
                        if (keyword.includes(searchWord) || searchWord.includes(keyword)) {
                            semanticScore++;
                        }
                    }
                }

                // Return true if semantic score is high enough
                return semanticScore >= Math.min(searchWords.length, 2);
            }

            // Load articles with advanced AI processing
            async loadArticles() {
                const hasValidToken = await this.ensureValidToken();
                if (!hasValidToken) {
                    this.updateConnectionStatus(false);
                    this.updateStatus('Authentication expired. Please reconnect.', 'error');
                    return;
                }

                try {
                    this.updateStatus('Loading articles with Advanced AI categorization... ⏳', 'loading');

                    const listResponse = await fetch('https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket:/children', {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!listResponse.ok) {
                        if (listResponse.status === 401) {
                            const refreshSuccess = await this.refreshAccessToken();
                            if (refreshSuccess) {
                                return this.loadArticles();
                            } else {
                                this.clearTokens();
                                this.updateConnectionStatus(false);
                                this.updateStatus('Session expired. Please reconnect.', 'error');
                                return;
                            }
                        }
                        throw new Error(`Failed to list files: ${listResponse.status}`);
                    }

                    const fileList = await listResponse.json();
                    const backupFiles = fileList.value.filter(file =>
                        file.name.startsWith('mypocket-backup-') && file.name.endsWith('.json')
                    );

                    if (backupFiles.length === 0) {
                        this.updateStatus('No backup files found. Save some articles with the browser extension first.', 'error');
                        this.displayEmptyState();
                        return;
                    }

                    const latestFile = backupFiles.sort((a, b) =>
                        new Date(b.lastModifiedDateTime) - new Date(a.lastModifiedDateTime)
                    )[0];

                    const downloadResponse = await fetch(`https://graph.microsoft.com/v1.0/me/drive/items/${latestFile.id}/content`, {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`
                        }
                    });

                    if (!downloadResponse.ok) {
                        throw new Error(`Failed to download backup: ${downloadResponse.status}`);
                    }

                    const backupContent = await downloadResponse.text();
                    const backup = JSON.parse(backupContent);

                    this.articles = backup.articles || [];
                    this.currentDisplayedArticles = this.articles;

                    console.log('🧠 Starting Advanced AI auto-categorization on load...');
                    this.updateStatus('🧠 Advanced AI is analyzing your articles...', 'ai-processing');

                    // Process with advanced AI in background
                    setTimeout(async () => {
                        await this.runAdvancedAIAnalysis();
                        this.updateArticleCounts();
                        this.displayArticles(this.articles);

                        const cacheStats = this.getCacheStats();
                        const storedImages = this.articles.filter(a => a.cachedImage).length;
                        const aiEnhancedCount = this.articles.filter(a => a.aiEnhanced).length;
                        const advancedAICount = this.articles.filter(a => a.advancedAI).length;

                        this.updateStatus(`🧠 Loaded ${this.articles.length} articles with Advanced AI (${storedImages} with stored images, ${aiEnhancedCount} AI enhanced, ${advancedAICount} advanced AI)`, 'success');
                    }, 100);

                } catch (error) {
                    console.error('Error loading articles:', error);
                    this.updateStatus(`Error loading articles: ${error.message}`, 'error');
                }
            }

            displayEmptyState() {
                const container = document.getElementById('articlesContainer');
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">🧠</div>
                        <h3>No articles found</h3>
                        <p>Use the MyPocket browser extension to save articles, then refresh this page for Advanced AI categorization with 20+ intelligent categories!</p>
                    </div>`;
            }

            // Enhanced display with advanced AI indicators
            displayArticles(articles) {
                const container = document.getElementById('articlesContainer');

                if (articles.length === 0) {
                    this.displayEmptyState();
                    return;
                }

                this.currentDisplayedArticles = articles;
                const isMobile = window.innerWidth <= 768;

                let imagesFromBackup = 0;
                let imagesFromCache = 0;
                let imagesNeedLoading = 0;

                console.log('🎯 DISPLAYING ARTICLES WITH ADVANCED AI - Image Source Priority Check:');

                const articlesHTML = articles.map((article, displayIndex) => {
                    const index = displayIndex;

                    let imageHTML = '';
                    let cacheStatus = 'loading';
                    let statusText = '🔄 Loading';
                    let imageSource = 'none';

                    // Image priority logic (same as before)
                    if (article.cachedImage && article.cachedImage.base64) {
                        imageHTML = this.createImageHTML(article.cachedImage.base64, true);
                        cacheStatus = 'synced';
                        statusText = '🌐 Synced';
                        imageSource = 'synced_base64';
                        imagesFromBackup++;
                    } else if (article.cachedImage && article.cachedImage.url && !article.cachedImage.base64) {
                        imageHTML = this.createImageHTML(article.cachedImage.url, true);
                        cacheStatus = 'synced';
                        statusText = '🔗 Synced URL';
                        imageSource = 'synced_url';
                        imagesFromBackup++;
                    } else if (this.getCachedImage(article)) {
                        imageHTML = this.createImageHTML(this.getCachedImage(article), true);
                        cacheStatus = 'cached';
                        statusText = '💾 Local Cache';
                        imageSource = 'local_cache';
                        imagesFromCache++;
                    } else if (this.getBestArticleImage(article)) {
                        const savedImage = this.getBestArticleImage(article);
                        imageHTML = this.createImageHTML(savedImage, false);
                        cacheStatus = 'metadata';
                        statusText = '📄 Metadata';
                        imageSource = 'metadata';
                        setTimeout(() => this.setArticleImageAndCache(article, index, savedImage, 'saved'), 100);
                    } else {
                        imageHTML = this.createPlaceholderHTML();
                        cacheStatus = 'loading';
                        statusText = isMobile ? '📱 Loading...' : '🔄 Loading';
                        imageSource = 'needs_extraction';
                        imagesNeedLoading++;
                    }

                    // Enhanced AI indicators
                    let cardClass = 'article-card';
                    if (article.aiEnhanced) cardClass += ' ai-categorized';
                    if (article.advancedAI) cardClass += ' advanced-ai';

                    // Enhanced category badge
                    const categoryData = this.aiEngine.categories[article.category] || { icon: '📄' };
                    let categoryClass = 'article-category';
                    if (article.aiEnhanced) categoryClass += ' ai-category';
                    if (article.advancedAI) categoryClass += ' advanced-ai-category';

                    const categoryBadge = article.category ? `
                        <div class="${categoryClass}">
                            <span>${categoryData.icon}</span>
                            <span>${article.category}</span>
                            ${article.aiEnhanced ? '<span>🤖</span>' : ''}
                            ${article.advancedAI ? '<span>🧠</span>' : ''}
                            ${article.categoryConfidence ? `<span class="ai-confidence">${article.categoryConfidence}%</span>` : ''}
                        </div>
                    ` : '';

                    // Enhanced cache indicator
                    let indicatorClass = `cache-indicator ${cacheStatus}`;
                    if (article.aiEnhanced) indicatorClass += ' ai-categorized';
                    if (article.advancedAI) indicatorClass += ' advanced-ai';

                    return `
                    <div class="${cardClass}" data-index="${index}" data-display-index="${displayIndex}" data-image-source="${imageSource}">
                        <div class="article-image" id="image-${index}">
                            ${imageHTML}
                            <div class="${indicatorClass}">
                                ${statusText}
                            </div>
                        </div>
                        <div class="article-content" onclick="webReader.openReaderByDisplayIndex(${displayIndex})">
                            ${categoryBadge}
                            <h2 class="article-title">${this.escapeHtml(article.title)}</h2>
                            <p class="article-excerpt">${this.escapeHtml(article.excerpt)}</p>
                            <div class="article-meta">
                                <span class="article-domain">🌐 ${this.aiEngine.getDomain(article.url)}</span>
                                <span class="article-date">📅 ${this.formatDate(article.dateAdded)}</span>
                            </div>
                            <div class="article-stats">
                                <span>⏱️ ${article.readTime || 1} min read</span>
                                <span>📝 ${article.wordCount || 0} words</span>
                                ${article.categoryScore ? `<span>🧠 ${article.categoryScore}</span>` : ''}
                                ${article.semanticTags ? `<span>🏷️ ${article.semanticTags.length}</span>` : ''}
                            </div>
                        </div>
                        <div class="article-actions">
                            <button class="action-btn read-btn" onclick="event.stopPropagation(); webReader.openReaderByDisplayIndex(${displayIndex})" title="Read article">
                                📖
                            </button>
                            <button class="action-btn refresh-image-btn" onclick="event.stopPropagation(); webReader.refreshSingleImage(${index}, ${displayIndex})" title="Refresh this image">
                                🖼️
                            </button>
                            <button class="action-btn export-btn" onclick="event.stopPropagation(); webReader.exportArticleByDisplayIndex(${displayIndex})" title="Export article">
                                📤
                            </button>
                            <button class="action-btn delete-btn" onclick="event.stopPropagation(); webReader.deleteArticleByDisplayIndex(${displayIndex})" title="Delete article">
                                🗑️
                            </button>
                        </div>
                    </div>
                `}).join('');

                container.innerHTML = `<div class="articles-grid">${articlesHTML}</div>`;

                // Enhanced status reporting
                const totalReady = imagesFromBackup + imagesFromCache;
                const aiEnhancedCount = articles.filter(a => a.aiEnhanced).length;
                const advancedAICount = articles.filter(a => a.advancedAI).length;

                console.log(`📊 IMAGE SUMMARY: ${imagesFromBackup} synced, ${imagesFromCache} cached, ${imagesNeedLoading} need loading`);
                console.log(`🧠 ADVANCED AI SUMMARY: ${aiEnhancedCount}/${articles.length} AI enhanced, ${advancedAICount}/${articles.length} advanced AI`);

                if (imagesNeedLoading === 0) {
                    const aiText = aiEnhancedCount > 0 ? ` (${aiEnhancedCount} AI enhanced, ${advancedAICount} advanced AI)` : '';
                    const message = isMobile ?
                        `📱 ALL images ready! ${totalReady}/${articles.length} synced perfectly ✨${aiText}` :
                        `✅ ALL images ready! ${imagesFromBackup} synced, ${imagesFromCache} cached ✨${aiText}`;
                    this.updateStatus(message, 'success');
                } else {
                    const aiText = aiEnhancedCount > 0 ? ` (${aiEnhancedCount} AI categorized, ${advancedAICount} advanced AI)` : '';
                    const message = isMobile ?
                        `📱 ${totalReady} ready instantly, extracting ${imagesNeedLoading} more...${aiText}` :
                        `⚡ ${totalReady} ready instantly, extracting ${imagesNeedLoading} more...${aiText}`;
                    this.updateStatus(message, 'loading');

                    if (isMobile) {
                        setTimeout(() => this.loadMissingImages(articles), 500);
                    } else {
                        this.loadMissingImages(articles);
                    }
                }
            }

            // Enhanced backup with advanced AI metadata
            async updateOneDriveBackup() {
                if (!this.accessToken) {
                    throw new Error('Not connected to OneDrive');
                }

                const articlesWithImages = this.articles.filter(a => a.cachedImage);
                const totalImageSizeKB = articlesWithImages.reduce((total, article) => {
                    return total + (article.cachedImage ? article.cachedImage.size || 0 : 0);
                }, 0);

                const aiEnhancedCount = this.articles.filter(a => a.aiEnhanced).length;
                const advancedAICount = this.articles.filter(a => a.advancedAI).length;
                const semanticTagsCount = this.articles.filter(a => a.semanticTags && a.semanticTags.length > 0).length;

                console.log(`📦 Creating backup with ${articlesWithImages.length} stored images (${Math.round(totalImageSizeKB)}KB) and ${advancedAICount} advanced AI articles`);

                const backup = {
                    articles: this.articles,
                    settings: {
                        storeImagesInBackup: this.storeImagesInBackup,
                        maxImageSizeKB: this.maxImageSizeKB,
                        aiCategoriesEnabled: this.aiCategoriesEnabled,
                        advancedAIMode: this.advancedAIMode,
                        semanticSearchEnabled: this.semanticSearchEnabled
                    },
                    aiAnalytics: Object.fromEntries(this.categoryAnalytics),
                    aiCategories: this.aiEngine.categories,
                    exportDate: new Date().toISOString(),
                    version: "6.0", // Advanced AI version
                    deviceInfo: {
                        browser: "Advanced AI Reader with 20+ Categories + PKCE Security + Cross-Device Images",
                        platform: navigator.platform,
                        timestamp: Date.now(),
                        articleCount: this.articles.length,
                        storedImages: articlesWithImages.length,
                        totalImageSizeKB: Math.round(totalImageSizeKB),
                        aiEnhancedArticles: aiEnhancedCount,
                        advancedAIArticles: advancedAICount,
                        semanticTagsCount: semanticTagsCount,
                        categoriesFound: this.categories.size,
                        authMethod: "Authorization Code + PKCE",
                        aiFeatures: "Advanced categorization engine with 20+ categories, semantic understanding, topic modeling, relationship analysis"
                    }
                };

                const fileName = `mypocket-backup-${new Date().toISOString().split('T')[0]}.json`;
                const fileContent = JSON.stringify(backup, null, 2);

                const backupSizeMB = fileContent.length / (1024 * 1024);
                if (backupSizeMB > 10) {
                    console.warn(`⚠️ Large backup detected: ${backupSizeMB.toFixed(1)}MB`);
                }

                const uploadUrl = `https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket/${fileName}:/content`;

                const uploadResponse = await fetch(uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${this.accessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: fileContent
                });

                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    throw new Error(`Failed to update OneDrive backup: ${uploadResponse.status} - ${errorText}`);
                }

                console.log(`✅ Advanced AI backup saved with ${articlesWithImages.length} images (${Math.round(totalImageSizeKB)}KB) and ${advancedAICount} advanced AI articles`);
                return await uploadResponse.json();
            }

            // All other methods remain the same but with enhanced status messages and AI indicators...
            // (Due to length constraints, I'll include the most important method signatures)

            updateStatus(message, type = '') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }

            // Image methods remain the same
            createImageHTML(imageUrl, fromCache = false) {
                return `
                    <img src="${imageUrl}" 
                         alt="Article image" 
                         style="opacity: 0; transition: opacity 0.8s ease; width: 100%; height: 100%; object-fit: cover;"
                         onload="this.style.opacity='1'; console.log('✅ Image loaded ${fromCache ? 'from cache' : 'successfully'}');" 
                         onerror="
                            console.log('⚠️ Image failed, tracking for retry');
                            const cardElement = this.closest('.article-card');
                            if (cardElement) {
                                const index = parseInt(cardElement.dataset.index);
                                if (!isNaN(index)) {
                                    webReader.failedImages.add(index);
                                    const indicator = this.parentElement.querySelector('.cache-indicator');
                                    if (indicator) {
                                        indicator.textContent = '❌ Failed';
                                        indicator.className = 'cache-indicator error';
                                    }
                                }
                            }
                            this.src='https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                         ">
                `;
            }

            createPlaceholderHTML() {
                return `
                    <div style="width: 100%; height: 100%; background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #f0f0f0 75%), linear-gradient(-45deg, transparent 75%, #f0f0f0 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px; display: flex; align-items: center; justify-content: center; color: #999; animation: shimmer 1.5s ease-in-out infinite;">
                        <div style="text-align: center;">
                            <div style="font-size: 1.2em; margin-bottom: 5px;">🖼️</div>
                            <div style="font-size: 0.7em;">Loading image...</div>
                        </div>
                    </div>
                `;
            }

            // Utility methods
            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            formatDate(dateString) {
                try {
                    const date = new Date(dateString);
                    if (isNaN(date.getTime())) return 'invalid date';

                    const now = new Date();
                    const diffMs = now.getTime() - date.getTime();
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

                    if (diffDays === 0) return 'today';
                    if (diffDays === 1) return 'yesterday';
                    if (diffDays <= 7) return `${diffDays} days ago`;
                    if (diffDays <= 30) return `${Math.floor(diffDays / 7)} weeks ago`;
                    if (diffDays <= 365) return `${Math.floor(diffDays / 30)} months ago`;
                    return `${Math.floor(diffDays / 365)} years ago`;
                } catch (error) {
                    return 'date error';
                }
            }

            // Dark mode functionality
            toggleDarkMode() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);

                this.updateDarkModeButton(newTheme);
                this.updateStatus(
                    newTheme === 'dark' ? '🌙 Dark mode enabled' : '☀️ Light mode enabled',
                    'success'
                );
            }

            loadThemePreference() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                document.documentElement.setAttribute('data-theme', savedTheme);
                this.updateDarkModeButton(savedTheme);
            }

            updateDarkModeButton(theme) {
                const darkModeIcon = document.getElementById('darkModeIcon');
                const darkModeText = document.getElementById('darkModeText');

                if (darkModeIcon && darkModeText) {
                    if (theme === 'dark') {
                        darkModeIcon.textContent = '☀️';
                        darkModeText.textContent = 'Light Mode';
                    } else {
                        darkModeIcon.textContent = '🌙';
                        darkModeText.textContent = 'Dark Mode';
                    }
                }
            }

            // Image cache system methods
            loadImageCache() {
                try {
                    const cachedData = localStorage.getItem(this.cacheKey);
                    if (cachedData) {
                        const cache = JSON.parse(cachedData);
                        const now = Date.now();
                        const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                        for (const [key, entry] of Object.entries(cache)) {
                            if (now - entry.timestamp < expiryTime) {
                                this.imageCache.set(key, entry);
                            }
                        }

                        console.log(`📦 Loaded ${this.imageCache.size} cached images`);
                    }
                } catch (error) {
                    console.error('Error loading image cache:', error);
                    this.imageCache.clear();
                }
            }

            saveImageCache() {
                try {
                    const cacheObject = {};
                    for (const [key, value] of this.imageCache.entries()) {
                        cacheObject[key] = value;
                    }
                    localStorage.setItem(this.cacheKey, JSON.stringify(cacheObject));
                    console.log(`💾 Saved ${this.imageCache.size} images to cache`);
                } catch (error) {
                    console.error('Error saving image cache:', error);
                }
            }

            getCacheKey(article) {
                return `${this.aiEngine.getDomain(article.url)}_${article.url.substring(article.url.length - 20)}_${article.title.substring(0, 30)}`.replace(/[^a-zA-Z0-9]/g, '_');
            }

            getCachedImage(article) {
                const key = this.getCacheKey(article);
                const cached = this.imageCache.get(key);

                if (cached) {
                    const now = Date.now();
                    const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                    if (now - cached.timestamp < expiryTime) {
                        console.log(`✅ Using cached image for: ${article.title.substring(0, 30)}...`);
                        return cached.imageUrl;
                    } else {
                        this.imageCache.delete(key);
                        console.log(`⏰ Cache expired for: ${article.title.substring(0, 30)}...`);
                    }
                }

                return null;
            }

            setCachedImage(article, imageUrl) {
                const key = this.getCacheKey(article);
                this.imageCache.set(key, {
                    imageUrl: imageUrl,
                    timestamp: Date.now(),
                    domain: this.aiEngine.getDomain(article.url),
                    title: article.title.substring(0, 50)
                });

                clearTimeout(this.cacheSaveTimeout);
                this.cacheSaveTimeout = setTimeout(() => this.saveImageCache(), 1000);

                console.log(`💾 Cached image for: ${article.title.substring(0, 30)}...`);
            }

            clearImageCache() {
                if (confirm('Clear all cached images?\n\nThis will:\n- Clear local cache\n- Remove stored images from articles\n- Force re-downloading images next time')) {
                    this.imageCache.clear();
                    localStorage.removeItem(this.cacheKey);

                    this.articles.forEach(article => {
                        if (article.cachedImage) {
                            delete article.cachedImage;
                        }
                    });

                    this.updateStatus('🗑️ All image data cleared. Images will be re-downloaded and stored for cross-device access.', 'success');
                    console.log('🗑️ All image data cleared');
                    this.displayArticles(this.articles);
                }
            }

            getCacheStats() {
                const timestamps = Array.from(this.imageCache.values()).map(entry => entry.timestamp);
                return {
                    total: this.imageCache.size,
                    memoryUsage: JSON.stringify(Object.fromEntries(this.imageCache)).length,
                    oldestEntry: timestamps.length > 0 ? Math.min(...timestamps) : null,
                    newestEntry: timestamps.length > 0 ? Math.max(...timestamps) : null
                };
            }

            // Image extraction methods
            getBestArticleImage(article) {
                if (article.images && article.images.length > 0) {
                    let bestImage = article.images[0];

                    for (const img of article.images) {
                        if (img.width && img.height) {
                            if (img.width >= 300 && img.height >= 150) {
                                bestImage = img;
                                break;
                            }
                        }
                    }

                    return bestImage.src || bestImage.url || bestImage;
                }

                if (article.featuredImage) {
                    return article.featuredImage;
                }

                if (article.image) {
                    return article.image;
                }

                if (article.content) {
                    const imgMatch = article.content.match(/<img[^>]+src="([^"]+)"/i);
                    if (imgMatch && imgMatch[1]) {
                        return imgMatch[1];
                    }
                }

                return null;
            }

            async setArticleImageAndCache(article, index, imageUrl, source) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return;

                imageElement.innerHTML = this.createImageHTML(imageUrl, false);

                const cacheIndicator = imageElement.querySelector('.cache-indicator');
                if (cacheIndicator) {
                    if (source === 'extracted') {
                        cacheIndicator.textContent = '🌐 Fresh';
                        cacheIndicator.className = 'cache-indicator fresh';
                    } else if (source === 'refreshed') {
                        cacheIndicator.textContent = '🔄 Refreshed';
                        cacheIndicator.className = 'cache-indicator fresh';
                    } else {
                        cacheIndicator.textContent = '💾 Cached';
                        cacheIndicator.className = 'cache-indicator cached';
                    }
                }

                this.setCachedImage(article, imageUrl);

                if (this.storeImagesInBackup && (source === 'extracted' || source === 'saved' || source === 'fallback' || source === 'refreshed')) {
                    try {
                        console.log(`🔄 Converting image for cross-device storage: ${article.title.substring(0, 30)}...`);
                        const imageData = await this.convertImageToBase64(imageUrl);

                        if (imageData.stored) {
                            const articleIndex = this.articles.findIndex(a => a.url === article.url);
                            if (articleIndex !== -1) {
                                this.articles[articleIndex].cachedImage = {
                                    base64: imageData.base64,
                                    url: imageData.url,
                                    timestamp: Date.now(),
                                    size: imageData.size,
                                    source: source
                                };

                                console.log(`💾 Stored ${imageData.size}KB image in backup for cross-device sync`);

                                if (cacheIndicator) {
                                    cacheIndicator.textContent = '🌐 Synced';
                                    cacheIndicator.className = 'cache-indicator synced';
                                }

                                if (this.accessToken) {
                                    console.log('💾 Auto-saving to OneDrive for instant cross-device sync...');
                                    try {
                                        await this.updateOneDriveBackup();
                                        console.log('✅ OneDrive backup updated with new image');
                                    } catch (error) {
                                        console.error('⚠️ Failed to auto-save backup:', error);
                                    }
                                }
                            }
                        } else {
                            console.log(`⚠️ Image too large for cross-device storage: ${imageData.size}KB`);
                        }
                    } catch (error) {
                        console.error('Error storing image for cross-device sync:', error);
                    }
                }
            }

            async convertImageToBase64(imageUrl) {
                try {
                    console.log(`📸 Converting image to base64: ${imageUrl.substring(0, 50)}...`);

                    const img = new Image();
                    img.crossOrigin = 'anonymous';

                    return new Promise((resolve, reject) => {
                        img.onload = () => {
                            try {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');

                                const maxWidth = 400;
                                const maxHeight = 250;

                                let { width, height } = img;

                                if (width > maxWidth) {
                                    height = (height * maxWidth) / width;
                                    width = maxWidth;
                                }
                                if (height > maxHeight) {
                                    width = (width * maxHeight) / height;
                                    height = maxHeight;
                                }

                                canvas.width = width;
                                canvas.height = height;

                                ctx.drawImage(img, 0, 0, width, height);
                                const base64 = canvas.toDataURL('image/jpeg', 0.8);

                                const sizeKB = Math.round(base64.length * 0.75 / 1024);

                                if (sizeKB > this.maxImageSizeKB) {
                                    console.log(`⚠️ Image too large (${sizeKB}KB), using URL only`);
                                    resolve({ url: imageUrl, size: sizeKB, stored: false });
                                } else {
                                    console.log(`✅ Image converted (${sizeKB}KB): ${imageUrl.substring(0, 30)}...`);
                                    resolve({ base64: base64, url: imageUrl, size: sizeKB, stored: true });
                                }
                            } catch (error) {
                                console.log(`❌ Canvas conversion failed: ${error.message}`);
                                resolve({ url: imageUrl, stored: false });
                            }
                        };

                        img.onerror = () => {
                            console.log(`❌ Image load failed: ${imageUrl}`);
                            resolve({ url: imageUrl, stored: false });
                        };

                        img.src = imageUrl;
                    });
                } catch (error) {
                    console.error('Image conversion error:', error);
                    return { url: imageUrl, stored: false };
                }
            }

            async loadMissingImages(articles) {
                console.log('🎨 Enhanced image loader - Getting quality images...');

                const articlesNeedingImages = articles.filter((article, index) => {
                    const hasStoredImage = article.cachedImage && article.cachedImage.base64;
                    const hasCachedImage = this.getCachedImage(article);
                    return !hasStoredImage && !hasCachedImage;
                });

                if (articlesNeedingImages.length === 0) {
                    this.updateStatus(`✅ All images loaded with enhanced quality!`, 'success');
                    return;
                }

                const isMobile = window.innerWidth <= 768;
                let successCount = 0;
                const totalNew = articlesNeedingImages.length;

                console.log(`🔄 Loading ${totalNew} images with enhanced extraction${isMobile ? ' (mobile optimized)' : ''}`);

                const batchSize = isMobile ? 2 : 5;
                const delayBetweenImages = isMobile ? 800 : 300;

                for (let i = 0; i < articlesNeedingImages.length; i += batchSize) {
                    const batch = articlesNeedingImages.slice(i, i + batchSize);

                    await Promise.all(batch.map(async (article) => {
                        const originalIndex = articles.findIndex(a => a === article);

                        try {
                            const success = await this.extractAndCacheImage(article, originalIndex);
                            if (success) successCount++;
                        } catch (error) {
                            console.error(`Failed to extract image for article ${originalIndex}:`, error);
                            const fallback = this.getCategoryBasedImage(article, originalIndex);
                            this.setArticleImageAndCache(article, originalIndex, fallback, 'smart_fallback');
                            successCount++;
                        }
                    }));

                    const progress = Math.round(((i + batchSize) / totalNew) * 100);
                    if (isMobile) {
                        this.updateStatus(`📱 Loading quality images... ${Math.min(i + batchSize, totalNew)}/${totalNew}`, 'loading');
                    } else {
                        this.updateStatus(`🎯 Loading enhanced images... ${Math.min(i + batchSize, totalNew)}/${totalNew} (${progress}%)`, 'loading');
                    }

                    if (i + batchSize < articlesNeedingImages.length) {
                        await new Promise(resolve => setTimeout(resolve, delayBetweenImages));
                    }
                }

                const totalCached = this.imageCache.size;

                if (isMobile) {
                    this.updateStatus(`📱 ${successCount} quality images loaded! 🎉`, 'success');
                } else {
                    this.updateStatus(`✅ Loaded ${successCount}/${totalNew} enhanced images! (${totalCached} total cached)`, 'success');
                }

                console.log(`🎨 Enhanced image loading complete: ${successCount}/${totalNew} quality images loaded`);
            }

            async extractAndCacheImage(article, index) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return false;

                console.log(`🎯 Enhanced image extraction for: ${this.aiEngine.getDomain(article.url)}`);

                const savedImage = this.getBestArticleImage(article);
                if (savedImage) {
                    console.log(`✅ Using saved image: ${article.title.substring(0, 30)}...`);
                    this.setArticleImageAndCache(article, index, savedImage, 'saved');
                    return true;
                }

                console.log(`🎨 Using smart fallback: ${article.title.substring(0, 30)}...`);
                const smartFallback = this.getCategoryBasedImage(article, index);
                this.setArticleImageAndCache(article, index, smartFallback, 'smart_fallback');
                return true;
            }

            getCategoryBasedImage(article, index) {
                const category = article.category || 'Technology';
                const categoryData = this.aiEngine.categories[category];
                
                if (!categoryData) {
                    return 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                }

                const categoryImages = {
                    'Technology': [
                        'https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1555949963-ff9fe166c327?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'Artificial Intelligence': [
                        'https://images.unsplash.com/photo-1555255707-c07966088b7b?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1620712943543-bcc4688e7485?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1677442136019-21780ecad995?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'Business': [
                        'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1664475450424-2645cd1d4b21?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1611974789855-9c2a0a7236a3?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'Science': [
                        'https://images.unsplash.com/photo-1532094349884-543bc11b234d?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ]
                };

                const defaultImages = categoryImages[category] || categoryImages['Technology'];
                const hash = Math.abs(article.title.split('').reduce((hash, char) => ((hash << 5) - hash + char.charCodeAt(0)) & 0xffffffff, 0));
                return defaultImages[hash % defaultImages.length];
            }

            // Reader functionality
            openReaderByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                this.currentArticle = article;
                const overlay = document.getElementById('readerOverlay');

                document.getElementById('readerTitle').textContent = article.title;
                document.getElementById('readerDate').textContent = this.formatDate(article.dateAdded);
                document.getElementById('readerDomain').textContent = this.aiEngine.getDomain(article.url);
                document.getElementById('readerTime').textContent = `${article.readTime || 1} min read`;

                document.getElementById('readerContent').innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                        <p>Loading article content...</p>
                    </div>
                `;

                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';

                setTimeout(() => this.loadArticleContent(article), 100);
            }

            async loadArticleContent(article) {
                console.log('🚀 Loading article content...');
                const contentElement = document.getElementById('readerContent');

                let content = this.getArticleContent(article);

                if (!content) {
                    contentElement.innerHTML = `
                        <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 20px; border-radius: 8px; margin: 20px 0;">
                            <h3>📄 Content Not Available</h3>
                            <p>The full article content wasn't saved by the browser extension.</p>
                            <p><strong>Available excerpt:</strong></p>
                            <p style="font-style: italic;">${article.excerpt || 'No excerpt available'}</p>
                            <div style="text-align: center; margin: 20px 0;">
                                <a href="${article.url}" target="_blank" style="display: inline-block; background: #ee5a24; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                                    🔗 Read Full Article
                                </a>
                            </div>
                        </div>
                    `;
                } else {
                    contentElement.innerHTML = content;
                }
            }

            getArticleContent(article) {
                const contentFields = ['content', 'html', 'fullContent', 'textContent', 'body', 'readableContent'];

                for (const field of contentFields) {
                    if (article[field] && article[field].trim()) {
                        console.log(`✅ Found content in ${field} (${article[field].length} chars)`);
                        return article[field];
                    }
                }

                return null;
            }

            closeReader() {
                const overlay = document.getElementById('readerOverlay');
                overlay.classList.remove('active');
                document.body.style.overflow = 'auto';
            }

            openOriginal() {
                if (this.currentArticle) {
                    window.open(this.currentArticle.url, '_blank');
                }
            }

            // Export and delete functionality
            exportArticleByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                try {
                    const html = this.createArticleHTML(article);
                    const filename = `${this.sanitizeFilename(article.title)}.html`;
                    this.downloadFile(html, filename, 'text/html');
                    this.updateStatus(`📤 Article "${article.title}" exported successfully!`, 'success');
                } catch (error) {
                    console.error('Error exporting article:', error);
                    this.updateStatus(`❌ Failed to export article: ${error.message}`, 'error');
                }
            }

            async deleteArticleByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                if (confirm(`Delete "${article.title}"?\n\nThis will permanently remove the article from your OneDrive backup.`)) {
                    try {
                        const originalIndex = this.articles.findIndex(a =>
                            a.url === article.url && a.title === article.title
                        );

                        if (originalIndex === -1) {
                            throw new Error('Could not find article in main collection');
                        }

                        const cacheKey = this.getCacheKey(article);
                        this.imageCache.delete(cacheKey);
                        this.saveImageCache();

                        this.articles.splice(originalIndex, 1);
                        this.currentDisplayedArticles.splice(displayIndex, 1);

                        if (this.accessToken) {
                            this.updateStatus('Updating OneDrive backup...', 'loading');
                            await this.updateOneDriveBackup();
                            this.updateStatus(`✅ Article deleted and backup updated. ${this.articles.length} articles remaining.`, 'success');
                        } else {
                            this.updateStatus(`❌ Article deleted locally but OneDrive backup not updated (not connected).`, 'error');
                        }

                        this.displayArticles(this.currentDisplayedArticles);

                    } catch (error) {
                        console.error('Error deleting article:', error);
                        this.updateStatus(`❌ Failed to delete article: ${error.message}`, 'error');
                    }
                }
            }

            createArticleHTML(article) {
                const categoryInfo = article.category ? `
                    <div style="margin-bottom: 16px;">
                        <span style="background: linear-gradient(135deg, var(--ai-primary), var(--ai-secondary)); color: white; padding: 6px 15px; border-radius: 20px; font-size: 0.9em; font-weight: 600;">
                            ${this.aiEngine.categories[article.category]?.icon || '📄'} ${article.category}
                            ${article.aiEnhanced ? ' 🤖' : ''}
                            ${article.advancedAI ? ' 🧠' : ''}
                        </span>
                    </div>
                ` : '';

                return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHtml(article.title)}</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 40px 20px; 
            line-height: 1.7; 
            color: #333;
        }
        .header { 
            border-bottom: 3px solid #9c27b0; 
            margin-bottom: 32px; 
            padding-bottom: 24px; 
        }
        .title { 
            font-size: 2.4em; 
            font-weight: bold; 
            margin-bottom: 16px; 
            color: #2c3e50; 
            line-height: 1.2; 
        }
        .meta { 
            color: #7f8c8d; 
            font-size: 0.95em; 
            margin-bottom: 24px; 
        }
        .content { 
            font-size: 1.15em; 
            line-height: 1.8; 
        }
        .content img { 
            max-width: 100%; 
            height: auto; 
            margin: 24px 0; 
            border-radius: 8px; 
        }
        .content p { 
            margin-bottom: 1.4em; 
        }
        .footer { 
            margin-top: 48px; 
            padding-top: 24px; 
            border-top: 2px solid #f0f0f0; 
            color: #666; 
            font-size: 0.9em; 
        }
    </style>
</head>
<body>
    <div class="header">
        ${categoryInfo}
        <h1 class="title">${this.escapeHtml(article.title)}</h1>
        <div class="meta">
            <div style="margin-bottom: 8px;">🌐 From: <a href="${article.url}" style="color: #9c27b0;">${this.aiEngine.getDomain(article.url)}</a></div>
            ${article.author ? `<div style="margin-bottom: 8px;">✍️ By: ${this.escapeHtml(article.author)}</div>` : ''}
            <div style="margin-bottom: 8px;">📅 Saved: ${this.formatDate(article.dateAdded)}</div>
            <div>⏱️ Reading time: ${article.readTime || 1} minutes</div>
            ${article.categoryScore ? `<div>🧠 AI Category Score: ${article.categoryScore}</div>` : ''}
            ${article.advancedAI ? `<div>🧠 Advanced AI Enhanced</div>` : ''}
        </div>
    </div>
    <div class="content">
        ${article.content || article.excerpt || 'Content not available'}
    </div>
    <div class="footer">
        <p><strong>🧠 Exported from MyPocket Advanced AI Reader</strong></p>
        <p>Original URL: <a href="${article.url}" style="color: #9c27b0;">${article.url}</a></p>
        <p>Export Date: ${new Date().toLocaleDateString()}</p>
        ${article.category ? `<p>Category: ${article.category} ${article.advancedAI ? '(Advanced AI)' : article.aiEnhanced ? '(AI Enhanced)' : ''}</p>` : ''}
    </div>
</body>
</html>`;
            }

            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                URL.revokeObjectURL(url);
            }

            sanitizeFilename(filename) {
                if (!filename) return 'article';
                return filename.replace(/[^a-z0-9\s]/gi, '_').toLowerCase().substring(0, 50);
            }

            // Other utility methods
            async forceSyncImages() {
                if (!this.accessToken) {
                    this.updateStatus('❌ Please connect to OneDrive first', 'error');
                    return;
                }

                this.updateStatus('🔄 Force syncing all images to OneDrive...', 'loading');

                try {
                    let syncedCount = 0;
                    const totalArticles = this.articles.length;

                    for (let i = 0; i < this.articles.length; i++) {
                        const article = this.articles[i];

                        if (!article.cachedImage) {
                            let imageUrl = this.getCachedImage(article);

                            if (!imageUrl) {
                                imageUrl = this.getBestArticleImage(article);
                            }

                            if (!imageUrl) {
                                imageUrl = this.getCategoryBasedImage(article, i);
                            }

                            if (imageUrl) {
                                try {
                                    const imageData = await this.convertImageToBase64(imageUrl);
                                    if (imageData.stored) {
                                        article.cachedImage = {
                                            base64: imageData.base64,
                                            url: imageData.url,
                                            timestamp: Date.now(),
                                            size: imageData.size,
                                            source: 'force_sync'
                                        };
                                        syncedCount++;
                                    }
                                } catch (error) {
                                    console.error(`Failed to sync image for ${article.title}:`, error);
                                }
                            }
                        } else {
                            syncedCount++;
                        }

                        if (i % 5 === 0) {
                            this.updateStatus(`🔄 Syncing images... ${i + 1}/${totalArticles}`, 'loading');
                        }
                    }

                    await this.updateOneDriveBackup();

                    this.updateStatus(`✅ Force sync complete! ${syncedCount}/${totalArticles} images synced to OneDrive`, 'success');
                    this.displayArticles(this.articles);

                } catch (error) {
                    console.error('Force sync error:', error);
                    this.updateStatus(`❌ Force sync failed: ${error.message}`, 'error');
                }
            }

            async retryFailedImages() {
                if (!this.accessToken) {
                    this.updateStatus('❌ Please connect to OneDrive first', 'error');
                    return;
                }

                const articlesWithFailedImages = this.articles.filter((article, index) => {
                    const isExplicitlyFailed = this.failedImages.has(index);
                    const imageElement = document.getElementById(`image-${index}`);
                    const cacheIndicator = imageElement?.querySelector('.cache-indicator');
                    const hasFailedIndicator = cacheIndicator && cacheIndicator.textContent.includes('❌ Failed');

                    return isExplicitlyFailed || hasFailedIndicator;
                });

                if (articlesWithFailedImages.length === 0) {
                    this.updateStatus('✅ No explicitly failed images found.', 'success');
                    return;
                }

                const proceed = confirm(`Retry ${articlesWithFailedImages.length} explicitly failed images?`);
                if (!proceed) return;

                this.updateStatus(`🔄 Retrying ${articlesWithFailedImages.length} explicitly failed images...`, 'loading');

                let retriedCount = 0;
                let successCount = 0;

                for (const article of articlesWithFailedImages) {
                    const originalIndex = this.articles.findIndex(a => a === article);
                    if (originalIndex === -1) continue;

                    try {
                        retriedCount++;
                        this.failedImages.delete(originalIndex);

                        const success = await this.extractAndCacheImage(article, originalIndex);
                        if (success) {
                            successCount++;
                        }

                        this.updateStatus(`🔄 Retrying failed images... ${retriedCount}/${articlesWithFailedImages.length} (${successCount} recovered)`, 'loading');

                        await new Promise(resolve => setTimeout(resolve, 300));

                    } catch (error) {
                        console.error(`Failed to retry image for ${article.title}:`, error);
                        this.failedImages.add(originalIndex);
                    }
                }

                const message = successCount > 0
                    ? `✅ Retry complete! Recovered ${successCount}/${articlesWithFailedImages.length} failed images.`
                    : `⚠️ Could not recover the failed images.`;

                this.updateStatus(message, successCount > 0 ? 'success' : 'error');

                if (successCount > 0 && this.accessToken) {
                    try {
                        await this.updateOneDriveBackup();
                        console.log('✅ OneDrive backup updated with recovered images');
                    } catch (error) {
                        console.error('⚠️ Failed to save recovered images to backup:', error);
                    }
                }
            }

            async refreshSingleImage(originalIndex, displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                const proceed = confirm(`Refresh image for "${article.title.substring(0, 50)}..."?`);
                if (!proceed) return;

                console.log(`🔄 Refreshing single image for: ${article.title.substring(0, 30)}...`);

                const imageElement = document.getElementById(`image-${originalIndex}`);
                if (imageElement) {
                    imageElement.innerHTML = this.createPlaceholderHTML() + `
                        <div class="cache-indicator loading">🔄 Refreshing...</div>
                    `;
                }

                try {
                    const cacheKey = this.getCacheKey(article);
                    this.imageCache.delete(cacheKey);

                    const mainArticleIndex = this.articles.findIndex(a =>
                        a.url === article.url && a.title === article.title
                    );
                    if (mainArticleIndex !== -1 && this.articles[mainArticleIndex].cachedImage) {
                        delete this.articles[mainArticleIndex].cachedImage;
                    }

                    const smartFallback = this.getCategoryBasedImage(article, originalIndex + Date.now());
                    await this.setArticleImageAndCache(article, originalIndex, smartFallback, 'refreshed');

                    this.updateStatus(`✅ Image refreshed successfully for "${article.title.substring(0, 40)}..."`, 'success');

                    if (this.accessToken) {
                        try {
                            await this.updateOneDriveBackup();
                            console.log('✅ Updated backup with refreshed image');
                        } catch (error) {
                            console.error('⚠️ Failed to update backup:', error);
                        }
                    }

                } catch (error) {
                    console.error('Single image refresh error:', error);
                    this.updateStatus(`❌ Failed to refresh image: ${error.message}`, 'error');
                }
            }

            toggleTestMode() {
                document.body.classList.toggle('test-mode');
                const isTestMode = document.body.classList.contains('test-mode');

                this.updateStatus(
                    isTestMode
                        ? '🔍 Test mode ON - Action buttons always visible'
                        : '👁️ Test mode OFF - Action buttons show on hover',
                    'success'
                );
            }

            showDebugInfo() {
                const cacheStats = this.getCacheStats();
                const storedImages = this.articles.filter(a => a.cachedImage).length;
                const totalStoredSizeKB = this.articles.reduce((total, article) => {
                    return total + (article.cachedImage ? article.cachedImage.size || 0 : 0);
                }, 0);

                const hasRefreshToken = !!this.getRefreshToken();
                const tokenTimestamp = localStorage.getItem('mypocket_token_timestamp');
                const tokenAge = tokenTimestamp ? Math.round((Date.now() - parseInt(tokenTimestamp)) / 1000 / 60) : 'Unknown';

                const categorizedArticles = this.articles.filter(a => a.category).length;
                const aiEnhancedArticles = this.articles.filter(a => a.aiEnhanced).length;
                const advancedAIArticles = this.articles.filter(a => a.advancedAI).length;
                const semanticTagsCount = this.articles.filter(a => a.semanticTags && a.semanticTags.length > 0).length;

                const info = `
MyPocket Advanced AI Reader Debug Info:
=====================================

Current URL: ${window.location.href}
Redirect URI: ${this.redirectUri}
Client ID: ${this.clientId}

🔐 SECURITY (PKCE):
- Authentication Method: Authorization Code + PKCE
- Security Level: HIGH
- Has Access Token: ${!!this.accessToken}
- Has Refresh Token: ${hasRefreshToken}
- Token Age: ${tokenAge} minutes

📚 ARTICLES & IMAGES:
- Articles Loaded: ${this.articles.length}
- Currently Displayed: ${this.currentDisplayedArticles.length}
- Articles with Stored Images: ${storedImages}
- Total Stored Image Size: ${Math.round(totalStoredSizeKB)}KB
- Failed Images: ${this.failedImages.size}

🧠 ADVANCED AI CATEGORIZATION:
- AI Features Enabled: ${this.aiCategoriesEnabled}
- Advanced AI Mode: ${this.advancedAIMode}
- Semantic Search: ${this.semanticSearchEnabled}
- Total Categories: ${this.categories.size}
- Categorized Articles: ${categorizedArticles}/${this.articles.length}
- AI Enhanced Articles: ${aiEnhancedArticles}/${this.articles.length}
- Advanced AI Articles: ${advancedAIArticles}/${this.articles.length}
- Semantic Tags Found: ${semanticTagsCount}/${this.articles.length}
- Active Category Filter: ${this.activeCategory || 'None'}

💾 LOCAL CACHE:
- Total Cached Images: ${cacheStats.total}
- Memory Usage: ${Math.round(cacheStats.memoryUsage / 1024)} KB
- Cache Expiry: ${this.cacheExpiryDays} days

🎯 AI ENHANCEMENTS:
✅ 20+ intelligent categories
✅ Multi-layered semantic analysis  
✅ Topic modeling and clustering
✅ Context-aware pattern recognition
✅ Category relationships and hierarchies
✅ Advanced confidence scoring
✅ Cross-device AI metadata sync

DEBUGGING COMMANDS:
- webReader.runAdvancedAIAnalysis() - Run advanced AI analysis
- webReader.toggleSemanticSearch() - Toggle semantic search
- webReader.showAIHelp() - Show AI help
                `;

                alert(info);
            }
        }

        let webReader;

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('📄 DOM Content Loaded - Starting Advanced AI initialization...');

            try {
                const connectBtn = document.getElementById('connectBtnSidebar');
                if (!connectBtn) {
                    console.error('❌ Critical: Connect button not found in DOM!');
                    const status = document.getElementById('status');
                    if (status) {
                        status.textContent = '❌ UI elements not found. Please refresh the page.';
                        status.className = 'status error';
                    }
                    return;
                }

                console.log('✅ Critical elements found, initializing Advanced AI reader...');
                webReader = new MyPocketWebReader();
                window.webReader = webReader;

                window.debugElements = () => webReader.debugElements();
                window.testAuth = () => webReader.testAuth();

                console.log('✅ MyPocket Advanced AI Reader initialized successfully');

                setTimeout(() => {
                    console.log('🧪 Running initial element test...');
                    if (window.debugMyPocket) {
                        window.debugMyPocket();
                    }
                }, 500);

            } catch (error) {
                console.error('❌ CRITICAL ERROR during Advanced AI initialization:', error);
                console.error('Error stack:', error.stack);

                const status = document.getElementById('status');
                if (status) {
                    status.textContent = `❌ Failed to start: ${error.message}`;
                    status.className = 'status error';
                }

                window.webReader = null;
                alert(`MyPocket Advanced AI Reader failed to start!\n\nError: ${error.message}\n\nPlease:\n1. Check browser console for details\n2. Try refreshing the page\n3. Ensure you're using a modern browser`);
            }
        });

        // Debug function
        window.debugMyPocket = function () {
            console.log('🔧 DEBUG: Checking all elements...');
            const elements = {
                'sidebar': document.getElementById('sidebar'),
                'connectBtnSidebar': document.getElementById('connectBtnSidebar'),
                'connectionStatusSidebar': document.getElementById('connectionStatusSidebar'),
                'connectionIcon': document.getElementById('connectionIcon'),
                'connectionText': document.getElementById('connectionText'),
                'status': document.getElementById('status'),
                'mainContent': document.getElementById('mainContent')
            };

            console.log('🔍 Element check results:');
            for (const [name, element] of Object.entries(elements)) {
                if (element) {
                    console.log(`✅ ${name}: Found`);
                } else {
                    console.log(`❌ ${name}: NOT FOUND`);
                }
            }

            if (window.webReader) {
                console.log('✅ webReader: Initialized');
                console.log('📊 webReader properties:', {
                    accessToken: !!window.webReader.accessToken,
                    articles: window.webReader.articles ? window.webReader.articles.length : 0,
                    advancedAIMode: window.webReader.advancedAIMode,
                    semanticSearchEnabled: window.webReader.semanticSearchEnabled,
                    categories: window.webReader.categories.size
                });
            } else {
                console.log('❌ webReader: NOT INITIALIZED');
            }

            return elements;
        };
    </script>
</body>

</html>
