<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>MyPocket - Web Reader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #ee5a24;
            --secondary-color: #667eea;
            --background: #f8f9fa;
            --surface: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --border: #e9ecef;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        /* Enhanced Dark mode with better contrast */
        [data-theme="dark"] {
            --primary-color: #ff6b35;
            --secondary-color: #7b88f7;
            --background: #0d1117;
            --surface: #161b22;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --border: #30363d;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.6);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.8);
        }

        /* Dark mode specific improvements */
        [data-theme="dark"] .article-card {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .article-card:hover {
            border-color: #484f58;
            transform: translateY(-2px) scale(1.02);
        }

        [data-theme="dark"] .search-input {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .search-input:focus {
            border-color: var(--primary-color);
            background: var(--surface);
        }

        [data-theme="dark"] .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.8;
        }

        [data-theme="dark"] .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border-color: var(--border);
        }

        [data-theme="dark"] .btn-secondary:hover {
            background: #21262d;
            border-color: #484f58;
            color: var(--text-primary);
        }

        [data-theme="dark"] .action-btn {
            background: rgba(22, 27, 34, 0.95);
            border-color: var(--border);
            color: var(--text-primary);
            backdrop-filter: blur(10px);
        }

        [data-theme="dark"] .action-btn:hover {
            background: rgba(33, 38, 45, 0.95);
            border-color: #484f58;
        }

        [data-theme="dark"] .read-btn:hover {
            background: rgba(13, 110, 253, 0.2);
            border-color: #0d6efd;
            color: #58a6ff;
        }

        [data-theme="dark"] .export-btn:hover {
            background: rgba(25, 135, 84, 0.2);
            border-color: #198754;
            color: #3fb950;
        }

        [data-theme="dark"] .delete-btn:hover {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #f85149;
        }

        [data-theme="dark"] .reader-container {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .reader-header {
            background: var(--background);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .reader-content {
            color: var(--text-primary);
        }

        [data-theme="dark"] .reader-content h1,
        [data-theme="dark"] .reader-content h2,
        [data-theme="dark"] .reader-content h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .reader-content blockquote {
            background: var(--background);
            border-left-color: var(--primary-color);
        }

        [data-theme="dark"] .close-reader {
            background: var(--primary-color);
        }

        [data-theme="dark"] .empty-state {
            color: var(--text-secondary);
        }

        [data-theme="dark"] .empty-state h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .connection-status.connected {
            background: rgba(25, 135, 84, 0.2);
            border-color: #198754;
            color: #3fb950;
        }

        [data-theme="dark"] .connection-status.disconnected {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #f85149;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--background);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            color: white;
            padding: 20px 0;
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .logo {
            font-size: 1.8em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
            transform: translateY(-1px);
        }

        /* Search */
        .search-container {
            padding: 30px 0;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .search-box {
            position: relative;
            max-width: 600px;
            margin: 0 auto;
        }

        .search-input {
            width: 100%;
            padding: 15px 50px 15px 20px;
            border: 2px solid var(--border);
            border-radius: 25px;
            font-size: 16px;
            background: var(--background);
            transition: border-color 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .search-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
            font-size: 20px;
        }

        /* Status */
        .status {
            padding: 20px 0;
            text-align: center;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .status.loading {
            color: var(--secondary-color);
        }

        .status.error {
            color: #e74c3c;
        }

        .status.success {
            color: #27ae60;
        }

        /* Articles Grid - SMALLER TILES */
        .articles-section {
            padding: 40px 0;
            min-height: 60vh;
        }

        .articles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); /* REDUCED from 290px to 220px */
            gap: 18px; /* REDUCED from 24px to 18px */
            margin-top: 20px;
        }

        /* ORGANIC SHAPED TILES - SMALLER VERSION */
        .article-card {
            background: var(--surface);
            /* Organic rounded shape - different for each nth-child */
            border-radius: 32px 24px 32px 24px;
            overflow: visible;
            box-shadow: var(--shadow);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border: 1px solid var(--border);
            position: relative;
            display: flex;
            flex-direction: column;
            transform-origin: center center;
        }

        /* Varying organic shapes for visual interest */
        .article-card:nth-child(3n+1) {
            border-radius: 28px 36px 28px 36px;
        }

        .article-card:nth-child(3n+2) {
            border-radius: 35px 25px 35px 25px;
        }

        .article-card:nth-child(3n+3) {
            border-radius: 30px 30px 40px 20px;
        }

        .article-card:nth-child(4n+1) {
            border-radius: 40px 20px 30px 30px;
        }

        .article-card:nth-child(5n+1) {
            border-radius: 25px 35px 25px 35px;
        }

        .article-card:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-8px) scale(1.02) rotate(1deg);
            border-color: var(--primary-color);
        }

        .article-card:nth-child(even):hover {
            transform: translateY(-8px) scale(1.02) rotate(-1deg);
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
        }

        /* Organic shaped image area - SMALLER */
        .article-image {
            width: 100%;
            height: 100px; /* REDUCED from 140px to 100px */
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em; /* REDUCED from 2em to 1.5em */
            color: white;
            position: relative;
            overflow: hidden;
            /* Inherit the card's organic border radius for top corners */
            border-radius: inherit;
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 16px;
        }

        .article-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            transition: transform 0.4s ease, opacity 0.3s ease;
            /* Force proper aspect ratio on all browsers */
            min-height: 100px;
            max-height: 100px;
        }

        .article-image:hover img {
            transform: scale(1.08);
        }

        /* Mobile-specific image fixes */
        @media (max-width: 768px) {
            .article-image {
                height: 120px; /* Slightly taller on mobile for better proportions */
                border-radius: 16px 16px 0 0 !important; /* Simpler radius on mobile */
            }
            
            .article-image img {
                /* Enhanced mobile image handling */
                min-height: 120px;
                max-height: 120px;
                object-fit: cover;
                object-position: center;
                /* Firefox mobile specific fixes */
                -moz-object-fit: cover;
                -moz-object-position: center;
                /* Prevent stretching on mobile */
                width: 100% !important;
                height: 100% !important;
                display: block;
            }
        }

        /* Firefox-specific image fixes */
        @-moz-document url-prefix() {
            .article-image img {
                object-fit: cover !important;
                object-position: center !important;
                width: 100% !important;
                height: 100% !important;
            }
        }

        /* Compact content area with organic feel - SMALLER */
        .article-content {
            padding: 15px; /* REDUCED from 20px to 15px */
            flex: 1;
            cursor: pointer;
            border-radius: 0 0 inherit inherit;
        }

        .article-title {
            font-size: 1em; /* REDUCED from 1.1em to 1em */
            font-weight: 600;
            margin-bottom: 6px; /* REDUCED from 8px to 6px */
            line-height: 1.3;
            color: var(--text-primary);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-excerpt {
            color: var(--text-secondary);
            font-size: 0.8em; /* REDUCED from 0.9em to 0.8em */
            line-height: 1.4;
            margin-bottom: 10px; /* REDUCED from 12px to 10px */
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px; /* REDUCED from 8px to 6px */
            color: var(--text-secondary);
            font-size: 0.75em; /* REDUCED from 0.8em to 0.75em */
            margin-bottom: 6px; /* REDUCED from 8px to 6px */
        }

        .article-domain {
            font-weight: 500;
        }

        .article-date {
            opacity: 0.8;
        }

        .article-stats {
            display: flex;
            gap: 10px; /* REDUCED from 12px to 10px */
            font-size: 0.7em; /* REDUCED from 0.75em to 0.7em */
            color: var(--text-secondary);
        }

        /* Floating organic action buttons - SMALLER */
        .article-actions {
            position: absolute;
            top: 10px; /* REDUCED from 15px to 10px */
            right: 10px; /* REDUCED from 15px to 10px */
            display: flex;
            gap: 6px; /* REDUCED from 8px to 6px */
            opacity: 0 !important;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid var(--border);
            border-radius: 50%; /* Circular buttons for organic feel */
            padding: 8px; /* REDUCED from 12px to 8px */
            cursor: pointer;
            font-size: 14px; /* REDUCED from 16px to 14px */
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            min-width: 36px; /* REDUCED from 44px to 36px */
            height: 36px; /* REDUCED from 44px to 36px */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn:hover {
            transform: translateY(-4px) scale(1.15);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
            border-radius: 40% 60% 70% 30%;
        }

        .read-btn:hover {
            background: #e3f2fd;
            border-color: #2196f3;
            border-radius: 60% 40% 30% 70%;
        }

        .export-btn:hover {
            background: #e8f5e8;
            border-color: #4caf50;
            border-radius: 30% 70% 60% 40%;
        }

        .delete-btn {
            color: #f44336;
        }

        .delete-btn:hover {
            background: #ffebee;
            border-color: #f44336;
            color: #d32f2f;
            border-radius: 70% 30% 40% 60%;
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
        }

        body.test-mode .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
            background: rgba(255, 255, 0, 0.1);
            border: 2px dashed #ff9800;
            border-radius: 20px;
            padding: 5px;
        }

        .article-actions:hover {
            opacity: 1 !important;
            visibility: visible !important;
        }

        /* Reader View */
        .reader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            overflow-y: auto;
        }

        .reader-overlay.active {
            display: block;
        }

        .reader-container {
            max-width: 800px;
            margin: 40px auto;
            background: var(--surface);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.3);
        }

        .reader-header {
            padding: 30px;
            border-bottom: 1px solid var(--border);
            background: var(--background);
        }

        .reader-title {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 15px;
            line-height: 1.3;
        }

        .reader-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .reader-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .reader-content {
            padding: 40px;
            font-size: 1.1em;
            line-height: 1.8;
            max-width: none;
        }

        .reader-content h1,
        .reader-content h2,
        .reader-content h3 {
            margin: 30px 0 15px;
            color: var(--text-primary);
        }

        .reader-content p {
            margin-bottom: 20px;
        }

        .reader-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
        }

        .reader-content blockquote {
            border-left: 4px solid var(--primary-color);
            margin: 20px 0;
            padding: 15px 20px;
            background: var(--background);
            font-style: italic;
        }

        .close-reader {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-reader:hover {
            border-radius: 30% 70% 70% 30%;
            transform: scale(1.1);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Cache indicator */
        .cache-indicator {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            z-index: 5;
        }

        .cache-indicator.cached {
            background: rgba(39, 174, 96, 0.8);
        }

        .cache-indicator.fresh {
            background: rgba(52, 152, 219, 0.8);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 0 15px;
            }

            .header-content {
                flex-direction: column;
                text-align: center;
            }

            .header-actions {
                flex-wrap: wrap;
                justify-content: center;
                gap: 10px;
            }

            .btn {
                padding: 8px 16px;
                font-size: 13px;
            }

            .articles-grid {
                grid-template-columns: 1fr;
                gap: 20px;
                margin-top: 15px;
            }

            .article-card {
                /* Simpler border radius for mobile */
                border-radius: 16px !important;
                /* Better mobile shadows */
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }

            .article-card:hover {
                transform: translateY(-2px) scale(1.005);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }

            /* Mobile image container */
            .article-image {
                height: 120px !important; /* Consistent mobile height */
                border-radius: 16px 16px 0 0 !important;
                /* Better mobile background gradients */
                background-size: 200% 200%;
                animation: gradientShift 3s ease infinite;
            }
            
            /* Enhanced mobile image handling */
            .article-image img {
                min-height: 120px !important;
                max-height: 120px !important;
                object-fit: cover !important;
                object-position: center !important;
                /* Prevent image distortion on mobile */
                aspect-ratio: 16/9;
                /* Firefox mobile specific */
                -moz-object-fit: cover !important;
                -moz-object-position: center !important;
                /* Webkit mobile specific */
                -webkit-object-fit: cover !important;
                -webkit-object-position: center !important;
            }

            .article-content {
                padding: 12px 15px;
            }

            .article-title {
                font-size: 0.95em;
                line-height: 1.4;
                margin-bottom: 8px;
            }

            .article-excerpt {
                font-size: 0.8em;
                line-height: 1.4;
                margin-bottom: 8px;
            }

            .article-meta {
                font-size: 0.7em;
                gap: 8px;
                margin-bottom: 8px;
            }

            .article-stats {
                font-size: 0.65em;
                gap: 8px;
            }

            .article-actions {
                position: static;
                opacity: 1 !important;
                visibility: visible !important;
                justify-content: center;
                margin: 10px 15px 15px;
                padding: 10px;
                background: var(--background);
                border-radius: 12px;
                gap: 12px;
            }

            .action-btn {
                min-width: 44px;
                height: 44px;
                font-size: 16px;
                border-radius: 50% !important;
                /* Better mobile touch targets */
                padding: 10px;
            }

            .action-btn:hover {
                border-radius: 50% !important;
                transform: scale(1.05);
            }

            .reader-container {
                margin: 10px;
                border-radius: 12px;
                max-height: 90vh;
                overflow-y: auto;
            }

            .reader-header,
            .reader-content {
                padding: 15px;
            }

            .reader-title {
                font-size: 1.4em;
                line-height: 1.3;
            }

            .reader-meta {
                flex-direction: column;
                gap: 8px;
                font-size: 0.85em;
            }

            .search-input {
                font-size: 16px; /* Prevent zoom on iOS */
                padding: 12px 45px 12px 15px;
            }

            .search-box {
                margin: 0 15px;
            }

            .status {
                padding: 15px 20px;
                font-size: 0.9em;
            }

            /* Mobile cache indicators */
            .cache-indicator {
                font-size: 9px;
                padding: 1px 4px;
                bottom: 5px;
                left: 5px;
            }
        }

        /* Extra small screens (phones in portrait) */
        @media (max-width: 480px) {
            .header-actions {
                gap: 8px;
            }
            
            .btn {
                padding: 6px 12px;
                font-size: 12px;
            }
            
            .btn span {
                margin-right: 4px;
            }
            
            .article-image {
                height: 100px !important;
            }
            
            .article-image img {
                min-height: 100px !important;
                max-height: 100px !important;
            }
        }

        /* Gradient animation for mobile loading states */
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .article-card:hover {
                transform: none;
            }
            
            .article-image img {
                /* Force proper rendering on touch devices */
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                backface-visibility: hidden;
                -webkit-backface-visibility: hidden;
            }
            
            .action-btn:hover {
                transform: none;
            }
            
            .action-btn:active {
                transform: scale(0.95);
                transition: transform 0.1s ease;
            }
        }

        /* High DPI display optimizations */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .article-image img {
                image-rendering: -webkit-optimize-contrast;
                image-rendering: crisp-edges;
            }
        }

        /* Connection Status */
        .connection-status {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 15px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .connection-status.connected {
            border-color: #27ae60;
            background: #d4edda;
        }

        .connection-status.disconnected {
            border-color: #e74c3c;
            background: #f8d7da;
        }

        /* Additional organic elements */
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-6px); }
        }

        /* Background pattern animation for generated placeholders */
        @keyframes floatPattern {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Shimmer animation for loading placeholders */
        @keyframes shimmer {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .article-card:nth-child(7n+1) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 0s;
        }

        .article-card:nth-child(7n+2) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 0.5s;
        }

        .article-card:nth-child(7n+3) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 1s;
        }

        /* Organic gradient backgrounds for images */
        .article-image:nth-child(odd) {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .article-image:nth-child(3n+1) {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .article-image:nth-child(3n+2) {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .article-image:nth-child(3n+3) {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }

        .article-image:nth-child(5n+1) {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }
    </style>
</head>

<body>
    <!-- Header -->
    <header class="header">
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    📚 MyPocket Web Reader
                </div>
                <div class="header-actions">
                    <button id="connectBtn" class="btn btn-primary">
                        <span id="connectIcon">☁️</span>
                        <span id="connectText">Connect OneDrive</span>
                    </button>
                    <button id="refreshBtn" class="btn btn-secondary" style="display: none;">
                        <span>🔄</span> Refresh
                    </button>
                    <button id="clearCacheBtn" class="btn btn-secondary" onclick="webReader.clearImageCache()">
                        <span>🗑️</span> Clear Cache
                    </button>
                    <button id="debugBtn" class="btn btn-secondary" onclick="webReader.showDebugInfo()">
                        <span>🔧</span> Debug
                    </button>
                    <button id="testBtn" class="btn btn-secondary" onclick="webReader.toggleTestMode()">
                        <span>👁️</span> Show Buttons
                    </button>
                    <button id="darkModeBtn" class="btn btn-secondary" onclick="webReader.toggleDarkMode()">
                        <span>🌙</span> Dark Mode
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Search -->
    <section class="search-container">
        <div class="container">
            <div class="search-box">
                <input type="text" id="searchInput" class="search-input" placeholder="Search your saved articles...">
                <span class="search-icon">🔍</span>
            </div>
        </div>
    </section>

    <!-- Status -->
    <div class="status" id="status">
        Connect to OneDrive to view your saved articles
    </div>

    <!-- Articles -->
    <section class="articles-section">
        <div class="container">
            <div id="articlesContainer">
                <div class="empty-state">
                    <div class="empty-state-icon">📖</div>
                    <h3>Welcome to MyPocket Web Reader</h3>
                    <p>Connect to OneDrive to access your saved articles from anywhere!</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Reader Overlay -->
    <div class="reader-overlay" id="readerOverlay">
        <div class="reader-container">
            <button class="close-reader" id="closeReader">✕</button>
            <div class="reader-header">
                <h1 class="reader-title" id="readerTitle">Article Title</h1>
                <div class="reader-meta" id="readerMeta">
                    <span>📅 <span id="readerDate">Date</span></span>
                    <span>🌐 <span id="readerDomain">Domain</span></span>
                    <span>⏱️ <span id="readerTime">5 min read</span></span>
                </div>
                <div class="reader-actions">
                    <button class="btn btn-secondary" id="openOriginal">
                        🔗 Open Original
                    </button>
                </div>
            </div>
            <div class="reader-content" id="readerContent">
                Article content will appear here...
            </div>
        </div>
    </div>

    <script>
        class MyPocketWebReader {
            constructor() {
                this.clientId = '436e8796-8c40-47c3-9ad5-b8882f3ef7f7';
                this.redirectUri = this.getRedirectUri();
                console.log('🔵 Redirect URI:', this.redirectUri);

                this.accessToken = null;
                this.articles = [];
                this.currentArticle = null;
                
                // Image cache system
                this.imageCache = new Map();
                this.cacheKey = 'mypocket_image_cache';
                this.cacheExpiryDays = 7; // Cache images for 7 days
                
                // Mobile browser detection
                this.isMobile = this.detectMobile();
                this.isFirefoxMobile = this.detectFirefoxMobile();

                this.init();
            }

            detectMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                       window.innerWidth <= 768 ||
                       ('ontouchstart' in window);
            }

            detectFirefoxMobile() {
                return /Firefox/.test(navigator.userAgent) && this.isMobile;
            }
            }

            getRedirectUri() {
                const currentUrl = window.location.href;
                const baseUrl = currentUrl.split('#')[0];

                if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {
                    return baseUrl;
                } else {
                    return window.location.origin + window.location.pathname;
                }
            }

            init() {
                this.setupEventListeners();
                this.checkAuthFromURL();
                this.loadStoredToken();
                this.loadThemePreference();
                this.loadImageCache(); // Load cached images
                
                // Mobile debugging info
                if (this.isMobile) {
                    console.log('📱 Mobile device detected');
                    if (this.isFirefoxMobile) {
                        console.log('🦊 Firefox Mobile detected - applying specific fixes');
                    }
                    console.log(`📐 Screen: ${window.innerWidth}x${window.innerHeight}, DPR: ${window.devicePixelRatio || 1}`);
                }
            }

            setupEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', () => this.authenticate());
                document.getElementById('refreshBtn').addEventListener('click', () => this.loadArticles());
                document.getElementById('searchInput').addEventListener('input', (e) => this.searchArticles(e.target.value));
                document.getElementById('closeReader').addEventListener('click', () => this.closeReader());
                document.getElementById('openOriginal').addEventListener('click', () => this.openOriginal());
            }

            // ===== IMAGE CACHE SYSTEM =====
            
            loadImageCache() {
                try {
                    const cachedData = localStorage.getItem(this.cacheKey);
                    if (cachedData) {
                        const cache = JSON.parse(cachedData);
                        
                        // Clean expired cache entries
                        const now = Date.now();
                        const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;
                        
                        for (const [key, entry] of Object.entries(cache)) {
                            if (now - entry.timestamp < expiryTime) {
                                this.imageCache.set(key, entry);
                            }
                        }
                        
                        console.log(`📦 Loaded ${this.imageCache.size} cached images`);
                    }
                } catch (error) {
                    console.error('Error loading image cache:', error);
                    this.imageCache.clear();
                }
            }

            saveImageCache() {
                try {
                    const cacheObject = {};
                    for (const [key, value] of this.imageCache.entries()) {
                        cacheObject[key] = value;
                    }
                    localStorage.setItem(this.cacheKey, JSON.stringify(cacheObject));
                    console.log(`💾 Saved ${this.imageCache.size} images to cache`);
                } catch (error) {
                    console.error('Error saving image cache:', error);
                }
            }

            getCacheKey(article) {
                // Create a unique cache key based on article URL and title
                return `${this.getDomain(article.url)}_${article.url.substring(article.url.length - 20)}_${article.title.substring(0, 30)}`.replace(/[^a-zA-Z0-9]/g, '_');
            }

            getCachedImage(article) {
                const key = this.getCacheKey(article);
                const cached = this.imageCache.get(key);
                
                if (cached) {
                    const now = Date.now();
                    const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;
                    
                    if (now - cached.timestamp < expiryTime) {
                        console.log(`✅ Using cached image for: ${article.title.substring(0, 30)}...`);
                        return cached.imageUrl;
                    } else {
                        // Remove expired cache entry
                        this.imageCache.delete(key);
                        console.log(`⏰ Cache expired for: ${article.title.substring(0, 30)}...`);
                    }
                }
                
                return null;
            }

            setCachedImage(article, imageUrl) {
                const key = this.getCacheKey(article);
                this.imageCache.set(key, {
                    imageUrl: imageUrl,
                    timestamp: Date.now(),
                    domain: this.getDomain(article.url),
                    title: article.title.substring(0, 50)
                });
                
                // Save to localStorage (debounced)
                clearTimeout(this.cacheSaveTimeout);
                this.cacheSaveTimeout = setTimeout(() => this.saveImageCache(), 1000);
                
                console.log(`💾 Cached image for: ${article.title.substring(0, 30)}...`);
            }

            clearImageCache() {
                if (confirm('Clear all cached images?\n\nThis will force re-downloading images next time you visit.')) {
                    this.imageCache.clear();
                    localStorage.removeItem(this.cacheKey);
                    this.updateStatus('🗑️ Image cache cleared. Images will be re-downloaded next time.', 'success');
                    console.log('🗑️ Image cache cleared');
                }
            }

            getCacheStats() {
                return {
                    total: this.imageCache.size,
                    memoryUsage: JSON.stringify(Object.fromEntries(this.imageCache)).length,
                    oldestEntry: Math.min(...Array.from(this.imageCache.values()).map(entry => entry.timestamp)),
                    newestEntry: Math.max(...Array.from(this.imageCache.values()).map(entry => entry.timestamp))
                };
            }

            // ===== ENHANCED IMAGE LOADING WITH CACHE =====

            // Enhanced displayArticles with intelligent caching
            displayArticles(articles) {
                const container = document.getElementById('articlesContainer');

                if (articles.length === 0) {
                    this.displayEmptyState();
                    return;
                }

                const articlesHTML = articles.map((article, index) => {
                    const cachedImage = this.getCachedImage(article);
                    const cacheStatus = cachedImage ? 'cached' : 'fresh';
                    
                    return `
                    <div class="article-card" data-index="${index}">
                        <div class="article-image" id="image-${index}">
                            ${cachedImage ? this.createImageHTML(cachedImage, true) : this.createPlaceholderHTML()}
                            <div class="cache-indicator ${cacheStatus}">
                                ${cachedImage ? '💾 Cached' : '🔄 Loading'}
                            </div>
                        </div>
                        <div class="article-content" onclick="webReader.openReader(${index})">
                            <h2 class="article-title">${this.escapeHtml(article.title)}</h2>
                            <p class="article-excerpt">${this.escapeHtml(article.excerpt)}</p>
                            <div class="article-meta">
                                <span class="article-domain">🌐 ${this.getDomain(article.url)}</span>
                                <span class="article-date">📅 ${this.formatDate(article.dateAdded)}</span>
                            </div>
                            <div class="article-stats">
                                <span>⏱️ ${article.readTime || 1} min read</span>
                                <span>📝 ${article.wordCount || 0} words</span>
                            </div>
                        </div>
                        <div class="article-actions">
                            <button class="action-btn read-btn" onclick="event.stopPropagation(); webReader.openReader(${index})" title="Read article">
                                📖
                            </button>
                            <button class="action-btn export-btn" onclick="event.stopPropagation(); webReader.exportArticle(${index})" title="Export article">
                                📤
                            </button>
                            <button class="action-btn delete-btn" onclick="event.stopPropagation(); webReader.deleteArticle(${index})" title="Delete article">
                                🗑️
                            </button>
                        </div>
                    </div>
                `}).join('');

                container.innerHTML = `<div class="articles-grid">${articlesHTML}</div>`;
                
                // Count articles that need image extraction
                const articlesNeedingImages = articles.filter(article => !this.getCachedImage(article));
                
                if (articlesNeedingImages.length > 0) {
                    this.updateStatus(`📸 Loading ${articlesNeedingImages.length} new images (${this.imageCache.size} cached)...`, 'loading');
                    this.loadMissingImages(articles);
                } else {
                    this.updateStatus(`✅ All ${articles.length} images loaded from cache!`, 'success');
                }
            }

            createImageHTML(imageUrl, fromCache = false) {
                return `
                    <img src="${imageUrl}" 
                         alt="Article image" 
                         loading="lazy"
                         decoding="async"
                         style="
                            opacity: 0; 
                            transition: opacity 0.8s ease;
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            object-position: center;
                            border-radius: inherit;
                            aspect-ratio: 16/9;
                            min-height: 100px;
                            max-height: 120px;
                         "
                         onload="
                            this.style.opacity='1';
                            console.log('✅ Image loaded ${fromCache ? 'from cache' : 'successfully'}');
                         " 
                         onerror="
                            console.log('⚠️ Image failed, using fallback');
                            this.src='https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                            this.style.opacity='1';
                         ">
                `;
            }

            createPlaceholderHTML() {
                return `
                    <div style="
                        width: 100%; 
                        height: 100%; 
                        background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                                   linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                                   linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                                   linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
                        background-size: 20px 20px;
                        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: #999;
                        animation: shimmer 1.5s ease-in-out infinite;
                        aspect-ratio: 16/9;
                        min-height: 100px;
                        max-height: 120px;
                    ">
                        <div style="text-align: center;">
                            <div style="font-size: 1.2em; margin-bottom: 5px;">🖼️</div>
                            <div style="font-size: 0.7em;">Loading image...</div>
                        </div>
                    </div>
                `;
            }

            // Load only missing images (not cached)
            async loadMissingImages(articles) {
                console.log('🎨 SMART IMAGE LOADER - Loading only missing images...');
                
                const articlesNeedingImages = articles.filter((article, index) => {
                    const cached = this.getCachedImage(article);
                    return !cached;
                });

                if (articlesNeedingImages.length === 0) {
                    this.updateStatus(`✅ All images loaded from cache!`, 'success');
                    return;
                }

                let successCount = 0;
                const totalNew = articlesNeedingImages.length;
                
                console.log(`🔄 Loading ${totalNew} new images (${this.imageCache.size} already cached)`);
                
                // Load images sequentially to avoid overwhelming websites
                for (let i = 0; i < articlesNeedingImages.length; i++) {
                    const article = articlesNeedingImages[i];
                    const originalIndex = articles.findIndex(a => a === article);
                    
                    try {
                        const success = await this.extractAndCacheRealImage(article, originalIndex);
                        if (success) successCount++;
                        
                        // Update progress
                        const progress = Math.round(((i + 1) / totalNew) * 100);
                        this.updateStatus(`🔍 Loading new images... ${i + 1}/${totalNew} (${progress}%)`, 'loading');
                        
                        // Delay to be respectful to websites
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                    } catch (error) {
                        console.error(`Failed to extract image for article ${originalIndex}:`, error);
                        // Use category fallback for failed extractions
                        const fallbackImage = this.getCategoryBasedImage(article, originalIndex);
                        this.setArticleImageAndCache(article, originalIndex, fallbackImage, 'fallback');
                        successCount++;
                    }
                }
                
                const totalCached = this.imageCache.size;
                this.updateStatus(`✅ Loaded ${successCount}/${totalNew} new images! (${totalCached} total cached)`, 'success');
                console.log(`🎨 Smart image loading complete: ${successCount}/${totalNew} new, ${totalCached} total cached`);
            }

            // Extract and cache image (enhanced version)
            async extractAndCacheRealImage(article, index) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return false;

                console.log(`🔍 Extracting new image from: ${this.getDomain(article.url)}`);

                // Strategy 1: Try saved article images first (fastest)
                const savedImage = this.getBestArticleImage(article);
                if (savedImage) {
                    console.log(`✅ Using saved image: ${article.title.substring(0, 30)}...`);
                    this.setArticleImageAndCache(article, index, savedImage, 'saved');
                    return true;
                }

                // Strategy 2: Extract image from the original website
                try {
                    const extractedImage = await this.fetchRealImageFromWebsite(article.url);
                    if (extractedImage) {
                        console.log(`✅ Extracted real image: ${article.title.substring(0, 30)}...`);
                        this.setArticleImageAndCache(article, index, extractedImage, 'extracted');
                        return true;
                    }
                } catch (error) {
                    console.log(`⚠️ Could not extract from website: ${error.message}`);
                }

                // Strategy 3: Use intelligent category-based fallback
                console.log(`🎨 Using intelligent fallback: ${article.title.substring(0, 30)}...`);
                const fallbackImage = this.getCategoryBasedImage(article, index);
                this.setArticleImageAndCache(article, index, fallbackImage, 'fallback');
                return true;
            }

            // Set image and update cache
            setArticleImageAndCache(article, index, imageUrl, source) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return;

                // Create mobile-optimized image HTML
                let imageHTML;
                if (this.isFirefoxMobile) {
                    // Extra fixes for Firefox mobile
                    imageHTML = `
                        <img src="${imageUrl}" 
                             alt="Article image" 
                             loading="lazy"
                             decoding="async"
                             style="
                                opacity: 0; 
                                transition: opacity 0.8s ease;
                                width: 100% !important;
                                height: 100% !important;
                                object-fit: cover !important;
                                object-position: center !important;
                                -moz-object-fit: cover !important;
                                -moz-object-position: center !important;
                                border-radius: inherit;
                                aspect-ratio: 16/9;
                                min-height: ${this.isMobile ? '120px' : '100px'} !important;
                                max-height: ${this.isMobile ? '120px' : '100px'} !important;
                                display: block !important;
                                position: relative;
                                z-index: 1;
                             "
                             onload="
                                this.style.opacity='1';
                                console.log('✅ Firefox Mobile image loaded: ${article.title.substring(0, 20)}...');
                             " 
                             onerror="
                                console.log('⚠️ Image failed, using fallback');
                                this.src='https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                                this.style.opacity='1';
                             ">
                    `;
                } else {
                    imageHTML = this.createImageHTML(imageUrl, false);
                }

                // Update the DOM
                imageElement.innerHTML = imageHTML;
                
                // Update cache indicator
                const cacheIndicator = imageElement.querySelector('.cache-indicator');
                if (cacheIndicator) {
                    cacheIndicator.textContent = source === 'extracted' ? '🌐 Fresh' : '💾 Cached';
                    cacheIndicator.className = `cache-indicator ${source === 'extracted' ? 'fresh' : 'cached'}`;
                }

                // Cache the image
                this.setCachedImage(article, imageUrl);
            }

            checkAuthFromURL() {
                const hash = window.location.hash.substring(1);
                if (hash && hash.includes('access_token=')) {
                    const params = new URLSearchParams(hash);
                    const accessToken = params.get('access_token');
                    const error = params.get('error');

                    if (error) {
                        this.updateStatus(`Authentication error: ${error}`, 'error');
                        return;
                    }

                    if (accessToken) {
                        this.accessToken = accessToken;
                        this.saveToken(accessToken);
                        this.updateConnectionStatus(true);
                        this.loadArticles();
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }
                }
            }

            loadStoredToken() {
                this.accessToken = localStorage.getItem('mypocket_access_token');
                if (this.accessToken) {
                    this.updateConnectionStatus(true);
                    this.loadArticles();
                }
            }

            saveToken(token) {
                localStorage.setItem('mypocket_access_token', token);
            }

            clearToken() {
                localStorage.removeItem('mypocket_access_token');
                this.accessToken = null;
            }

            authenticate() {
                if (!this.redirectUri || (!this.redirectUri.startsWith('http://') && !this.redirectUri.startsWith('https://'))) {
                    this.updateStatus('❌ Invalid redirect URI. Please open this page via HTTP/HTTPS.', 'error');
                    console.error('🔴 Invalid redirect URI:', this.redirectUri);
                    alert(`Redirect URI Error:\n\nCurrent URI: ${this.redirectUri}\n\nPlease:\n1. Open this page via HTTP/HTTPS (not file://)\n2. Register this exact URI in Azure AD\n3. Use a web server to serve this file`);
                    return;
                }

                // Enhanced auth URL with longer token duration and better scope
                const authUrl = `https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize?` +
                    `client_id=${this.clientId}&` +
                    `response_type=token&` +
                    `redirect_uri=${encodeURIComponent(this.redirectUri)}&` +
                    `scope=${encodeURIComponent('Files.ReadWrite User.Read offline_access')}&` +
                    `response_mode=fragment&` +
                    `prompt=select_account&` +
                    `nonce=${Date.now()}`;

                console.log('🔵 Enhanced Auth URL:', authUrl);
                console.log('🔵 Encoded Redirect URI:', encodeURIComponent(this.redirectUri));

                this.updateStatus('🔄 Redirecting to Microsoft login...', 'loading');

                setTimeout(() => {
                    window.location.href = authUrl;
                }, 1000);
            }

            updateConnectionStatus(connected) {
                const connectBtn = document.getElementById('connectBtn');
                const connectIcon = document.getElementById('connectIcon');
                const connectText = document.getElementById('connectText');
                const refreshBtn = document.getElementById('refreshBtn');

                if (connected) {
                    connectIcon.textContent = '✅';
                    
                    // Show token expiration info if available
                    try {
                        const storedData = localStorage.getItem('mypocket_access_token');
                        if (storedData) {
                            const tokenData = JSON.parse(storedData);
                            const minutesLeft = Math.round((tokenData.expiresAt - Date.now()) / (60 * 1000));
                            connectText.textContent = `Connected (${minutesLeft}m left)`;
                        } else {
                            connectText.textContent = 'Connected';
                        }
                    } catch (error) {
                        connectText.textContent = 'Connected';
                    }
                    
                    connectBtn.style.background = 'rgba(39, 174, 96, 0.8)';
                    refreshBtn.style.display = 'inline-flex';
                } else {
                    connectIcon.textContent = '☁️';
                    connectText.textContent = 'Connect OneDrive';
                    connectBtn.style.background = 'rgba(255,255,255,0.2)';
                    refreshBtn.style.display = 'none';
                }
            }

            updateStatus(message, type = '') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }

            async makeAuthenticatedRequest(url, options = {}) {
                if (!this.accessToken) {
                    throw new Error('No access token available');
                }

                const headers = {
                    'Authorization': `Bearer ${this.accessToken}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                };

                try {
                    const response = await fetch(url, { ...options, headers });
                    
                    if (response.status === 401) {
                        console.log('🔑 Token expired, clearing and prompting for re-auth');
                        this.clearToken();
                        this.updateConnectionStatus(false);
                        this.updateStatus('🔑 Session expired. Please reconnect to OneDrive.', 'error');
                        
                        // Auto-prompt for re-authentication after a delay
                        setTimeout(() => {
                            if (confirm('Your OneDrive session has expired. Would you like to reconnect now?')) {
                                this.authenticate();
                            }
                        }, 2000);
                        
                        throw new Error('Authentication expired');
                    }
                    
                    return response;
                } catch (error) {
                    if (error.message === 'Authentication expired') {
                        throw error;
                    }
                    throw new Error(`Request failed: ${error.message}`);
                }
            }

            async loadArticles() {
                if (!this.accessToken) {
                    this.updateStatus('Not connected to OneDrive', 'error');
                    return;
                }

                try {
                    this.updateStatus('Loading articles... ⏳', 'loading');

                    const listResponse = await this.makeAuthenticatedRequest(
                        'https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket:/children'
                    );

                    if (!listResponse.ok) {
                        throw new Error(`Failed to list files: ${listResponse.status}`);
                    }

                    const fileList = await listResponse.json();
                    const backupFiles = fileList.value.filter(file =>
                        file.name.startsWith('mypocket-backup-') && file.name.endsWith('.json')
                    );

                    if (backupFiles.length === 0) {
                        this.updateStatus('No backup files found. Save some articles with the browser extension first.', 'error');
                        this.displayEmptyState();
                        return;
                    }

                    const latestFile = backupFiles.sort((a, b) =>
                        new Date(b.lastModifiedDateTime) - new Date(a.lastModifiedDateTime)
                    )[0];

                    const downloadResponse = await this.makeAuthenticatedRequest(
                        `https://graph.microsoft.com/v1.0/me/drive/items/${latestFile.id}/content`
                    );

                    if (!downloadResponse.ok) {
                        throw new Error(`Failed to download backup: ${downloadResponse.status}`);
                    }

                    const backupContent = await downloadResponse.text();
                    const backup = JSON.parse(backupContent);

                    this.articles = backup.articles || [];
                    this.displayArticles(this.articles);

                    const cacheStats = this.getCacheStats();
                    this.updateStatus(`✅ Loaded ${this.articles.length} articles from ${latestFile.name} (${cacheStats.total} images cached)`, 'success');

                } catch (error) {
                    console.error('Error loading articles:', error);
                    if (error.message === 'Authentication expired') {
                        // Already handled in makeAuthenticatedRequest
                        return;
                    }
                    this.updateStatus(`Error loading articles: ${error.message}`, 'error');
                }
            }

            displayEmptyState() {
                const container = document.getElementById('articlesContainer');
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">📖</div>
                        <h3>No articles found</h3>
                        <p>Use the MyPocket browser extension to save articles, then refresh this page.</p>
                    </div>`;
            }

            searchArticles(query) {
                if (!query) {
                    this.displayArticles(this.articles);
                    return;
                }

                const filtered = this.articles.filter(article =>
                    article.title.toLowerCase().includes(query.toLowerCase()) ||
                    article.textContent.toLowerCase().includes(query.toLowerCase()) ||
                    article.author.toLowerCase().includes(query.toLowerCase()) ||
                    this.getDomain(article.url).toLowerCase().includes(query.toLowerCase())
                );

                this.displayArticles(filtered);
                this.updateStatus(`Found ${filtered.length} articles matching "${query}"`, filtered.length > 0 ? 'success' : 'error');
            }

            openReader(index) {
                this.currentArticle = this.articles[index];
                const overlay = document.getElementById('readerOverlay');

                // Set title and meta info
                document.getElementById('readerTitle').textContent = this.currentArticle.title;
                document.getElementById('readerDate').textContent = this.formatDate(this.currentArticle.dateAdded);
                document.getElementById('readerDomain').textContent = this.getDomain(this.currentArticle.url);
                document.getElementById('readerTime').textContent = `${this.currentArticle.readTime || 1} min read`;
                
                // Show loading state first
                document.getElementById('readerContent').innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                        <p>Checking for article content...</p>
                    </div>
                `;

                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
                
                // Try to get content, fetch if needed
                setTimeout(() => this.loadArticleContent(this.currentArticle), 100);
            }

            async loadArticleContent(article) {
                console.log('🚀 CONTENT LOADER WITH CACHING');
                const contentElement = document.getElementById('readerContent');
                
                // First try to get saved content
                let content = this.getArticleContent(article);
                
                // If no saved content found, try to fetch from original URL
                if (!content) {
                    console.log('🌐 No saved content found. Attempting to fetch from original URL...');
                    
                    try {
                        // Show fetching status
                        contentElement.innerHTML = `
                            <div style="text-align: center; padding: 40px;">
                                <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                                <p><strong>🌐 Fetching article content...</strong></p>
                                <p style="font-size: 0.9em; color: var(--text-secondary);">
                                    Loading from ${this.getDomain(article.url)}
                                </p>
                                <p style="font-size: 0.8em; color: var(--text-secondary);">
                                    This may take a few seconds...
                                </p>
                            </div>
                        `;
                        
                        // Fetch content using proxy services
                        const fetchedContent = await this.fetchArticleContent(article.url);
                        
                        if (fetchedContent && fetchedContent.trim()) {
                            content = fetchedContent;
                            console.log('✅ Successfully fetched article content');
                            this.updateStatus('✅ Article content loaded successfully!', 'success');
                        } else {
                            throw new Error('No content extracted from fetched page');
                        }
                        
                    } catch (error) {
                        console.log('❌ Failed to fetch content:', error.message);
                        this.updateStatus('❌ Could not fetch article content. Using fallback.', 'error');
                        content = this.getFallbackContent(article, error.message);
                    }
                } else {
                    console.log('✅ Using saved content');
                    this.updateStatus('✅ Article loaded from saved content', 'success');
                }
                
                // Display the final content
                contentElement.innerHTML = content;
            }

            async fetchArticleContent(url) {
                try {
                    console.log(`🌐 Starting fetch for: ${url}`);
                    
                    // Method 1: Try using AllOrigins proxy (most reliable)
                    try {
                        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                        console.log(`Trying AllOrigins proxy...`);
                        
                        const response = await fetch(proxyUrl);
                        
                        if (response.ok) {
                            const data = await response.json();
                            const html = data.contents;
                            
                            if (html && html.length > 1000) { // Ensure we got substantial content
                                console.log(`✅ AllOrigins success: ${html.length} chars`);
                                const extractedContent = this.extractContentFromHTML(html, url);
                                if (extractedContent && extractedContent.length > 500) {
                                    return extractedContent;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`AllOrigins failed: ${error.message}`);
                    }
                    
                    // Method 2: Try CORS proxy
                    try {
                        const corsProxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                        console.log(`Trying CORS proxy...`);
                        
                        const response = await fetch(corsProxyUrl);
                        
                        if (response.ok) {
                            const html = await response.text();
                            
                            if (html && html.length > 1000) {
                                console.log(`✅ CORS proxy success: ${html.length} chars`);
                                const extractedContent = this.extractContentFromHTML(html, url);
                                if (extractedContent && extractedContent.length > 500) {
                                    return extractedContent;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`CORS proxy failed: ${error.message}`);
                    }
                    
                    // Method 3: Try direct fetch (will likely fail due to CORS, but worth trying)
                    try {
                        console.log(`Trying direct fetch...`);
                        const response = await fetch(url, {
                            mode: 'cors',
                            headers: {
                                'User-Agent': 'Mozilla/5.0 (compatible; MyPocket Reader)'
                            }
                        });
                        
                        if (response.ok) {
                            const html = await response.text();
                            console.log(`✅ Direct fetch success: ${html.length} chars`);
                            return this.extractContentFromHTML(html, url);
                        }
                    } catch (error) {
                        console.log(`Direct fetch failed (expected): ${error.message}`);
                    }
                    
                    throw new Error('All proxy methods failed to fetch content');
                    
                } catch (error) {
                    console.error('❌ All fetch methods failed:', error);
                    throw error;
                }
            }

            extractContentFromHTML(html, url) {
                try {
                    // Create a temporary DOM to parse the HTML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // Remove unwanted elements
                    const unwantedSelectors = [
                        'script', 'style', 'nav', 'header', 'footer', 
                        '.sidebar', '.menu', '.navigation', '.comments',
                        '.advertisement', '.ads', '.social-share',
                        '[role="banner"]', '[role="navigation"]', '[role="complementary"]'
                    ];
                    
                    unwantedSelectors.forEach(selector => {
                        doc.querySelectorAll(selector).forEach(el => el.remove());
                    });
                    
                    // Try to find the main content using common selectors
                    const contentSelectors = [
                        'article',
                        '[role="main"]',
                        '.post-content', '.entry-content', '.article-content',
                        '.content', '.main-content', '.post-body',
                        '.entry', '.post', '.article-body',
                        'main', '#content', '#main'
                    ];
                    
                    let contentElement = null;
                    
                    for (const selector of contentSelectors) {
                        contentElement = doc.querySelector(selector);
                        if (contentElement && contentElement.textContent.trim().length > 200) {
                            break;
                        }
                    }
                    
                    // If no main content found, try to get paragraphs from body
                    if (!contentElement || contentElement.textContent.trim().length < 200) {
                        const paragraphs = Array.from(doc.querySelectorAll('p'))
                            .filter(p => p.textContent.trim().length > 50)
                            .slice(0, 20); // Take first 20 substantial paragraphs
                        
                        if (paragraphs.length > 0) {
                            const div = doc.createElement('div');
                            paragraphs.forEach(p => div.appendChild(p.cloneNode(true)));
                            contentElement = div;
                        }
                    }
                    
                    if (contentElement) {
                        // Clean up the content
                        let content = contentElement.innerHTML;
                        
                        // Fix relative URLs to absolute
                        const baseUrl = new URL(url).origin;
                        content = content.replace(/src="\/([^"]+)"/g, `src="${baseUrl}/$1"`);
                        content = content.replace(/href="\/([^"]+)"/g, `href="${baseUrl}/$1"`);
                        
                        // Add a note about the source
                        content = `
                            <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                                <p style="margin: 0; font-size: 0.9em;">
                                    <strong>📡 Content fetched from original source</strong><br>
                                    This article content was retrieved in real-time from <a href="${url}" target="_blank" style="color: #1976d2;">${this.getDomain(url)}</a>
                                </p>
                            </div>
                            ${content}
                        `;
                        
                        return content;
                    }
                    
                    throw new Error('Could not extract readable content from page');
                    
                } catch (error) {
                    console.error('Content extraction error:', error);
                    throw error;
                }
            }

            getFallbackContent(article, errorMessage) {
                return `
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h3>📄 Content Not Available</h3>
                        <p>We couldn't load the full article content. This can happen because:</p>
                        <ul style="margin: 15px 0;">
                            <li>The website blocks automated content fetching</li>
                            <li>CORS (Cross-Origin) restrictions prevent access</li>
                            <li>The article content wasn't saved by the browser extension</li>
                            <li>Network connectivity issues</li>
                        </ul>
                        
                        <p><strong>What you can do:</strong></p>
                        <ol style="margin: 15px 0;">
                            <li><strong>Visit the original article</strong> using the button below</li>
                            <li><strong>Re-save the article</strong> with your browser extension</li>
                            <li><strong>Check extension settings</strong> for content extraction options</li>
                        </ol>
                        
                        <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <p><strong>Available excerpt:</strong></p>
                            <p style="font-style: italic;">${article.excerpt || 'No excerpt available'}</p>
                        </div>
                        
                        <div style="text-align: center; margin: 20px 0;">
                            <a href="${article.url}" target="_blank" style="display: inline-block; background: #ee5a24; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                                🔗 Read Full Article
                            </a>
                        </div>
                        
                        <details style="margin-top: 20px;">
                            <summary style="cursor: pointer; color: #666;">Technical Details</summary>
                            <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
                                Error: ${errorMessage}
                            </p>
                        </details>
                    </div>
                `;
            }

            // Get the best available content for reading - simplified version
            getArticleContent(article) {
                console.log('📖 Checking for saved content...');
                
                // Try content fields in order
                const contentFields = ['content', 'html', 'fullContent', 'textContent', 'body', 'readableContent', 'articleContent', 'savedContent'];
                
                for (const field of contentFields) {
                    if (article[field] && article[field].trim()) {
                        console.log(`✅ Found content in ${field} (${article[field].length} chars)`);
                        return article[field];
                    }
                }
                
                // Look for any substantial text content
                for (const [key, value] of Object.entries(article)) {
                    if (typeof value === 'string' && value.length > 200 && key !== 'excerpt' && key !== 'url') {
                        console.log(`✅ Found substantial content in ${key} (${value.length} chars)`);
                        return value;
                    }
                }
                
                console.log('❌ No saved content found');
                return null;
            }

            closeReader() {
                const overlay = document.getElementById('readerOverlay');
                overlay.classList.remove('active');
                document.body.style.overflow = 'auto';
            }

            openOriginal() {
                if (this.currentArticle) {
                    window.open(this.currentArticle.url, '_blank');
                }
            }

            async deleteArticle(index) {
                const article = this.articles[index];
                if (!article) return;

                if (confirm(`Delete "${article.title}"?\n\nThis will permanently remove the article from your OneDrive backup.`)) {
                    try {
                        // Remove from cache
                        const cacheKey = this.getCacheKey(article);
                        this.imageCache.delete(cacheKey);
                        this.saveImageCache();

                        this.articles.splice(index, 1);

                        if (this.accessToken) {
                            this.updateStatus('Updating OneDrive backup...', 'loading');
                            await this.updateOneDriveBackup();
                            this.updateStatus(`✅ Article deleted and backup updated. ${this.articles.length} articles remaining.`, 'success');
                        } else {
                            this.updateStatus(`❌ Article deleted locally but OneDrive backup not updated (not connected).`, 'error');
                        }

                        this.displayArticles(this.articles);

                    } catch (error) {
                        console.error('Error deleting article:', error);
                        this.updateStatus(`❌ Failed to delete article: ${error.message}`, 'error');
                    }
                }
            }

            exportArticle(index) {
                const article = this.articles[index];
                if (!article) return;

                try {
                    const html = this.createArticleHTML(article);
                    const filename = `${this.sanitizeFilename(article.title)}.html`;
                    this.downloadFile(html, filename, 'text/html');
                    this.updateStatus(`📤 Article "${article.title}" exported successfully!`, 'success');
                } catch (error) {
                    console.error('Error exporting article:', error);
                    this.updateStatus(`❌ Failed to export article: ${error.message}`, 'error');
                }
            }

            async updateOneDriveBackup() {
                if (!this.accessToken) {
                    throw new Error('Not connected to OneDrive');
                }

                const backup = {
                    articles: this.articles,
                    settings: {},
                    exportDate: new Date().toISOString(),
                    version: "3.3",
                    deviceInfo: {
                        browser: "Web Reader",
                        platform: navigator.platform,
                        timestamp: Date.now(),
                        articleCount: this.articles.length
                    }
                };

                const fileName = `mypocket-backup-${new Date().toISOString().split('T')[0]}.json`;
                const fileContent = JSON.stringify(backup, null, 2);

                const uploadUrl = `https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket/${fileName}:/content`;

                const uploadResponse = await this.makeAuthenticatedRequest(uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: fileContent
                });

                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    throw new Error(`Failed to update OneDrive backup: ${uploadResponse.status} - ${errorText}`);
                }

                return await uploadResponse.json();
            }

            createArticleHTML(article) {
                return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHtml(article.title)}</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 40px 20px; 
            line-height: 1.7; 
            color: #333;
        }
        .header { 
            border-bottom: 3px solid #ee5a24; 
            margin-bottom: 32px; 
            padding-bottom: 24px; 
        }
        .title { 
            font-size: 2.4em; 
            font-weight: bold; 
            margin-bottom: 16px; 
            color: #2c3e50; 
            line-height: 1.2; 
        }
        .meta { 
            color: #7f8c8d; 
            font-size: 0.95em; 
            margin-bottom: 24px; 
        }
        .content { 
            font-size: 1.15em; 
            line-height: 1.8; 
        }
        .content img { 
            max-width: 100%; 
            height: auto; 
            margin: 24px 0; 
            border-radius: 8px; 
        }
        .content p { 
            margin-bottom: 1.4em; 
        }
        .footer { 
            margin-top: 48px; 
            padding-top: 24px; 
            border-top: 2px solid #f0f0f0; 
            color: #666; 
            font-size: 0.9em; 
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">${this.escapeHtml(article.title)}</h1>
        <div class="meta">
            <div style="margin-bottom: 8px;">🌐 From: <a href="${article.url}" style="color: #ee5a24;">${this.getDomain(article.url)}</a></div>
            ${article.author ? `<div style="margin-bottom: 8px;">✍️ By: ${this.escapeHtml(article.author)}</div>` : ''}
            <div style="margin-bottom: 8px;">📅 Saved: ${this.formatDate(article.dateAdded)}</div>
            <div>⏱️ Reading time: ${article.readTime || 1} minutes</div>
        </div>
    </div>
    <div class="content">
        ${article.content}
    </div>
    <div class="footer">
        <p><strong>✨ Exported from MyPocket Web Reader</strong></p>
        <p>Original URL: <a href="${article.url}" style="color: #ee5a24;">${article.url}</a></p>
        <p>Export Date: ${new Date().toLocaleDateString()}</p>
    </div>
</body>
</html>`;
            }

            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                URL.revokeObjectURL(url);
            }

            // Enhanced image handling
            getBestArticleImage(article) {
                if (article.images && article.images.length > 0) {
                    let bestImage = article.images[0];
                    
                    for (const img of article.images) {
                        if (img.width && img.height) {
                            if (img.width >= 300 && img.height >= 150) {
                                bestImage = img;
                                break;
                            }
                        }
                    }
                    
                    return bestImage.src || bestImage.url || bestImage;
                }
                
                if (article.featuredImage) {
                    return article.featuredImage;
                }
                
                if (article.image) {
                    return article.image;
                }
                
                if (article.content) {
                    const imgMatch = article.content.match(/<img[^>]+src="([^"]+)"/i);
                    if (imgMatch && imgMatch[1]) {
                        return imgMatch[1];
                    }
                }
                
                return null;
            }

            // NEW: Fetch the actual featured image from a website
            async fetchRealImageFromWebsite(url) {
                try {
                    console.log(`🌐 Fetching webpage to extract image: ${url}`);
                    
                    // Method 1: Try AllOrigins proxy
                    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                    const response = await fetch(proxyUrl);
                    
                    if (!response.ok) {
                        throw new Error('Failed to fetch webpage');
                    }
                    
                    const data = await response.json();
                    const html = data.contents;
                    
                    if (!html || html.length < 500) {
                        throw new Error('No substantial HTML content received');
                    }
                    
                    // Parse the HTML and extract the best image
                    const extractedImageUrl = this.parseHTMLForBestImage(html, url);
                    
                    if (extractedImageUrl) {
                        console.log(`🎯 Found image: ${extractedImageUrl}`);
                        return extractedImageUrl;
                    }
                    
                    throw new Error('No suitable image found in webpage');
                    
                } catch (error) {
                    console.log(`❌ Website image extraction failed: ${error.message}`);
                    
                    // Try alternative proxy methods
                    try {
                        return await this.tryAlternativeImageExtraction(url);
                    } catch (altError) {
                        console.log(`❌ Alternative extraction also failed: ${altError.message}`);
                        throw error;
                    }
                }
            }

            // NEW: Parse HTML to find the best image
            parseHTMLForBestImage(html, baseUrl) {
                try {
                    // Create a DOM parser
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // Strategy 1: Look for Open Graph image (most reliable)
                    const ogImage = doc.querySelector('meta[property="og:image"]');
                    if (ogImage) {
                        const imageUrl = this.makeAbsoluteUrl(ogImage.getAttribute('content'), baseUrl);
                        if (this.isValidImageUrl(imageUrl)) {
                            console.log(`🎯 Found Open Graph image: ${imageUrl}`);
                            return imageUrl;
                        }
                    }
                    
                    // Strategy 2: Look for Twitter card image
                    const twitterImage = doc.querySelector('meta[name="twitter:image"], meta[property="twitter:image"]');
                    if (twitterImage) {
                        const imageUrl = this.makeAbsoluteUrl(twitterImage.getAttribute('content'), baseUrl);
                        if (this.isValidImageUrl(imageUrl)) {
                            console.log(`🎯 Found Twitter card image: ${imageUrl}`);
                            return imageUrl;
                        }
                    }
                    
                    // Strategy 3: Look for article featured image
                    const featuredSelectors = [
                        '.featured-image img',
                        '.hero-image img',
                        '.post-thumbnail img',
                        '.article-image img',
                        '.entry-image img',
                        '.wp-post-image',
                        'article img:first-of-type',
                        '.content img:first-of-type',
                        '.post-content img:first-of-type'
                    ];
                    
                    for (const selector of featuredSelectors) {
                        const img = doc.querySelector(selector);
                        if (img) {
                            const src = img.getAttribute('src') || img.getAttribute('data-src') || img.getAttribute('data-lazy-src');
                            if (src) {
                                const imageUrl = this.makeAbsoluteUrl(src, baseUrl);
                                if (this.isValidImageUrl(imageUrl) && !this.isIconOrLogo(src)) {
                                    console.log(`🎯 Found featured image: ${imageUrl}`);
                                    return imageUrl;
                                }
                            }
                        }
                    }
                    
                    // Strategy 4: Look for the first substantial image in the content
                    const allImages = Array.from(doc.querySelectorAll('img')).filter(img => {
                        const src = img.getAttribute('src') || img.getAttribute('data-src');
                        const width = img.getAttribute('width') || img.style.width;
                        const height = img.getAttribute('height') || img.style.height;
                        
                        // Filter out small images, icons, and logos
                        return src && 
                               !this.isIconOrLogo(src) && 
                               !this.isSmallImage(width, height) &&
                               !src.includes('avatar') &&
                               !src.includes('profile');
                    });
                    
                    for (const img of allImages) {
                        const src = img.getAttribute('src') || img.getAttribute('data-src');
                        if (src) {
                            const imageUrl = this.makeAbsoluteUrl(src, baseUrl);
                            if (this.isValidImageUrl(imageUrl)) {
                                console.log(`🎯 Found content image: ${imageUrl}`);
                                return imageUrl;
                            }
                        }
                    }
                    
                    // Strategy 5: Look for images in JSON-LD structured data
                    const jsonLdScripts = doc.querySelectorAll('script[type="application/ld+json"]');
                    for (const script of jsonLdScripts) {
                        try {
                            const data = JSON.parse(script.textContent);
                            const image = this.extractImageFromJsonLd(data);
                            if (image) {
                                const imageUrl = this.makeAbsoluteUrl(image, baseUrl);
                                if (this.isValidImageUrl(imageUrl)) {
                                    console.log(`🎯 Found JSON-LD image: ${imageUrl}`);
                                    return imageUrl;
                                }
                            }
                        } catch (e) {
                            // Ignore malformed JSON-LD
                        }
                    }
                    
                    console.log(`❌ No suitable image found in HTML`);
                    return null;
                    
                } catch (error) {
                    console.error('HTML parsing error:', error);
                    return null;
                }
            }

            // NEW: Extract image from JSON-LD structured data
            extractImageFromJsonLd(data) {
                if (typeof data !== 'object') return null;
                
                // Handle arrays
                if (Array.isArray(data)) {
                    for (const item of data) {
                        const image = this.extractImageFromJsonLd(item);
                        if (image) return image;
                    }
                    return null;
                }
                
                // Look for image properties
                if (data.image) {
                    if (typeof data.image === 'string') return data.image;
                    if (Array.isArray(data.image) && data.image.length > 0) {
                        return typeof data.image[0] === 'string' ? data.image[0] : data.image[0].url;
                    }
                    if (data.image.url) return data.image.url;
                }
                
                // Look for thumbnailUrl
                if (data.thumbnailUrl) {
                    return typeof data.thumbnailUrl === 'string' ? data.thumbnailUrl : data.thumbnailUrl.url;
                }
                
                // Recursively search nested objects
                for (const key in data) {
                    if (typeof data[key] === 'object') {
                        const image = this.extractImageFromJsonLd(data[key]);
                        if (image) return image;
                    }
                }
                
                return null;
            }

            // NEW: Try alternative image extraction methods
            async tryAlternativeImageExtraction(url) {
                // Method 1: Try CORS proxy
                try {
                    const corsProxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                    const response = await fetch(corsProxyUrl);
                    
                    if (response.ok) {
                        const html = await response.text();
                        const extractedImage = this.parseHTMLForBestImage(html, url);
                        if (extractedImage) return extractedImage;
                    }
                } catch (error) {
                    console.log(`CORS proxy failed: ${error.message}`);
                }
                
                // Method 2: Try to guess common image patterns based on URL
                const guessedImage = this.guessImageFromUrl(url);
                if (guessedImage) return guessedImage;
                
                throw new Error('All alternative extraction methods failed');
            }

            // NEW: Guess image from URL patterns (for known sites)
            guessImageFromUrl(url) {
                const domain = this.getDomain(url).toLowerCase();
                
                // Medium articles often have predictable image patterns
                if (domain.includes('medium.com')) {
                    // Try to extract the article ID and construct image URL
                    const match = url.match(/\/([a-f0-9]+)$/);
                    if (match) {
                        return `https://miro.medium.com/max/1400/1*${match[1]}.png`;
                    }
                }
                
                // GitHub repository images
                if (domain.includes('github.com')) {
                    const pathMatch = url.match(/github\.com\/([^\/]+)\/([^\/]+)/);
                    if (pathMatch) {
                        return `https://opengraph.githubassets.com/1/${pathMatch[1]}/${pathMatch[2]}`;
                    }
                }
                
                // YouTube videos
                if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                    const videoIdMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/);
                    if (videoIdMatch) {
                        return `https://img.youtube.com/vi/${videoIdMatch[1]}/maxresdefault.jpg`;
                    }
                }
                
                return null;
            }

            // Enhanced URL validation
            isValidImageUrl(url) {
                if (!url || typeof url !== 'string') return false;
                
                // Must be a valid URL
                try {
                    new URL(url);
                } catch {
                    return false;
                }
                
                // Must have common image extensions or be from known image services
                const imagePattern = /\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i;
                const imageServices = ['unsplash.com', 'images.unsplash.com', 'picsum.photos', 'via.placeholder.com'];
                
                return imagePattern.test(url) || imageServices.some(service => url.includes(service));
            }

            // Enhanced icon/logo detection
            isIconOrLogo(src) {
                if (!src) return false;
                
                const iconPatterns = [
                    'icon', 'logo', 'avatar', 'profile', 'favicon', 'sprite', 
                    'button', 'badge', 'social', 'thumb', 'thumbnail',
                    '/icons/', '/images/icons/', 'gravatar', 'user-content'
                ];
                
                const srcLower = src.toLowerCase();
                return iconPatterns.some(pattern => srcLower.includes(pattern)) ||
                       srcLower.includes('.ico') ||
                       (srcLower.includes('64x64') || srcLower.includes('32x32'));
            }

            // Check if image dimensions suggest it's too small
            isSmallImage(width, height) {
                if (!width && !height) return false;
                
                const w = parseInt(width) || 0;
                const h = parseInt(height) || 0;
                
                return (w > 0 && w < 200) || (h > 0 && h < 150);
            }

            // NEW: Get category-based images that always work
            getCategoryBasedImage(article, index) {
                const domain = this.getDomain(article.url).toLowerCase();
                const title = article.title.toLowerCase();
                
                // Use reliable image services that work well with direct img tags
                
                // Technology/Programming
                if (domain.includes('github') || domain.includes('stackoverflow') || domain.includes('dev.to') ||
                    title.includes('code') || title.includes('programming') || title.includes('javascript') || title.includes('react')) {
                    return `https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Business/Finance
                if (domain.includes('business') || domain.includes('finance') || domain.includes('linkedin') ||
                    title.includes('business') || title.includes('finance') || title.includes('startup') || title.includes('entrepreneur')) {
                    return `https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Design/Creative
                if (domain.includes('dribbble') || domain.includes('behance') || 
                    title.includes('design') || title.includes('ui') || title.includes('ux') || title.includes('creative')) {
                    return `https://images.unsplash.com/photo-1561070791-2526d30994b5?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // News/Media
                if (domain.includes('news') || domain.includes('bbc') || domain.includes('cnn') ||
                    title.includes('news') || title.includes('politics') || title.includes('media')) {
                    return `https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Travel/Adventure
                if (title.includes('travel') || title.includes('vacation') || title.includes('adventure') || title.includes('journey')) {
                    return `https://images.unsplash.com/photo-1488646953014-85cb44e25828?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Food/Cooking
                if (title.includes('food') || title.includes('recipe') || title.includes('cooking') || title.includes('restaurant')) {
                    return `https://images.unsplash.com/photo-1504674900247-0877df9cc836?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Health/Fitness
                if (title.includes('health') || title.includes('fitness') || title.includes('exercise') || title.includes('wellness')) {
                    return `https://images.unsplash.com/photo-1571019613454-1cb2f99b2d8b?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Science/Research
                if (domain.includes('arxiv') || domain.includes('research') ||
                    title.includes('science') || title.includes('research') || title.includes('study') || title.includes('data')) {
                    return `https://images.unsplash.com/photo-1532094349884-543bc11b234d?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Education/Learning
                if (domain.includes('edu') || title.includes('learn') || title.includes('education') || title.includes('course')) {
                    return `https://images.unsplash.com/photo-1523240795612-9a054b0db644?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Photography/Art
                if (title.includes('photo') || title.includes('art') || title.includes('gallery') || title.includes('visual')) {
                    return `https://images.unsplash.com/photo-1542909168-82c3e7fdca5c?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Technology (general)
                if (domain.includes('tech') || title.includes('tech') || title.includes('digital') || title.includes('innovation')) {
                    return `https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Books/Reading/Writing
                if (domain.includes('medium') || domain.includes('blog') ||
                    title.includes('book') || title.includes('read') || title.includes('write') || title.includes('story')) {
                    return `https://images.unsplash.com/photo-1481627834876-b7833e8f5570?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Music/Entertainment
                if (title.includes('music') || title.includes('entertainment') || title.includes('movie') || title.includes('film')) {
                    return `https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Sports
                if (title.includes('sport') || title.includes('game') || title.includes('team') || title.includes('player')) {
                    return `https://images.unsplash.com/photo-1461896836934-ffe607ba8211?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Nature/Environment
                if (title.includes('nature') || title.includes('environment') || title.includes('climate') || title.includes('green')) {
                    return `https://images.unsplash.com/photo-1441974231531-c6227db76b6e?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }
                
                // Default beautiful images based on index
                const defaultImages = [
                    'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Mountain landscape
                    'https://images.unsplash.com/photo-1511593358241-7eea1f3c84e5?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Abstract colorful
                    'https://images.unsplash.com/photo-1519681393784-d120267933ba?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Space/galaxy
                    'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Ocean waves
                    'https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // City skyline
                    'https://images.unsplash.com/photo-1470115636492-6d2b56f9146d?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Forest/trees
                    'https://images.unsplash.com/photo-1503023345310-bd7c1de61c7d?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Sunset/sunrise
                    'https://images.unsplash.com/photo-1558618047-3c8c76ca7d13?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Architecture
                    'https://images.unsplash.com/photo-1506744038136-46273834b3fb?w=400&h=250&fit=crop&crop=center&q=80&auto=format', // Lake reflection
                    'https://images.unsplash.com/photo-1518837695005-2083093ee35b?w=400&h=250&fit=crop&crop=center&q=80&auto=format'  // Geometric pattern
                ];
                
                return defaultImages[index % defaultImages.length];
            }

            // Convert relative URLs to absolute
            makeAbsoluteUrl(imageUrl, baseUrl) {
                if (!imageUrl) return null;
                
                try {
                    // If already absolute, return as-is
                    if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                        return imageUrl;
                    }
                    
                    // Handle protocol-relative URLs
                    if (imageUrl.startsWith('//')) {
                        return 'https:' + imageUrl;
                    }
                    
                    // If relative, make it absolute
                    const base = new URL(baseUrl);
                    return new URL(imageUrl, base.origin).href;
                } catch (error) {
                    console.log(`Failed to make absolute URL: ${imageUrl}, base: ${baseUrl}`);
                    return null;
                }
            }

            // Smart icon selection based on domain
            getArticleIcon(url) {
                const domain = this.getDomain(url).toLowerCase();
                
                const siteIcons = {
                    'youtube.com': '📺',
                    'github.com': '🐙',
                    'stackoverflow.com': '💻',
                    'medium.com': '📝',
                    'dev.to': '👨‍💻',
                    'twitter.com': '🐦',
                    'x.com': '🐦',
                    'linkedin.com': '💼',
                    'reddit.com': '🔴',
                    'hackernews.ycombinator.com': '🟠',
                    'techcrunch.com': '📰',
                    'theverge.com': '📱',
                    'arstechnica.com': '🔬',
                    'wired.com': '⚡',
                    'bbc.com': '📺',
                    'cnn.com': '📰',
                    'nytimes.com': '📰',
                    'guardian.co.uk': '📰',
                    'washingtonpost.com': '📰',
                    'wikipedia.org': '📖',
                    'arxiv.org': '🎓',
                };
                
                for (const [siteDomain, icon] of Object.entries(siteIcons)) {
                    if (domain.includes(siteDomain)) {
                        return icon;
                    }
                }
                
                if (domain.includes('blog') || domain.includes('medium')) return '📝';
                if (domain.includes('news')) return '📰';
                if (domain.includes('tech')) return '💻';
                if (domain.includes('code') || domain.includes('dev')) return '👨‍💻';
                if (domain.includes('video') || domain.includes('tube')) return '📺';
                if (domain.includes('music') || domain.includes('spotify')) return '🎵';
                if (domain.includes('photo') || domain.includes('image')) return '📸';
                if (domain.includes('shop') || domain.includes('store')) return '🛒';
                if (domain.includes('book') || domain.includes('read')) return '📚';
                if (domain.includes('learn') || domain.includes('edu')) return '🎓';
                
                return '📄';
            }

            getDomain(url) {
                try {
                    return new URL(url).hostname.replace('www.', '');
                } catch (e) {
                    return url;
                }
            }

            formatDate(dateString) {
                try {
                    const date = new Date(dateString);

                    if (isNaN(date.getTime())) {
                        console.error('Invalid date:', dateString);
                        return 'invalid date';
                    }

                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const targetDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                    const diffMs = today.getTime() - targetDate.getTime();
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

                    if (diffDays < 0) {
                        return date.toLocaleDateString();
                    }

                    if (diffDays === 0) {
                        return 'today';
                    } else if (diffDays === 1) {
                        return 'yesterday';
                    } else if (diffDays <= 7) {
                        return `${diffDays} days ago`;
                    } else if (diffDays <= 30) {
                        const weeks = Math.floor(diffDays / 7);
                        return weeks === 1 ? '1 week ago' : `${weeks} weeks ago`;
                    } else if (diffDays <= 365) {
                        const months = Math.floor(diffDays / 30);
                        return months === 1 ? '1 month ago' : `${months} months ago`;
                    } else {
                        const years = Math.floor(diffDays / 365);
                        return years === 1 ? '1 year ago' : `${years} years ago`;
                    }
                } catch (error) {
                    console.error('Date formatting error:', error, 'Input:', dateString);
                    return 'date error';
                }
            }

            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            sanitizeFilename(filename) {
                if (!filename) return 'article';
                return filename.replace(/[^a-z0-9\s]/gi, '_').toLowerCase().substring(0, 50);
            }

            showDebugInfo() {
                const cacheStats = this.getCacheStats();
                
                // Get token info
                let tokenInfo = 'No token stored';
                try {
                    const storedData = localStorage.getItem('mypocket_access_token');
                    if (storedData) {
                        const tokenData = JSON.parse(storedData);
                        const minutesLeft = Math.round((tokenData.expiresAt - Date.now()) / (60 * 1000));
                        const isExpired = Date.now() > tokenData.expiresAt;
                        tokenInfo = `${isExpired ? 'EXPIRED' : 'Valid'} - ${isExpired ? 'Expired' : minutesLeft + ' minutes left'}`;
                    }
                } catch (error) {
                    tokenInfo = 'Error reading token data';
                }
                
                const info = `
MyPocket Web Reader Debug Info:
=====================================

Current URL: ${window.location.href}
Redirect URI: ${this.redirectUri}
Client ID: ${this.clientId}
Protocol: ${window.location.protocol}
Host: ${window.location.host}
Has Access Token: ${!!this.accessToken}
Token Status: ${tokenInfo}
Articles Loaded: ${this.articles.length}

Device & Browser Info:
- User Agent: ${navigator.userAgent}
- Is Mobile: ${this.isMobile}
- Is Firefox Mobile: ${this.isFirefoxMobile}
- Screen Size: ${window.innerWidth}x${window.innerHeight}
- Device Pixel Ratio: ${window.devicePixelRatio || 1}
- Touch Support: ${'ontouchstart' in window}

Image Cache Stats:
- Total Cached Images: ${cacheStats.total}
- Memory Usage: ${Math.round(cacheStats.memoryUsage / 1024)} KB
- Cache Expiry: ${this.cacheExpiryDays} days
- Oldest Entry: ${cacheStats.total > 0 ? new Date(cacheStats.oldestEntry).toLocaleDateString() : 'N/A'}
- Newest Entry: ${cacheStats.total > 0 ? new Date(cacheStats.newestEntry).toLocaleDateString() : 'N/A'}

Mobile Optimizations Applied:
- Enhanced image object-fit handling
- Firefox mobile specific CSS fixes
- Aspect ratio preservation (16:9)
- Touch-friendly interface adjustments
- Simplified border radius on mobile
- Increased touch targets (44px minimum)

Token Management:
- Access tokens expire after ~1 hour
- App tracks expiration and warns before expiry
- Auto-prompts for re-authentication when needed
- Enhanced error handling for expired sessions

Common Mobile Issues Fixed:
1. Image stretching in Firefox mobile ✅
2. Touch target sizes too small ✅  
3. Viewport scaling problems ✅
4. Object-fit compatibility ✅
5. Border radius rendering issues ✅

Azure AD Redirect URI Requirements:
- Must be absolute URI (http:// or https://)
- Must be registered in Azure AD App Registration
- Must match exactly (including trailing slashes)

Next Steps for Mobile Issues:
1. Check if images still appear stretched
2. Test touch interactions work properly  
3. Verify text is readable without zooming
4. Confirm buttons are easily tappable
5. Report any remaining visual issues

Image Cache Features:
- Images are cached for ${this.cacheExpiryDays} days
- Cache survives browser sessions
- Use "Clear Cache" button to force refresh
- Cached images load instantly on subsequent visits

Token Expiration Solutions:
- App now tracks token expiration time
- Shows remaining time in connection status
- Warns 5 minutes before expiration
- Auto-prompts for re-authentication when expired
- Enhanced error handling for all API calls
                `;

                alert(info);
                console.log('🔧 Debug Info:', {
                    currentUrl: window.location.href,
                    redirectUri: this.redirectUri,
                    clientId: this.clientId,
                    protocol: window.location.protocol,
                    hasToken: !!this.accessToken,
                    tokenInfo: tokenInfo,
                    articlesCount: this.articles.length,
                    cacheStats: cacheStats
                });
            }

            toggleTestMode() {
                document.body.classList.toggle('test-mode');
                const isTestMode = document.body.classList.contains('test-mode');

                const testBtn = document.getElementById('testBtn');
                if (testBtn) {
                    testBtn.innerHTML = isTestMode
                        ? '<span>👁️</span> Hide Buttons'
                        : '<span>👁️</span> Show Buttons';
                }

                this.updateStatus(
                    isTestMode
                        ? '🔍 Test mode ON - Action buttons always visible'
                        : '👁️ Test mode OFF - Action buttons show on hover',
                    'success'
                );
            }

            // Dark mode functionality
            toggleDarkMode() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                
                this.updateDarkModeButton(newTheme);
                this.updateStatus(
                    newTheme === 'dark' ? '🌙 Dark mode enabled' : '☀️ Light mode enabled',
                    'success'
                );
            }

            loadThemePreference() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                document.documentElement.setAttribute('data-theme', savedTheme);
                this.updateDarkModeButton(savedTheme);
            }

            updateDarkModeButton(theme) {
                const darkModeBtn = document.getElementById('darkModeBtn');
                if (darkModeBtn) {
                    darkModeBtn.innerHTML = theme === 'dark' 
                        ? '<span>☀️</span> Light Mode'
                        : '<span>🌙</span> Dark Mode';
                }
            }
        }

        let webReader;
        document.addEventListener('DOMContentLoaded', () => {
            webReader = new MyPocketWebReader();
            window.webReader = webReader;
        });
    </script>
</body>

</html>
