<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyPocket - Web Reader (FIXED: Manual Categories + Local Cache)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #ee5a24;
            --secondary-color: #667eea;
            --background: #f8f9fa;
            --surface: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --border: #e9ecef;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        /* Enhanced Dark mode with better contrast */
        [data-theme="dark"] {
            --primary-color: #ff6b35;
            --secondary-color: #7b88f7;
            --background: #0d1117;
            --surface: #161b22;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --border: #30363d;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.6);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.8);
        }

        /* Dark mode specific improvements */
        [data-theme="dark"] .article-card {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .article-card:hover {
            border-color: #484f58;
            transform: translateY(-2px) scale(1.02);
        }

        [data-theme="dark"] .search-input {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .search-input:focus {
            border-color: var(--primary-color);
            background: var(--surface);
        }

        [data-theme="dark"] .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.8;
        }

        [data-theme="dark"] .search-close-btn:hover {
            background: #21262d;
            color: var(--text-primary);
        }

        [data-theme="dark"] .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border-color: var(--border);
        }

        [data-theme="dark"] .btn-secondary:hover {
            background: #21262d;
            border-color: #484f58;
            color: var(--text-primary);
        }

        [data-theme="dark"] .action-btn {
            background: rgba(22, 27, 34, 0.95);
            border-color: var(--border);
            color: var(--text-primary);
            backdrop-filter: blur(10px);
        }

        [data-theme="dark"] .action-btn:hover {
            background: rgba(33, 38, 45, 0.95);
            border-color: #484f58;
        }

        [data-theme="dark"] .read-btn:hover {
            background: rgba(13, 110, 253, 0.2);
            border-color: #0d6efd;
            color: #58a6ff;
        }

        [data-theme="dark"] .export-btn:hover {
            background: rgba(25, 135, 84, 0.2);
            border-color: #198754;
            color: #3fb950;
        }

        [data-theme="dark"] .refresh-image-btn:hover {
            background: rgba(255, 152, 0, 0.2);
            border-color: #ff9800;
            color: #ffb74d;
        }

        [data-theme="dark"] .delete-btn:hover {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #f85149;
        }

        [data-theme="dark"] .reader-container {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .reader-header {
            background: var(--background);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .reader-content {
            color: var(--text-primary);
        }

        [data-theme="dark"] .reader-content h1,
        [data-theme="dark"] .reader-content h2,
        [data-theme="dark"] .reader-content h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .reader-content blockquote {
            background: var(--background);
            border-left-color: var(--primary-color);
        }

        [data-theme="dark"] .close-reader {
            background: var(--primary-color);
        }

        [data-theme="dark"] .empty-state {
            color: var(--text-secondary);
        }

        [data-theme="dark"] .empty-state h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .connection-status.connected {
            background: rgba(25, 135, 84, 0.2);
            border-color: #198754;
            color: #3fb950;
        }

        [data-theme="dark"] .connection-status.disconnected {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #f85149;
        }

        /* NEW: Enhanced dark mode styles for cache indicators */
        [data-theme="dark"] .cache-indicator.synced {
            background: rgba(76, 175, 80, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.fallback {
            background: rgba(255, 152, 0, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.metadata {
            background: rgba(103, 58, 183, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.error {
            background: rgba(244, 67, 54, 0.9);
            color: white;
        }

        /* NEW: AI categorization indicator */
        [data-theme="dark"] .cache-indicator.ai-categorized {
            background: rgba(76, 175, 80, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.smart-categorized {
            background: rgba(103, 58, 183, 0.9);
            color: white;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--background);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            color: white;
            padding: 20px 0;
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-left: 60px;
            /* Account for sidebar */
        }

        .logo {
            font-size: 1.8em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* Left Sidebar - Pocket Style */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: var(--surface);
            border-right: 1px solid var(--border);
            z-index: 101;
            overflow-y: auto;
            transition: transform 0.3s ease;
            box-shadow: var(--shadow);
        }

        .sidebar.collapsed {
            transform: translateX(-220px);
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: var(--background);
        }

        .sidebar-brand {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.2em;
            font-weight: 600;
            color: var(--text-primary);
        }

        .sidebar-toggle {
            position: absolute;
            right: -40px;
            top: 20px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0 8px 8px 0;
            padding: 8px;
            cursor: pointer;
            color: var(--text-primary);
            transition: all 0.2s ease;
            z-index: 102;
        }

        .sidebar-toggle:hover {
            background: var(--primary-color);
            color: white;
        }

        .sidebar-nav {
            padding: 20px 0;
        }

        .nav-section {
            margin-bottom: 30px;
        }

        .nav-section-title {
            padding: 0 20px 10px;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            letter-spacing: 0.5px;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            color: var(--text-primary);
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 14px;
        }

        .nav-item:hover {
            background: var(--background);
            color: var(--primary-color);
        }

        .nav-item.active {
            background: var(--primary-color);
            color: white;
            border-right: 3px solid var(--secondary-color);
        }

        .nav-item .icon {
            width: 20px;
            text-align: center;
            font-size: 16px;
        }

        .nav-item .text {
            flex: 1;
        }

        .nav-item .badge {
            background: var(--border);
            color: var(--text-secondary);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: 500;
        }

        .nav-item.active .badge {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        /* Connection Status in Sidebar */
        .connection-panel {
            padding: 15px 20px;
            margin: 10px 0;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
        }

        .connection-status-sidebar {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9em;
        }

        .connection-status-sidebar.connected {
            color: #27ae60;
        }

        .connection-status-sidebar.disconnected {
            color: #e74c3c;
        }

        .connect-btn-sidebar {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .connect-btn-sidebar:hover {
            background: var(--secondary-color);
            transform: translateY(-1px);
        }

        .connect-btn-sidebar.connected {
            background: #27ae60;
        }

        /* Main Content Area */
        .main-content {
            margin-left: 280px;
            min-height: 100vh;
            transition: margin-left 0.3s ease;
        }

        .main-content.sidebar-collapsed {
            margin-left: 60px;
        }

        /* Mobile Sidebar */
        .mobile-header {
            display: none;
        }

        /* Dark mode sidebar styles */
        [data-theme="dark"] .sidebar {
            background: var(--surface);
            border-right-color: var(--border);
        }

        [data-theme="dark"] .sidebar-header {
            background: var(--background);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .sidebar-brand {
            color: var(--text-primary);
        }

        [data-theme="dark"] .sidebar-toggle {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .sidebar-toggle:hover {
            background: var(--primary-color);
            color: white;
        }

        [data-theme="dark"] .nav-section-title {
            color: var(--text-secondary);
        }

        [data-theme="dark"] .nav-item {
            color: var(--text-primary);
        }

        [data-theme="dark"] .nav-item:hover {
            background: var(--background);
            color: var(--primary-color);
        }

        [data-theme="dark"] .nav-item.active {
            background: var(--primary-color);
            color: white;
        }

        [data-theme="dark"] .nav-item .badge {
            background: var(--border);
            color: var(--text-secondary);
        }

        [data-theme="dark"] .nav-item.active .badge {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        [data-theme="dark"] .connection-panel {
            border-top-color: var(--border);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .connect-btn-sidebar {
            background: var(--primary-color);
        }

        [data-theme="dark"] .connect-btn-sidebar:hover {
            background: var(--secondary-color);
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
            transform: translateY(-1px);
        }

        /* Search Toggle Animation */
        .search-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 90;
            padding: 30px 0;
        }

        .search-container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .search-container.hidden {
            opacity: 0;
            transform: translateY(-10px);
        }

        /* Category Filter Styles */
        .category-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 89;
            padding: 20px 0;
        }

        .category-container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .category-container.hidden {
            opacity: 0;
            transform: translateY(-10px);
        }

        .category-filter {
            max-width: 800px;
            margin: 0 auto;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .category-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.2em;
        }

        .category-close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .category-close-btn:hover {
            background: var(--border);
            color: var(--text-primary);
            transform: scale(1.1);
        }

        .category-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .category-chip {
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
        }

        .category-chip:hover {
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: white;
            transform: translateY(-2px);
        }

        .category-chip.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        .category-chip.show-all {
            background: var(--secondary-color);
            border-color: var(--secondary-color);
            color: white;
            font-weight: 600;
        }

        .category-chip.show-all:hover {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .category-count {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .category-chip:not(.active) .category-count {
            background: var(--border);
            color: var(--text-secondary);
        }

        /* AI indicator for categories */
        .category-chip.ai-enhanced {
            border-color: #9c27b0;
            background: linear-gradient(45deg, var(--background), #f3e5f5);
        }

        .category-chip.ai-enhanced:hover {
            background: linear-gradient(45deg, var(--primary-color), #9c27b0);
        }

        .category-chip.ai-enhanced::after {
            content: "🤖";
            font-size: 0.7em;
            margin-left: 4px;
        }

        /* Dark mode category styles */
        [data-theme="dark"] .category-container {
            background: var(--surface);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .category-header h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .category-close-btn:hover {
            background: #21262d;
            color: var(--text-primary);
        }

        [data-theme="dark"] .category-chip {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .category-chip:hover {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        [data-theme="dark"] .category-chip.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        [data-theme="dark"] .category-chip:not(.active) .category-count {
            background: var(--border);
            color: var(--text-secondary);
        }

        [data-theme="dark"] .category-chip.ai-enhanced {
            background: linear-gradient(45deg, var(--surface), #3a1c3f);
            border-color: #9c27b0;
        }

        .search-box {
            position: relative;
            max-width: 600px;
            margin: 0 auto;
        }

        .search-input {
            width: 100%;
            padding: 15px 50px 15px 20px;
            border: 2px solid var(--border);
            border-radius: 25px;
            font-size: 16px;
            background: var(--background);
            transition: border-color 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .search-close-btn {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .search-close-btn:hover {
            background: var(--border);
            color: var(--text-primary);
            transform: translateY(-50%) scale(1.1);
        }

        /* Status */
        .status {
            padding: 20px 0;
            text-align: center;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .status.loading {
            color: var(--secondary-color);
        }

        .status.error {
            color: #e74c3c;
        }

        .status.success {
            color: #27ae60;
        }

        /* FIXED: Local cache status indicator */
        .local-cache-status {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 15px;
            margin: 15px 0;
            font-size: 0.9em;
            text-align: center;
            transition: all 0.3s ease;
        }

        .local-cache-status.has-changes {
            background: #fff3cd;
            border-color: #ffeaa7;
            color: #856404;
        }

        .local-cache-status.synced {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        [data-theme="dark"] .local-cache-status.has-changes {
            background: #3a3019;
            border-color: #675a1a;
            color: #fff3cd;
        }

        [data-theme="dark"] .local-cache-status.synced {
            background: #1a2e1a;
            border-color: #2d5a2d;
            color: #d4edda;
        }

        /* Articles Grid - SMALLER TILES */
        .articles-section {
            padding: 40px 0;
            min-height: 60vh;
        }

        .articles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            /* REDUCED from 290px to 220px */
            gap: 18px;
            /* REDUCED from 24px to 18px */
            margin-top: 20px;
        }

        /* ORGANIC SHAPED TILES - SMALLER VERSION */
        .article-card {
            background: var(--surface);
            /* Organic rounded shape - different for each nth-child */
            border-radius: 32px 24px 32px 24px;
            overflow: visible;
            box-shadow: var(--shadow);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border: 1px solid var(--border);
            position: relative;
            display: flex;
            flex-direction: column;
            transform-origin: center center;
        }

        /* Varying organic shapes for visual interest */
        .article-card:nth-child(3n+1) {
            border-radius: 28px 36px 28px 36px;
        }

        .article-card:nth-child(3n+2) {
            border-radius: 35px 25px 35px 25px;
        }

        .article-card:nth-child(3n+3) {
            border-radius: 30px 30px 40px 20px;
        }

        .article-card:nth-child(4n+1) {
            border-radius: 40px 20px 30px 30px;
        }

        .article-card:nth-child(5n+1) {
            border-radius: 25px 35px 25px 35px;
        }

        .article-card:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-8px) scale(1.02) rotate(1deg);
            border-color: var(--primary-color);
        }

        .article-card:nth-child(even):hover {
            transform: translateY(-8px) scale(1.02) rotate(-1deg);
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
        }

        /* AI categorization indicator on cards */
        .article-card.ai-categorized {
            border-color: #9c27b0;
        }

        .article-card.ai-categorized::before {
            content: "🤖 AI";
            position: absolute;
            top: 5px;
            left: 10px;
            background: rgba(156, 39, 176, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7em;
            z-index: 10;
        }

        /* FIXED: Manual edit indicator */
        .article-card.manual-edit::before {
            content: "✏️ Manual";
            position: absolute;
            top: 5px;
            left: 10px;
            background: rgba(25, 135, 84, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7em;
            z-index: 10;
        }

        /* Organic shaped image area - SMALLER */
        .article-image {
            width: 100%;
            height: 100px;
            /* REDUCED from 140px to 100px */
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            /* REDUCED from 2em to 1.5em */
            color: white;
            position: relative;
            overflow: hidden;
            /* Inherit the card's organic border radius for top corners */
            border-radius: inherit;
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 16px;
        }

        .article-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.4s ease, opacity 0.3s ease;
        }

        .article-image:hover img {
            transform: scale(1.08);
        }

        /* Compact content area with organic feel - SMALLER */
        .article-content {
            padding: 15px;
            /* REDUCED from 20px to 15px */
            flex: 1;
            cursor: pointer;
            border-radius: 0 0 inherit inherit;
        }

        .article-title {
            font-size: 1em;
            /* REDUCED from 1.1em to 1em */
            font-weight: 600;
            margin-bottom: 6px;
            /* REDUCED from 8px to 6px */
            line-height: 1.3;
            color: var(--text-primary);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-excerpt {
            color: var(--text-secondary);
            font-size: 0.8em;
            /* REDUCED from 0.9em to 0.8em */
            line-height: 1.4;
            margin-bottom: 10px;
            /* REDUCED from 12px to 10px */
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
            /* REDUCED from 8px to 6px */
            color: var(--text-secondary);
            font-size: 0.75em;
            /* REDUCED from 0.8em to 0.75em */
            margin-bottom: 6px;
            /* REDUCED from 8px to 6px */
        }

        .article-domain {
            font-weight: 500;
        }

        .article-date {
            opacity: 0.8;
        }

        .article-stats {
            display: flex;
            gap: 10px;
            /* REDUCED from 12px to 10px */
            font-size: 0.7em;
            /* REDUCED from 0.75em to 0.7em */
            color: var(--text-secondary);
        }

        /* Enhanced category badge on articles */
        .article-category {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: var(--primary-color);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.65em;
            font-weight: 500;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .article-category:hover {
            background: var(--secondary-color);
            transform: scale(1.05);
        }

        .article-category.ai-category {
            background: linear-gradient(45deg, var(--primary-color), #9c27b0);
        }

        /* FIXED: Better manual edit indication */
        .article-category.manual-edit {
            background: linear-gradient(45deg, #198754, #20c997);
            border: 1px solid #28a745;
        }

        /* NEW: Category editing dropdown */
        .category-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--surface);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            box-shadow: var(--shadow-hover);
            z-index: 200;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            min-width: 150px;
        }

        .category-dropdown.visible {
            display: block;
        }

        .category-option {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9em;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--text-primary);
        }

        .category-option:hover {
            background: var(--background);
        }

        .category-option.selected {
            background: var(--primary-color);
            color: white;
        }

        .category-option:last-child {
            border-bottom: none;
        }

        /* Dark mode dropdown styles */
        [data-theme="dark"] .category-dropdown {
            background: var(--surface);
            border-color: var(--primary-color);
        }

        [data-theme="dark"] .category-option {
            color: var(--text-primary);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .category-option:hover {
            background: var(--background);
        }

        [data-theme="dark"] .category-option.selected {
            background: var(--primary-color);
            color: white;
        }

        /* Floating organic action buttons - SMALLER */
        .article-actions {
            position: absolute;
            top: 10px;
            /* REDUCED from 15px to 10px */
            right: 10px;
            /* REDUCED from 15px to 10px */
            display: flex;
            gap: 6px;
            /* REDUCED from 8px to 6px */
            opacity: 0 !important;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid var(--border);
            border-radius: 50%;
            /* Circular buttons for organic feel */
            padding: 8px;
            /* REDUCED from 12px to 8px */
            cursor: pointer;
            font-size: 14px;
            /* REDUCED from 16px to 14px */
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            min-width: 36px;
            /* REDUCED from 44px to 36px */
            height: 36px;
            /* REDUCED from 44px to 36px */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn:hover {
            transform: translateY(-4px) scale(1.15);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
            border-radius: 40% 60% 70% 30%;
        }

        .read-btn:hover {
            background: #e3f2fd;
            border-color: #2196f3;
            border-radius: 60% 40% 30% 70%;
        }

        .export-btn:hover {
            background: #e8f5e8;
            border-color: #4caf50;
            border-radius: 30% 70% 60% 40%;
        }

        .refresh-image-btn:hover {
            background: #fff3e0;
            border-color: #ff9800;
            border-radius: 40% 60% 40% 60%;
        }

        .delete-btn {
            color: #f44336;
        }

        .delete-btn:hover {
            background: #ffebee;
            border-color: #f44336;
            color: #d32f2f;
            border-radius: 70% 30% 40% 60%;
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
        }

        body.test-mode .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
            background: rgba(255, 255, 0, 0.1);
            border: 2px dashed #ff9800;
            border-radius: 20px;
            padding: 5px;
        }

        .article-actions:hover {
            opacity: 1 !important;
            visibility: visible !important;
        }

        /* Reader View */
        .reader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            overflow-y: auto;
        }

        .reader-overlay.active {
            display: block;
        }

        .reader-container {
            max-width: 800px;
            margin: 40px auto;
            background: var(--surface);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.3);
        }

        .reader-header {
            padding: 30px;
            border-bottom: 1px solid var(--border);
            background: var(--background);
        }

        .reader-title {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 15px;
            line-height: 1.3;
        }

        .reader-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .reader-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .reader-content {
            padding: 40px;
            font-size: 1.1em;
            line-height: 1.8;
            max-width: none;
        }

        .reader-content h1,
        .reader-content h2,
        .reader-content h3 {
            margin: 30px 0 15px;
            color: var(--text-primary);
        }

        .reader-content p {
            margin-bottom: 20px;
        }

        .reader-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
        }

        .reader-content blockquote {
            border-left: 4px solid var(--primary-color);
            margin: 20px 0;
            padding: 15px 20px;
            background: var(--background);
            font-style: italic;
        }

        .close-reader {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-reader:hover {
            border-radius: 30% 70% 70% 30%;
            transform: scale(1.1);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Cache indicator */
        .cache-indicator {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            z-index: 5;
        }

        .cache-indicator.cached {
            background: rgba(39, 174, 96, 0.8);
        }

        .cache-indicator.fresh {
            background: rgba(52, 152, 219, 0.8);
        }

        /* NEW: Enhanced cache indicator styles */
        .cache-indicator.synced {
            background: rgba(76, 175, 80, 0.8);
            color: white;
        }

        .cache-indicator.fallback {
            background: rgba(255, 152, 0, 0.8);
            color: white;
        }

        .cache-indicator.metadata {
            background: rgba(103, 58, 183, 0.8);
            color: white;
        }

        .cache-indicator.error {
            background: rgba(244, 67, 54, 0.8);
            color: white;
        }

        .cache-indicator.ai-categorized {
            background: rgba(156, 39, 176, 0.9);
            color: white;
        }

        .cache-indicator.smart-categorized {
            background: rgba(103, 58, 183, 0.9);
            color: white;
        }

        /* NEW: Progress indicator for recategorization */
        .progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1001;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .progress-overlay.visible {
            display: flex;
        }

        .progress-container {
            background: var(--surface);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            box-shadow: var(--shadow-hover);
            text-align: center;
        }

        .progress-title {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: var(--background);
            border-radius: 6px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 6px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-top: 10px;
        }

        .progress-stats {
            font-size: 0.8em;
            color: var(--text-secondary);
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border);
        }

        /* Dark mode progress styles */
        [data-theme="dark"] .progress-container {
            background: var(--surface);
        }

        [data-theme="dark"] .progress-title {
            color: var(--text-primary);
        }

        [data-theme="dark"] .progress-text,
        [data-theme="dark"] .progress-stats {
            color: var(--text-secondary);
        }

        [data-theme="dark"] .progress-stats {
            border-top-color: var(--border);
        }

        /* Enhanced Mobile Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 0 12px;
            }

            /* Mobile Sidebar */
            .sidebar {
                transform: translateX(-100%);
                width: 100%;
                max-width: 280px;
                z-index: 105;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .sidebar.collapsed {
                transform: translateX(-100%);
            }

            .sidebar-toggle {
                display: none;
            }

            /* Mobile Header */
            .header {
                padding: 15px 0;
                position: fixed;
                width: 100%;
                top: 0;
                z-index: 104;
            }

            .header-content {
                padding-left: 20px;
                padding-right: 20px;
            }

            .mobile-menu-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 6px;
                color: white;
                padding: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .mobile-menu-btn:hover {
                background: rgba(255, 255, 255, 0.3);
            }

            /* Main Content Mobile */
            .main-content {
                margin-left: 0;
                padding-top: 80px;
                /* Account for fixed header */
            }

            .main-content.sidebar-collapsed {
                margin-left: 0;
            }

            /* Mobile Overlay */
            .sidebar-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 103;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s ease;
            }

            .sidebar-overlay.active {
                opacity: 1;
                visibility: visible;
            }

            /* Header improvements for mobile */
            .logo {
                font-size: 1.4em;
            }

            .header-right {
                gap: 10px;
            }

            .mobile-menu-btn {
                display: none;
                align-items: center;
                justify-content: center;
                background: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 6px;
                color: white;
                padding: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-size: 18px;
                width: 36px;
                height: 36px;
            }

            .mobile-menu-btn:hover {
                background: rgba(255, 255, 255, 0.3);
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
                border-radius: 20px;
            }

            /* Search improvements */
            .search-container {
                padding: 20px 0;
                top: 80px;
                /* Account for fixed header */
            }

            .search-input {
                font-size: 16px !important;
                /* Prevent zoom */
                padding: 12px 45px 12px 16px;
                border-radius: 20px;
            }

            .search-close-btn {
                right: 12px;
                width: 28px;
                height: 28px;
                font-size: 16px;
            }

            /* Category Filter Mobile */
            .category-container {
                padding: 15px 0;
                top: 80px;
                /* Account for fixed header */
            }

            .category-header h3 {
                font-size: 1.1em;
            }

            .category-chips {
                gap: 8px;
            }

            .category-chip {
                padding: 6px 12px;
                font-size: 0.8em;
                border-radius: 16px;
            }

            .category-count {
                font-size: 0.7em;
                padding: 1px 4px;
            }

            /* Status bar */
            .status {
                padding: 15px 0;
                font-size: 14px;
                line-height: 1.4;
            }

            /* MAJOR MOBILE GRID FIX */
            .articles-section {
                padding: 20px 0;
            }

            .articles-grid {
                display: block;
                /* Use block layout instead of grid for better mobile performance */
                margin-top: 15px;
            }

            /* COMPLETELY REDESIGNED MOBILE CARDS */
            .article-card {
                display: block !important;
                width: 100% !important;
                margin-bottom: 20px !important;
                border-radius: 20px !important;
                overflow: hidden;
                background: var(--surface);
                border: 1px solid var(--border);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                transform: none !important;
                animation: none !important;
            }

            .article-card:hover {
                transform: none !important;
                box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
            }

            /* LARGER MOBILE IMAGE */
            .article-image {
                width: 100% !important;
                height: 140px !important;
                /* Increased from 100px */
                border-radius: 20px 20px 0 0 !important;
                position: relative;
            }

            /* MUCH LARGER TEXT ON MOBILE */
            .article-content {
                padding: 20px !important;
                cursor: pointer;
            }

            .article-title {
                font-size: 1.25em !important;
                /* Much larger - was 1em */
                font-weight: 600;
                margin-bottom: 10px !important;
                line-height: 1.4 !important;
                color: var(--text-primary);
                display: block !important;
                /* Remove text clamping on mobile */
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-excerpt {
                font-size: 1em !important;
                /* Much larger - was 0.8em */
                line-height: 1.5 !important;
                margin-bottom: 15px !important;
                color: var(--text-secondary);
                display: block !important;
                /* Remove text clamping on mobile */
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-meta {
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-wrap: wrap;
                gap: 8px;
                color: var(--text-secondary);
                font-size: 0.9em !important;
                /* Larger - was 0.75em */
                margin-bottom: 10px;
            }

            .article-stats {
                display: flex;
                gap: 15px;
                font-size: 0.85em !important;
                /* Larger - was 0.7em */
                color: var(--text-secondary);
                margin-bottom: 10px;
            }

            /* Mobile category badge */
            .article-category {
                font-size: 0.8em !important;
                padding: 4px 10px;
                margin-bottom: 10px;
            }

            /* MOBILE-OPTIMIZED ACTION BUTTONS */
            .article-actions {
                position: static !important;
                opacity: 1 !important;
                visibility: visible !important;
                display: flex !important;
                justify-content: center;
                gap: 12px;
                padding: 15px 20px;
                background: var(--background);
                border-radius: 0;
                margin: 0;
                border-top: 1px solid var(--border);
            }

            .action-btn {
                min-width: 45px !important;
                height: 45px !important;
                font-size: 18px !important;
                border-radius: 50% !important;
                padding: 0;
                background: var(--surface);
                border: 2px solid var(--border);
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .action-btn:hover,
            .action-btn:active {
                border-radius: 50% !important;
                transform: scale(1.05);
                background: var(--primary-color);
                color: white;
                border-color: var(--primary-color);
            }

            /* MOBILE READER IMPROVEMENTS */
            .reader-overlay {
                padding: 0;
                z-index: 106;
            }

            .reader-container {
                margin: 0 !important;
                border-radius: 0 !important;
                height: 100vh;
                max-width: none;
                display: flex;
                flex-direction: column;
            }

            .reader-header {
                padding: 20px;
                border-radius: 0;
                flex-shrink: 0;
            }

            .reader-title {
                font-size: 1.4em !important;
                line-height: 1.3;
                margin-bottom: 15px;
            }

            .reader-meta {
                font-size: 0.9em;
                gap: 15px;
            }

            .reader-content {
                padding: 20px;
                font-size: 1.1em !important;
                /* Larger reading text */
                line-height: 1.7 !important;
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                /* Smooth scrolling on iOS */
            }

            .close-reader {
                top: 15px;
                right: 15px;
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            /* MOBILE SEARCH */
            .search-input {
                font-size: 16px !important;
                /* Prevent zoom */
                padding: 14px 50px 14px 18px;
            }

            /* EMPTY STATE */
            .empty-state {
                padding: 40px 20px;
            }

            .empty-state-icon {
                font-size: 3em;
                margin-bottom: 15px;
            }

            .empty-state h3 {
                font-size: 1.3em;
                margin-bottom: 8px;
            }

            .empty-state p {
                font-size: 1em;
                line-height: 1.5;
            }

            /* Mobile progress overlay */
            .progress-container {
                max-width: 350px;
                padding: 25px;
            }

            .progress-title {
                font-size: 1.1em;
            }

            .category-dropdown {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 280px;
                max-height: 300px;
                border-radius: 12px;
            }
        }

        /* Extra small screens (very small phones) */
        @media (max-width: 480px) {
            .article-title {
                font-size: 1.15em !important;
            }

            .article-excerpt {
                font-size: 0.95em !important;
            }

            .article-content {
                padding: 16px !important;
            }

            .header-actions {
                gap: 6px;
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        /* Firefox Mobile Specific Fixes */
        @-moz-document url-prefix() {
            @media (max-width: 768px) {
                .article-card {
                    will-change: auto;
                    /* Improve performance on Firefox mobile */
                }

                .articles-grid {
                    transform: translateZ(0);
                    /* Force hardware acceleration */
                }

                .search-input {
                    -moz-appearance: none;
                    /* Remove Firefox mobile styling */
                }

                .btn {
                    -moz-appearance: none;
                }
            }
        }

        /* Connection Status */
        .connection-status {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 15px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .connection-status.connected {
            border-color: #27ae60;
            background: #d4edda;
        }

        .connection-status.disconnected {
            border-color: #e74c3c;
            background: #f8d7da;
        }

        /* Additional organic elements */
        @keyframes float {

            0%,
            100% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-6px);
            }
        }

        /* Background pattern animation for generated placeholders */
        @keyframes floatPattern {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        /* Shimmer animation for loading placeholders */
        @keyframes shimmer {
            0% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.6;
            }
        }

        .article-card:nth-child(7n+1) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 0s;
        }

        .article-card:nth-child(7n+2) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 0.5s;
        }

        .article-card:nth-child(7n+3) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 1s;
        }

        /* Organic gradient backgrounds for images */
        .article-image:nth-child(odd) {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .article-image:nth-child(3n+1) {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .article-image:nth-child(3n+2) {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .article-image:nth-child(3n+3) {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }

        .article-image:nth-child(5n+1) {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }
    </style>
</head>

<body>
    <!-- Left Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-brand">
                <span>🤖</span>
                <span>MyPocket AI</span>
            </div>
        </div>

        <!-- Connection Status -->
        <div class="connection-panel">
            <div class="connection-status-sidebar" id="connectionStatusSidebar">
                <span id="connectionIcon">🔐</span>
                <span id="connectionText">Not Connected</span>
            </div>
            <button id="connectBtnSidebar" class="connect-btn-sidebar">
                Secure Connect
            </button>
        </div>

        <!-- Navigation -->
        <nav class="sidebar-nav">
            <!-- Main Actions -->
            <div class="nav-section">
                <div class="nav-section-title">Library</div>
                <button class="nav-item" id="allArticlesNav" onclick="webReader.showAllArticles()">
                    <span class="icon">📖</span>
                    <span class="text">All Articles</span>
                    <span class="badge" id="allArticlesBadge">0</span>
                </button>
                <button class="nav-item" id="searchNavBtn" onclick="webReader.toggleSearch()">
                    <span class="icon">🔍</span>
                    <span class="text">Search</span>
                </button>
                <button class="nav-item" id="categoriesNavBtn" onclick="webReader.toggleCategoryFilter()">
                    <span class="icon">🤖</span>
                    <span class="text">AI Categories</span>
                    <span class="badge" id="categoryBadge">0</span>
                </button>
            </div>

            <!-- FIXED: Data Management Tools -->
            <div class="nav-section">
                <div class="nav-section-title">Data</div>
                <button class="nav-item" id="refreshNavBtn" onclick="webReader.loadFromOneDrive()">
                    <span class="icon">☁️</span>
                    <span class="text">Load from OneDrive</span>
                </button>
                <button class="nav-item" id="saveNavBtn" onclick="webReader.saveToOneDrive()">
                    <span class="icon">💾</span>
                    <span class="text">Save to OneDrive</span>
                </button>
                <button class="nav-item" id="autoSaveNavBtn" onclick="webReader.toggleAutoSave()">
                    <span class="icon">🔄</span>
                    <span class="text">Auto-Save: <span id="autoSaveStatus">OFF</span></span>
                </button>
            </div>

            <!-- Tools -->
            <div class="nav-section">
                <div class="nav-section-title">Tools</div>
                <button class="nav-item" id="syncNavBtn" onclick="webReader.forceSyncImages()">
                    <span class="icon">🌐</span>
                    <span class="text">Sync Images</span>
                </button>
                <button class="nav-item" id="retryNavBtn" onclick="webReader.retryFailedImages()">
                    <span class="icon">🔁</span>
                    <span class="text">Retry Failed</span>
                </button>
                <button class="nav-item" onclick="webReader.clearImageCache()">
                    <span class="icon">🗑️</span>
                    <span class="text">Clear Cache</span>
                </button>
                <button class="nav-item" id="recategorizeBtn" onclick="webReader.recategorizeAllWithAI()">
                    <span class="icon">🧠</span>
                    <span class="text">AI Re-categorize</span>
                </button>
            </div>

            <!-- Settings -->
            <div class="nav-section">
                <div class="nav-section-title">Settings</div>
                <button class="nav-item" onclick="webReader.toggleDarkMode()">
                    <span class="icon" id="darkModeIcon">🌙</span>
                    <span class="text" id="darkModeText">Dark Mode</span>
                </button>
                <button class="nav-item" onclick="webReader.toggleTestMode()">
                    <span class="icon">👁️</span>
                    <span class="text">Show Buttons</span>
                </button>
                <button class="nav-item" onclick="webReader.showImageHelp()">
                    <span class="icon">❓</span>
                    <span class="text">Image Help</span>
                </button>
                <button class="nav-item" onclick="webReader.showAIHelp()">
                    <span class="icon">🤖</span>
                    <span class="text">AI Categories Help</span>
                </button>
                <button class="nav-item" onclick="webReader.showDebugInfo()">
                    <span class="icon">🔧</span>
                    <span class="text">Debug Info</span>
                </button>
            </div>
        </nav>

        <!-- Sidebar Toggle -->
        <button class="sidebar-toggle" id="sidebarToggle" onclick="webReader.toggleSidebar()">
            <span id="sidebarToggleIcon">◀</span>
        </button>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="webReader.closeMobileSidebar()"></div>

    <!-- Main Content Area -->
    <div class="main-content" id="mainContent">
        <!-- Header -->
        <header class="header">
            <div class="container">
                <div class="header-content">
                    <!-- Mobile Menu Button -->
                    <button class="mobile-menu-btn" id="mobileMenuBtn" onclick="webReader.openMobileSidebar()"
                        style="display: none;">
                        <span>☰</span>
                    </button>

                    <div class="logo">
                        MyPocket AI Reader (FIXED: Manual Categories + Local Cache)
                    </div>

                    <div class="header-right">
                        <span id="headerStatus" class="header-status">💾 Local cache enabled!</span>
                    </div>
                </div>
            </div>
        </header>

        <!-- FIXED: Local Cache Status -->
        <div class="local-cache-status" id="localCacheStatus" style="display: none;">
            <span id="cacheStatusText">📦 Using local cache - manual changes saved!</span>
        </div>

        <!-- Search (Initially Hidden) -->
        <section class="search-container" id="searchContainer" style="display: none;">
            <div class="container">
                <div class="search-box">
                    <input type="text" id="searchInput" class="search-input"
                        placeholder="Search your saved articles... (🤖 AI-powered)" autocomplete="off">
                    <button class="search-close-btn" onclick="webReader.toggleSearch()" title="Close search">✕</button>
                </div>
            </div>
        </section>

        <!-- Category Filter (Initially Hidden) -->
        <section class="category-container" id="categoryContainer" style="display: none;">
            <div class="container">
                <div class="category-filter">
                    <div class="category-header">
                        <h3>🤖 AI-Enhanced Categories</h3>
                        <button class="category-close-btn" onclick="webReader.toggleCategoryFilter()"
                            title="Close categories">✕</button>
                    </div>
                    <div class="category-chips" id="categoryChips">
                        <!-- Categories will be populated here -->
                    </div>
                </div>
            </div>
        </section>

        <!-- Status -->
        <div class="status" id="status">
            💾 Ready to use with local caching! Connect to OneDrive to sync your articles.
        </div>

        <!-- Articles -->
        <section class="articles-section">
            <div class="container">
                <div id="articlesContainer">
                    <div class="empty-state">
                        <div class="empty-state-icon">💾</div>
                        <h3>Welcome to MyPocket AI Reader (FIXED)</h3>
                        <p>Connect to OneDrive to access your saved articles with intelligent AI categorization and
                            local caching!</p>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <!-- Reader Overlay -->
    <div class="reader-overlay" id="readerOverlay">
        <div class="reader-container">
            <button class="close-reader" id="closeReader">✕</button>
            <div class="reader-header">
                <h1 class="reader-title" id="readerTitle">Article Title</h1>
                <div class="reader-meta" id="readerMeta">
                    <span>📅 <span id="readerDate">Date</span></span>
                    <span>🌐 <span id="readerDomain">Domain</span></span>
                    <span>⏱️ <span id="readerTime">5 min read</span></span>
                </div>
                <div class="reader-actions">
                    <button class="btn btn-secondary" id="openOriginal">
                        🔗 Open Original
                    </button>
                </div>
            </div>
            <div class="reader-content" id="readerContent">
                Article content will appear here...
            </div>
        </div>
    </div>

    <!-- Progress Overlay for Recategorization -->
    <div class="progress-overlay" id="progressOverlay">
        <div class="progress-container">
            <div class="progress-title">🧠 AI Re-categorization in Progress</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Initializing AI analysis...</div>
            <div class="progress-stats" id="progressStats">
                Processing articles with enhanced categorization...
            </div>
        </div>
    </div>

    <script>
        console.log('🚀 MyPocket AI-Enhanced Web Reader script starting...');

        // Debug function available immediately
        window.debugMyPocket = function () {
            console.log('🔧 DEBUG: Checking all elements...');
            const elements = {
                'sidebar': document.getElementById('sidebar'),
                'connectBtnSidebar': document.getElementById('connectBtnSidebar'),
                'connectionStatusSidebar': document.getElementById('connectionStatusSidebar'),
                'connectionIcon': document.getElementById('connectionIcon'),
                'connectionText': document.getElementById('connectionText'),
                'refreshNavBtn': document.getElementById('refreshNavBtn'),
                'syncNavBtn': document.getElementById('syncNavBtn'),
                'retryNavBtn': document.getElementById('retryNavBtn'),
                'allArticlesNav': document.getElementById('allArticlesNav'),
                'searchNavBtn': document.getElementById('searchNavBtn'),
                'categoriesNavBtn': document.getElementById('categoriesNavBtn'),
                'recategorizeBtn': document.getElementById('recategorizeBtn'),
                'status': document.getElementById('status'),
                'mainContent': document.getElementById('mainContent')
            };

            console.log('🔍 Element check results:');
            for (const [name, element] of Object.entries(elements)) {
                if (element) {
                    console.log(`✅ ${name}: Found`);
                } else {
                    console.log(`❌ ${name}: NOT FOUND`);
                }
            }

            // Check if webReader exists
            if (window.webReader) {
                console.log('✅ webReader: Initialized');
                console.log('📊 webReader properties:', {
                    accessToken: !!window.webReader.accessToken,
                    articles: window.webReader.articles ? window.webReader.articles.length : 0,
                    redirectUri: window.webReader.redirectUri,
                    aiCategoriesEnabled: window.webReader.aiCategoriesEnabled,
                    isRecategorizing: window.webReader.isRecategorizing
                });
            } else {
                console.log('❌ webReader: NOT INITIALIZED');
            }

            return elements;
        };

        class MyPocketWebReader {
            constructor() {
                console.log('🏗️ Creating FIXED AI-Enhanced MyPocketWebReader instance...');

                this.clientId = '436e8796-8c40-47c3-9ad5-b8882f3ef7f7';
                this.redirectUri = this.getRedirectUri();
                console.log('🔵 Redirect URI:', this.redirectUri);

                this.accessToken = null;
                this.articles = [];
                this.currentArticle = null;
                this.currentDisplayedArticles = []; // Track what's currently displayed
                this.failedImages = new Set(); // Track articles with failed images

                // FIXED: Auto-save and local cache system
                this.autoSaveEnabled = false;
                this.localCacheKey = 'mypocket_local_articles_cache';
                this.hasUnsavedChanges = false;
                this.lastOneDriveSyncHash = null;
                this.manuallyEditedArticles = new Set(); // Track manually edited articles

                // Auto-categorization system with AI enhancements
                this.categories = new Map(); // Store category counts
                this.activeCategory = null; // Currently selected category filter
                this.categoryKeywords = this.initializeAIEnhancedCategoryKeywords();
                this.aiCategoriesEnabled = true; // Enable AI categorization features
                this.categorySynonyms = this.initializeCategorySynonyms(); // For smarter matching
                this.categoryAnalytics = new Map(); // Track categorization confidence

                // NEW: Context phrases for better categorization
                this.contextPhrases = this.initializeContextPhrases();
                this.negativeKeywords = this.initializeNegativeKeywords();

                // Image cache system
                this.imageCache = new Map();
                this.cacheKey = 'mypocket_image_cache';
                this.cacheExpiryDays = 7; // Cache images for 7 days

                // Cross-device image storage
                this.storeImagesInBackup = true; // Enable cross-device image storage
                this.maxImageSizeKB = 500; // Limit to prevent huge backups
                this.cacheSaveTimeout = null; // For debounced saves

                // PKCE-specific properties
                this.codeVerifier = null;
                this.codeChallenge = null;
                this.state = null;

                // NEW: Progress tracking for recategorization
                this.isRecategorizing = false;
                this.recategorizationProgress = 0;

                console.log('✅ FIXED AI-Enhanced MyPocketWebReader constructor complete');
                this.init();
            }

            getRedirectUri() {
                const currentUrl = window.location.href;
                const baseUrl = currentUrl.split('#')[0].split('?')[0]; // Remove both fragment and query

                if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {
                    return baseUrl;
                } else {
                    return window.location.origin + window.location.pathname;
                }
            }

            init() {
                console.log('🚀 Initializing FIXED AI-Enhanced MyPocket Web Reader...');
                this.setupEventListeners();
                this.checkAuthFromURL();
                this.loadStoredToken();
                this.loadThemePreference();
                this.loadImageCache();
                this.initializeSidebar();
                this.loadLocalCache(); // FIXED: Load local cache first
                this.updateAutoSaveStatus();
                console.log('✅ FIXED AI-Enhanced initialization complete');
            }

            // ===== FIXED LOCAL CACHE SYSTEM =====

            // FIXED: Load articles from local cache first
            loadLocalCache() {
                console.log('💾 Loading articles from local cache...');
                try {
                    const cachedData = localStorage.getItem(this.localCacheKey);
                    if (cachedData) {
                        const cache = JSON.parse(cachedData);
                        this.articles = cache.articles || [];
                        this.lastOneDriveSyncHash = cache.syncHash || null;
                        this.manuallyEditedArticles = new Set(cache.manuallyEdited || []);

                        console.log(`💾 Loaded ${this.articles.length} articles from local cache`);
                        console.log(`✏️ ${this.manuallyEditedArticles.size} manually edited articles tracked`);

                        if (this.articles.length > 0) {
                            this.updateLocalCacheStatus('synced', `💾 ${this.articles.length} articles loaded from local cache`);
                            this.recategorizeAllArticles(); // Categorize cached articles
                            this.displayArticles(this.articles);
                            this.updateArticleCounts();
                            this.updateStatus(`💾 Loaded ${this.articles.length} articles from local cache`, 'success');
                        }
                    } else {
                        console.log('💾 No local cache found');
                    }
                } catch (error) {
                    console.error('💾 Error loading local cache:', error);
                    this.updateStatus('⚠️ Error loading local cache', 'error');
                }
            }

            // FIXED: Save articles to local cache with better error handling
            saveLocalCache() {
                try {
                    console.log('💾 Starting local cache save...');

                    // Clean articles data to remove non-serializable content
                    const cleanedArticles = this.cleanArticlesForStorage(this.articles);

                    const cacheData = {
                        articles: cleanedArticles,
                        syncHash: this.calculateArticlesHash(),
                        manuallyEdited: Array.from(this.manuallyEditedArticles),
                        timestamp: Date.now(),
                        version: '7.2-fixed'
                    };

                    // Check size before saving
                    const dataString = JSON.stringify(cacheData);
                    const sizeKB = Math.round(dataString.length / 1024);
                    const sizeMB = Math.round(sizeKB / 1024 * 100) / 100;

                    console.log(`💾 Cache data size: ${sizeKB}KB (${sizeMB}MB)`);

                    // localStorage typically has 5-10MB limit
                    if (sizeKB > 8000) { // 8MB safety limit
                        console.warn(`⚠️ Cache data too large: ${sizeMB}MB`);
                        // Try saving without base64 images
                        const lightCacheData = this.createLightweightCache(cleanedArticles);
                        const lightDataString = JSON.stringify(lightCacheData);
                        const lightSizeKB = Math.round(lightDataString.length / 1024);

                        console.log(`💾 Trying lightweight cache: ${lightSizeKB}KB`);
                        localStorage.setItem(this.localCacheKey, lightDataString);

                        this.updateLocalCacheStatus('synced', `💾 Lightweight cache saved (${lightSizeKB}KB) - images excluded`);
                        this.updateStatus(`💾 Local cache saved (${lightSizeKB}KB) - large images excluded for space`, 'success');
                    } else {
                        localStorage.setItem(this.localCacheKey, dataString);
                        console.log(`✅ Saved ${cleanedArticles.length} articles to local cache (${sizeKB}KB)`);
                        console.log(`✏️ Tracking ${this.manuallyEditedArticles.size} manually edited articles`);

                        this.hasUnsavedChanges = false;
                        this.updateLocalCacheStatus('synced', `💾 Local cache updated with ${cleanedArticles.length} articles (${sizeKB}KB)`);
                        this.updateStatus(`💾 Local cache saved successfully (${sizeKB}KB)`, 'success');
                    }

                } catch (error) {
                    console.error('💾 Error saving local cache:', error);

                    // More specific error handling
                    if (error.name === 'QuotaExceededError' || error.message.includes('quota')) {
                        this.handleStorageQuotaError();
                    } else if (error.message.includes('JSON')) {
                        this.handleSerializationError(error);
                    } else {
                        console.error('💾 Unexpected cache error:', error);
                        this.updateStatus(`⚠️ Local cache error: ${error.message}`, 'error');
                    }
                }
            }

            // FIXED: Clean articles data for safe storage
            cleanArticlesForStorage(articles) {
                return articles.map(article => {
                    const cleaned = {};

                    // Copy safe properties
                    for (const [key, value] of Object.entries(article)) {
                        if (value === null || value === undefined) {
                            continue; // Skip null/undefined
                        }

                        if (typeof value === 'function') {
                            continue; // Skip functions
                        }

                        if (typeof value === 'object') {
                            // Handle objects carefully
                            if (Array.isArray(value)) {
                                cleaned[key] = value; // Arrays are usually safe
                            } else if (key === 'cachedImage') {
                                // Handle cached images specially
                                cleaned[key] = {
                                    base64: value.base64,
                                    url: value.url,
                                    timestamp: value.timestamp,
                                    size: value.size,
                                    source: value.source
                                };
                            } else {
                                // Try to serialize other objects
                                try {
                                    JSON.stringify(value);
                                    cleaned[key] = value;
                                } catch (e) {
                                    console.warn(`Skipping non-serializable property: ${key}`);
                                }
                            }
                        } else {
                            cleaned[key] = value; // Primitive values are safe
                        }
                    }

                    return cleaned;
                });
            }

            // FIXED: Create lightweight cache without large images
            createLightweightCache(articles) {
                const lightArticles = articles.map(article => {
                    const light = { ...article };

                    // Remove large base64 images but keep URLs
                    if (light.cachedImage && light.cachedImage.base64) {
                        light.cachedImage = {
                            url: light.cachedImage.url,
                            timestamp: light.cachedImage.timestamp,
                            size: light.cachedImage.size,
                            source: light.cachedImage.source
                            // base64 removed to save space
                        };
                    }

                    // Remove very large content fields
                    if (light.content && light.content.length > 50000) {
                        light.content = light.content.substring(0, 50000) + '... [truncated for cache]';
                    }

                    return light;
                });

                return {
                    articles: lightArticles,
                    syncHash: this.calculateArticlesHash(),
                    manuallyEdited: Array.from(this.manuallyEditedArticles),
                    timestamp: Date.now(),
                    version: '7.2-fixed-light',
                    note: 'Lightweight cache - some images and content truncated'
                };
            }

            // FIXED: Handle storage quota exceeded error
            handleStorageQuotaError() {
                console.error('💾 Storage quota exceeded!');

                // Try to clear some space
                this.clearOldCacheData();

                // Try saving lightweight version
                try {
                    const lightCache = this.createLightweightCache(this.articles);
                    localStorage.setItem(this.localCacheKey, JSON.stringify(lightCache));

                    this.updateLocalCacheStatus('synced', '💾 Lightweight cache saved (storage full)');
                    this.updateStatus('💾 Storage full - saved lightweight cache without large images', 'warning');
                } catch (e) {
                    this.updateStatus('❌ Storage full - cannot save cache. Try clearing browser data.', 'error');

                    // Show help dialog
                    alert(`Storage Error:\n\nYour browser's localStorage is full. To fix this:\n\n1. Clear browser data/cache\n2. Enable auto-save to OneDrive instead\n3. Use "Clear Cache" button to remove old data\n\nYour articles are still loaded in memory and can be saved to OneDrive.`);
                }
            }

            // FIXED: Handle JSON serialization errors
            handleSerializationError(error) {
                console.error('💾 JSON serialization error:', error);

                // Try to identify problematic data
                try {
                    // Test serialization of main components
                    JSON.stringify(this.articles.slice(0, 1)); // Test first article
                    JSON.stringify(Array.from(this.manuallyEditedArticles)); // Test manually edited set

                    this.updateStatus('❌ Data serialization error - some article data may be corrupted', 'error');
                } catch (e) {
                    console.error('💾 Specific serialization issue:', e);
                    this.updateStatus('❌ Cannot serialize article data - please reload from OneDrive', 'error');
                }
            }

            // FIXED: Clear old cache data to free space
            clearOldCacheData() {
                try {
                    // Clear image cache
                    localStorage.removeItem(this.cacheKey);

                    // Clear other potential MyPocket data
                    for (let i = localStorage.length - 1; i >= 0; i--) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('mypocket_') && key !== this.localCacheKey) {
                            localStorage.removeItem(key);
                            console.log(`Cleared old cache: ${key}`);
                        }
                    }

                    console.log('💾 Cleared old cache data to free space');
                } catch (error) {
                    console.error('Error clearing old cache:', error);
                }
            }

            // FIXED: Calculate hash of articles for change detection
            calculateArticlesHash() {
                const articlesString = JSON.stringify(this.articles.map(a => ({
                    url: a.url,
                    title: a.title,
                    category: a.category,
                    dateAdded: a.dateAdded
                })));
                return this.simpleHash(articlesString);
            }

            // Simple hash function
            simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return hash;
            }

            // FIXED: Update local cache status indicator
            updateLocalCacheStatus(status, message) {
                const statusElement = document.getElementById('localCacheStatus');
                const textElement = document.getElementById('cacheStatusText');

                if (statusElement && textElement) {
                    statusElement.style.display = 'block';
                    textElement.textContent = message;

                    statusElement.className = 'local-cache-status';
                    if (status === 'has-changes') {
                        statusElement.classList.add('has-changes');
                    } else if (status === 'synced') {
                        statusElement.classList.add('synced');
                    }
                }
            }

            // FIXED: Toggle auto-save
            toggleAutoSave() {
                this.autoSaveEnabled = !this.autoSaveEnabled;
                localStorage.setItem('mypocket_auto_save', this.autoSaveEnabled.toString());
                this.updateAutoSaveStatus();

                if (this.autoSaveEnabled && this.hasUnsavedChanges && this.accessToken) {
                    // Save immediately if we have unsaved changes
                    this.saveToOneDrive();
                }

                this.updateStatus(`🔄 Auto-save ${this.autoSaveEnabled ? 'enabled' : 'disabled'}`, 'success');
            }

            // FIXED: Update auto-save status in UI
            updateAutoSaveStatus() {
                const autoSaveStatus = document.getElementById('autoSaveStatus');
                const autoSaveNavBtn = document.getElementById('autoSaveNavBtn');

                const enabled = localStorage.getItem('mypocket_auto_save') === 'true';
                this.autoSaveEnabled = enabled;

                if (autoSaveStatus) {
                    autoSaveStatus.textContent = enabled ? 'ON' : 'OFF';
                }

                if (autoSaveNavBtn) {
                    if (enabled) {
                        autoSaveNavBtn.style.color = '#27ae60';
                    } else {
                        autoSaveNavBtn.style.color = '';
                    }
                }
            }

            // FIXED: Load from OneDrive (manual action)
            async loadFromOneDrive() {
                if (!this.accessToken) {
                    this.updateStatus('❌ Not connected to OneDrive. Please connect first.', 'error');
                    return;
                }

                try {
                    this.updateStatus('☁️ Loading from OneDrive...', 'loading');
                    await this.loadArticles();
                    this.saveLocalCache(); // Update local cache with OneDrive data
                    this.updateStatus('☁️ Successfully loaded from OneDrive and cached locally', 'success');
                } catch (error) {
                    console.error('Error loading from OneDrive:', error);
                    this.updateStatus(`❌ Failed to load from OneDrive: ${error.message}`, 'error');
                }
            }

            // FIXED: Save to OneDrive (manual action)
            async saveToOneDrive() {
                if (!this.accessToken) {
                    this.updateStatus('❌ Not connected to OneDrive. Please connect first.', 'error');
                    return;
                }

                if (this.articles.length === 0) {
                    this.updateStatus('❌ No articles to save', 'error');
                    return;
                }

                try {
                    this.updateStatus('☁️ Saving to OneDrive...', 'loading');
                    await this.updateOneDriveBackup();
                    this.hasUnsavedChanges = false;
                    this.lastOneDriveSyncHash = this.calculateArticlesHash();
                    this.saveLocalCache(); // Update local cache with sync status
                    this.updateLocalCacheStatus('synced', `☁️ Synced ${this.articles.length} articles to OneDrive`);
                    this.updateStatus('☁️ Successfully saved to OneDrive', 'success');
                } catch (error) {
                    console.error('Error saving to OneDrive:', error);
                    this.updateStatus(`❌ Failed to save to OneDrive: ${error.message}`, 'error');
                }
            }

            // FIXED: Mark article as manually edited and save changes
            markAsManuallyEdited(article) {
                const articleId = `${article.url}_${article.title}`;
                this.manuallyEditedArticles.add(articleId);
                this.hasUnsavedChanges = true;

                // Save to local cache immediately
                this.saveLocalCache();

                // Auto-save to OneDrive if enabled
                if (this.autoSaveEnabled && this.accessToken) {
                    setTimeout(() => {
                        this.saveToOneDrive();
                    }, 2000); // Save after 2 seconds
                } else {
                    this.updateLocalCacheStatus('has-changes', `✏️ Manual changes saved locally (${this.manuallyEditedArticles.size} edited articles)`);
                }
            }

            // ===== FIXED AI CATEGORIZATION SYSTEM =====

            // Initialize enhanced category keywords with more sophisticated patterns
            initializeAIEnhancedCategoryKeywords() {
                return {
                    'Technology': {
                        icon: '💻',
                        confidence: 'high',
                        weight: 1.0, // NEW: Category weight for confidence calculation
                        keywords: ['tech', 'technology', 'programming', 'code', 'coding', 'software', 'developer', 'development', 'javascript', 'python', 'react', 'vue', 'angular', 'node', 'api', 'github', 'stackoverflow', 'algorithm', 'database', 'web', 'mobile', 'app', 'application', 'framework', 'library', 'bug', 'debug', 'frontend', 'backend', 'fullstack', 'devops', 'cloud', 'aws', 'azure', 'docker', 'kubernetes', 'microservices', 'serverless', 'machine learning', 'artificial intelligence', 'ai', 'ml', 'data science', 'blockchain', 'cryptocurrency', 'bitcoin', 'cybersecurity', 'security', 'hacking', 'penetration testing', 'open source', 'git', 'version control', 'ci/cd', 'automation', 'testing'],
                        domains: ['github.com', 'stackoverflow.com', 'dev.to', 'techcrunch.com', 'theverge.com', 'arstechnica.com', 'wired.com', 'hacker-news.firebaseapp.com', 'news.ycombinator.com', 'medium.com', 'hackernoon.com', 'freecodecamp.org', 'codepen.io', 'replit.com', 'glitch.com', 'netlify.com', 'vercel.com', 'heroku.com'],
                        aliases: ['tech', 'programming', 'software', 'coding', 'dev']
                    },
                    'Business': {
                        icon: '💼',
                        confidence: 'high',
                        weight: 1.0,
                        keywords: ['business', 'startup', 'entrepreneur', 'entrepreneurship', 'finance', 'financial', 'investment', 'investing', 'marketing', 'sales', 'strategy', 'management', 'leadership', 'company', 'revenue', 'profit', 'corporate', 'economics', 'market', 'industry', 'venture', 'funding', 'ipo', 'stocks', 'trading', 'cryptocurrency', 'fintech', 'saas', 'b2b', 'b2c', 'productivity', 'workflow', 'automation', 'remote work', 'freelancing', 'consulting', 'networking', 'career', 'job', 'hiring', 'hr', 'human resources', 'innovation', 'disruption', 'scaling', 'growth hacking'],
                        domains: ['linkedin.com', 'forbes.com', 'bloomberg.com', 'businessinsider.com', 'harvard.business.review', 'hbr.org', 'entrepreneur.com', 'inc.com', 'fastcompany.com', 'techcrunch.com', 'crunchbase.com', 'angellist.com', 'producthunt.com', 'ycombinator.com', 'stripe.com', 'shopify.com'],
                        aliases: ['startup', 'finance', 'entrepreneurship', 'corporate', 'work']
                    },
                    'Science': {
                        icon: '🔬',
                        confidence: 'high',
                        weight: 1.0,
                        keywords: ['science', 'scientific', 'research', 'study', 'data', 'analysis', 'experiment', 'discovery', 'theory', 'hypothesis', 'biology', 'chemistry', 'physics', 'medicine', 'medical', 'health', 'healthcare', 'climate', 'environment', 'environmental', 'space', 'astronomy', 'genetics', 'psychology', 'neuroscience', 'quantum', 'nuclear', 'biochemistry', 'biotechnology', 'pharmaceutical', 'vaccine', 'covid', 'pandemic', 'evolution', 'ecology', 'sustainability', 'renewable energy', 'solar', 'wind energy', 'genomics', 'bioengineering', 'nanotechnology'],
                        domains: ['arxiv.org', 'nature.com', 'science.org', 'plos.org', 'pubmed.ncbi.nlm.nih.gov', 'ncbi.nlm.nih.gov', 'sciencedirect.com', 'springer.com', 'wiley.com', 'cell.com', 'thelancet.com', 'nejm.org', 'scientificamerican.com', 'nationalgeographic.com', 'nasa.gov', 'nih.gov', 'cdc.gov'],
                        aliases: ['research', 'medical', 'biology', 'chemistry', 'physics']
                    },
                    'Politics': {
                        icon: '🏛️',
                        confidence: 'medium',
                        weight: 0.8,
                        keywords: ['politics', 'political', 'government', 'policy', 'election', 'vote', 'voting', 'democracy', 'republican', 'democrat', 'conservative', 'liberal', 'senate', 'congress', 'president', 'prime minister', 'parliament', 'legislation', 'law', 'constitution', 'supreme court', 'judge', 'campaign', 'candidate', 'poll', 'debate', 'immigration', 'healthcare reform', 'tax policy', 'foreign policy', 'diplomacy', 'war', 'peace', 'conflict', 'international relations', 'sovereignty', 'nationalism', 'globalization', 'activism', 'protest', 'rally'],
                        domains: ['politico.com', 'washingtonpost.com', 'nytimes.com', 'cnn.com', 'foxnews.com', 'bbc.com', 'reuters.com', 'ap.org', 'npr.org', 'pbs.org', 'theguardian.com', 'wsj.com', 'economist.com', 'foreignaffairs.com', 'foreignpolicy.com'],
                        aliases: ['government', 'election', 'policy', 'democracy', 'law']
                    },
                    'Philosophy': {
                        icon: '🤔',
                        confidence: 'medium',
                        weight: 0.7,
                        keywords: ['philosophy', 'philosophical', 'ethics', 'moral', 'morality', 'epistemology', 'metaphysics', 'logic', 'reasoning', 'consciousness', 'existentialism', 'stoicism', 'buddhism', 'mindfulness', 'meditation', 'wisdom', 'truth', 'reality', 'existence', 'meaning', 'purpose', 'free will', 'determinism', 'phenomenology', 'nihilism', 'absurdism', 'pragmatism', 'rationalism', 'empiricism', 'virtue', 'justice', 'freedom', 'rights', 'utilitarianism', 'deontology', 'virtue ethics', 'critical thinking'],
                        domains: ['plato.stanford.edu', 'philpapers.org', 'philosophynow.org', 'aeon.co', 'thephilosopher1923.org'],
                        aliases: ['ethics', 'moral', 'wisdom', 'consciousness', 'existential']
                    },
                    'Psychology': {
                        icon: '🧠',
                        confidence: 'medium',
                        weight: 0.8,
                        keywords: ['psychology', 'psychological', 'mental health', 'therapy', 'counseling', 'behavior', 'cognitive', 'emotion', 'personality', 'depression', 'anxiety', 'stress', 'trauma', 'ptsd', 'mindfulness', 'self-help', 'motivation', 'habit', 'addiction', 'neurology', 'brain', 'mind', 'learning', 'memory', 'perception', 'development', 'social psychology', 'behavioral economics', 'decision making', 'bias', 'persuasion', 'influence', 'relationships', 'communication', 'leadership psychology'],
                        domains: ['psychologytoday.com', 'apa.org', 'psych.org', 'mindful.org', 'headspace.com', 'calm.com'],
                        aliases: ['mental health', 'therapy', 'behavior', 'mind', 'brain']
                    },
                    'Design': {
                        icon: '🎨',
                        confidence: 'high',
                        weight: 1.0,
                        keywords: ['design', 'designer', 'ui', 'ux', 'user experience', 'user interface', 'interface', 'visual', 'graphic', 'creative', 'art', 'artist', 'illustration', 'typography', 'color', 'layout', 'prototype', 'wireframe', 'figma', 'sketch', 'photoshop', 'adobe', 'branding', 'logo', 'icon', 'website design', 'web design', 'mobile design', 'app design', 'product design', 'industrial design', 'fashion', 'architecture', 'interior design', 'photography', 'video', 'animation', 'motion graphics', 'accessibility', 'usability'],
                        domains: ['dribbble.com', 'behance.net', 'medium.com', 'uxdesign.cc', 'designbetter.co', 'smashingmagazine.com', 'awwwards.com', 'cssdesignawards.com', 'siteinspire.com', 'pinterest.com', 'unsplash.com', 'adobe.com', 'figma.com', 'invisionapp.com', 'framer.com'],
                        aliases: ['ui', 'ux', 'graphic', 'visual', 'creative']
                    },
                    'News': {
                        icon: '📰',
                        confidence: 'medium',
                        weight: 0.6,
                        keywords: ['news', 'breaking', 'breaking news', 'report', 'reporter', 'journalist', 'journalism', 'media', 'current events', 'headline', 'press', 'investigation', 'crisis', 'conflict', 'war', 'peace', 'diplomacy', 'economy', 'economic', 'recession', 'inflation', 'gdp', 'unemployment', 'stock market', 'breaking', 'urgent', 'live', 'update', 'scandal', 'controversy', 'exclusive', 'interview', 'analysis', 'opinion', 'editorial'],
                        domains: ['bbc.com', 'cnn.com', 'nytimes.com', 'washingtonpost.com', 'theguardian.com', 'reuters.com', 'ap.org', 'npr.org', 'pbs.org', 'abcnews.go.com', 'cbsnews.com', 'nbcnews.com', 'foxnews.com', 'usatoday.com', 'wsj.com', 'ft.com', 'economist.com', 'politico.com', 'axios.com', 'vox.com'],
                        aliases: ['journalism', 'media', 'current events', 'breaking']
                    },
                    'Education': {
                        icon: '🎓',
                        confidence: 'high',
                        weight: 0.9,
                        keywords: ['education', 'educational', 'learning', 'learn', 'course', 'courses', 'tutorial', 'tutorials', 'lesson', 'lessons', 'teach', 'teaching', 'teacher', 'student', 'university', 'college', 'school', 'academic', 'academia', 'knowledge', 'skill', 'skills', 'training', 'certification', 'certificate', 'degree', 'bachelor', 'master', 'phd', 'doctorate', 'mooc', 'online learning', 'e-learning', 'study', 'studying', 'exam', 'test', 'quiz', 'homework', 'assignment', 'research', 'curriculum', 'pedagogy'],
                        domains: ['coursera.org', 'edx.org', 'khanacademy.org', 'udemy.com', 'wikipedia.org', 'mit.edu', 'stanford.edu', 'harvard.edu', 'berkeley.edu', 'yale.edu', 'oxford.ac.uk', 'cambridge.org', 'skillshare.com', 'lynda.com', 'pluralsight.com', 'codecademy.com', 'duolingo.com', 'masterclass.com'],
                        aliases: ['learning', 'course', 'tutorial', 'academic', 'study']
                    },
                    'Entertainment': {
                        icon: '🎬',
                        confidence: 'medium',
                        weight: 0.7,
                        keywords: ['entertainment', 'movie', 'movies', 'film', 'films', 'cinema', 'tv', 'television', 'show', 'shows', 'series', 'episode', 'season', 'music', 'song', 'album', 'artist', 'band', 'concert', 'festival', 'game', 'games', 'gaming', 'video games', 'esports', 'streaming', 'netflix', 'amazon prime', 'disney', 'hulu', 'spotify', 'apple music', 'youtube', 'twitch', 'celebrity', 'celebrities', 'hollywood', 'broadway', 'theater', 'comedy', 'humor', 'funny', 'meme', 'viral', 'pop culture'],
                        domains: ['youtube.com', 'netflix.com', 'spotify.com', 'imdb.com', 'ign.com', 'gamespot.com', 'polygon.com', 'kotaku.com', 'variety.com', 'hollywoodreporter.com', 'ew.com', 'rollingstone.com', 'billboard.com', 'pitchfork.com', 'reddit.com', 'twitch.tv', 'steam.com', 'epicgames.com', 'rotten-tomatoes.com'],
                        aliases: ['movies', 'music', 'gaming', 'tv', 'celebrity']
                    },
                    'Health': {
                        icon: '🏥',
                        confidence: 'high',
                        weight: 0.9,
                        keywords: ['health', 'healthy', 'healthcare', 'medical', 'medicine', 'doctor', 'physician', 'patient', 'hospital', 'clinic', 'treatment', 'therapy', 'disease', 'illness', 'symptoms', 'diagnosis', 'cure', 'medication', 'drug', 'pharmaceutical', 'fitness', 'exercise', 'workout', 'gym', 'running', 'yoga', 'nutrition', 'diet', 'food', 'vitamins', 'supplements', 'wellness', 'mental health', 'depression', 'anxiety', 'stress', 'mindfulness', 'meditation', 'sleep', 'weight loss', 'weight gain', 'muscle', 'cardio', 'prevention', 'immunization'],
                        domains: ['mayoclinic.org', 'webmd.com', 'healthline.com', 'nih.gov', 'cdc.gov', 'who.int', 'medicalnewstoday.com', 'everydayhealth.com', 'health.com', 'prevention.com', 'menshealth.com', 'womenshealthmag.com', 'self.com', 'shape.com', 'fitbit.com', 'myfitnesspal.com', 'headspace.com', 'calm.com'],
                        aliases: ['medical', 'fitness', 'wellness', 'nutrition', 'healthcare']
                    },
                    'Sports': {
                        icon: '⚽',
                        confidence: 'medium',
                        weight: 0.8,
                        keywords: ['sports', 'sport', 'football', 'soccer', 'basketball', 'baseball', 'tennis', 'golf', 'hockey', 'olympics', 'athlete', 'team', 'game', 'match', 'tournament', 'championship', 'league', 'player', 'coach', 'training', 'fitness', 'competition', 'score', 'win', 'lose', 'victory', 'defeat', 'mvp', 'draft', 'trade', 'playoff', 'season', 'stadium', 'fan', 'espn', 'nfl', 'nba', 'mlb', 'nhl', 'fifa', 'uefa'],
                        domains: ['espn.com', 'sports.yahoo.com', 'bleacherreport.com', 'si.com', 'nfl.com', 'nba.com', 'mlb.com', 'nhl.com', 'fifa.com', 'uefa.com', 'olympic.org'],
                        aliases: ['athletics', 'competition', 'team', 'game', 'athlete']
                    },
                    'Travel': {
                        icon: '✈️',
                        confidence: 'medium',
                        weight: 0.7,
                        keywords: ['travel', 'traveling', 'trip', 'vacation', 'holiday', 'tourism', 'tourist', 'destination', 'flight', 'flights', 'airline', 'airport', 'hotel', 'accommodation', 'booking', 'airbnb', 'hostel', 'resort', 'adventure', 'explore', 'exploring', 'backpacking', 'hiking', 'camping', 'road trip', 'cruise', 'culture', 'cultural', 'country', 'city', 'guide', 'travel guide', 'itinerary', 'budget travel', 'luxury travel', 'solo travel', 'family travel', 'business travel', 'nomad'],
                        domains: ['tripadvisor.com', 'booking.com', 'airbnb.com', 'expedia.com', 'kayak.com', 'skyscanner.com', 'hotels.com', 'agoda.com', 'lonelyplanet.com', 'fodors.com', 'frommers.com', 'roughguides.com', 'timeout.com', 'cntraveler.com', 'travelandleisure.com', 'nationalgeographic.com', 'nomadicmatt.com', 'backpacker.com'],
                        aliases: ['vacation', 'tourism', 'adventure', 'explore', 'journey']
                    },
                    'Food': {
                        icon: '🍳',
                        confidence: 'medium',
                        weight: 0.8,
                        keywords: ['food', 'recipe', 'recipes', 'cooking', 'cook', 'chef', 'kitchen', 'restaurant', 'restaurants', 'dining', 'cuisine', 'culinary', 'ingredient', 'ingredients', 'meal', 'meals', 'dish', 'dishes', 'baking', 'bake', 'bread', 'cake', 'dessert', 'nutrition', 'diet', 'healthy eating', 'vegetarian', 'vegan', 'gluten-free', 'organic', 'local food', 'farm to table', 'foodie', 'wine', 'beer', 'cocktail', 'beverage', 'coffee', 'tea', 'breakfast', 'lunch', 'dinner'],
                        domains: ['allrecipes.com', 'foodnetwork.com', 'epicurious.com', 'bonappetit.com', 'seriouseats.com', 'food52.com', 'tasty.co', 'delish.com', 'eatingwell.com', 'cookinglight.com', 'yummly.com', 'thespruceeats.com', 'saveur.com', 'foodandwine.com', 'chowhound.com', 'yelp.com', 'zomato.com', 'opentable.com'],
                        aliases: ['cooking', 'recipe', 'cuisine', 'dining', 'culinary']
                    },
                    'Environment': {
                        icon: '🌱',
                        confidence: 'medium',
                        weight: 0.8,
                        keywords: ['environment', 'environmental', 'climate', 'climate change', 'global warming', 'sustainability', 'sustainable', 'renewable energy', 'solar', 'wind', 'green', 'eco', 'ecology', 'ecosystem', 'biodiversity', 'conservation', 'pollution', 'carbon', 'emissions', 'greenhouse gas', 'fossil fuels', 'clean energy', 'recycling', 'waste', 'plastic', 'ocean', 'forest', 'deforestation', 'wildlife', 'endangered species', 'carbon footprint', 'renewable', 'organic'],
                        domains: ['greenpeace.org', 'wwf.org', 'epa.gov', 'unfccc.int', 'ipcc.ch', 'nationalgeographic.com', 'nature.org', 'earthday.org'],
                        aliases: ['climate', 'sustainability', 'green', 'ecology', 'conservation']
                    },
                    'Lifestyle': {
                        icon: '🏠',
                        confidence: 'low',
                        weight: 0.5,
                        keywords: ['lifestyle', 'life', 'living', 'home', 'house', 'apartment', 'decor', 'decoration', 'interior', 'furniture', 'diy', 'crafts', 'gardening', 'pets', 'family', 'parenting', 'relationships', 'dating', 'marriage', 'wedding', 'fashion', 'style', 'beauty', 'skincare', 'makeup', 'hair', 'shopping', 'personal development', 'self-improvement', 'habits', 'productivity', 'organization', 'minimalism', 'self-care', 'work-life balance'],
                        domains: ['pinterest.com', 'instagram.com', 'buzzfeed.com', 'refinery29.com', 'popsugar.com', 'cosmopolitan.com', 'elle.com', 'vogue.com', 'marieclaire.com', 'goodhousekeeping.com', 'countryliving.com', 'apartmenttherapy.com', 'houzz.com', 'realsimple.com', 'oprah.com', 'goop.com', 'theeverygirl.com', 'cupcakesandcashmere.com'],
                        aliases: ['personal', 'self-improvement', 'home', 'family', 'relationships']
                    }
                };
            }

            // NEW: Initialize context phrases for better accuracy
            initializeContextPhrases() {
                return {
                    'Technology': [
                        'software development', 'web development', 'mobile development', 'app development',
                        'machine learning', 'artificial intelligence', 'data science', 'deep learning',
                        'programming language', 'javascript framework', 'react tutorial', 'python guide',
                        'api development', 'database design', 'cloud computing', 'devops practices',
                        'open source project', 'code review', 'software engineering', 'technical debt',
                        'agile development', 'microservices architecture', 'docker container',
                        'kubernetes deployment', 'ci/cd pipeline', 'version control', 'git workflow'
                    ],
                    'Business': [
                        'business strategy', 'startup funding', 'venture capital', 'market research',
                        'customer acquisition', 'revenue growth', 'profit margin', 'business model',
                        'digital transformation', 'market analysis', 'competitive advantage',
                        'investment opportunity', 'financial planning', 'cash flow management',
                        'brand strategy', 'marketing campaign', 'sales funnel', 'lead generation',
                        'business development', 'strategic partnership', 'merger acquisition',
                        'ipo process', 'stock market', 'financial analysis', 'growth hacking',
                        'lean startup', 'product market fit', 'scaling business', 'exit strategy'
                    ],
                    'Science': [
                        'scientific study', 'research findings', 'peer review', 'clinical trial',
                        'scientific method', 'research paper', 'laboratory study', 'experimental results',
                        'data analysis', 'statistical significance', 'hypothesis testing',
                        'scientific discovery', 'breakthrough research', 'academic paper',
                        'medical research', 'pharmaceutical study', 'vaccine development',
                        'climate study', 'environmental research', 'space exploration',
                        'genetic research', 'biotechnology advancement', 'scientific breakthrough'
                    ],
                    'Politics': [
                        'political campaign', 'election results', 'policy debate', 'government policy',
                        'legislative process', 'political analysis', 'campaign finance', 'voter turnout',
                        'political strategy', 'election forecast', 'polling data', 'political reform',
                        'foreign policy', 'domestic policy', 'political party', 'campaign trail',
                        'political scandal', 'government reform', 'political movement'
                    ],
                    'Philosophy': [
                        'philosophical debate', 'ethical dilemma', 'moral philosophy', 'critical thinking',
                        'philosophical argument', 'existential question', 'ethical framework',
                        'philosophical theory', 'moral reasoning', 'consciousness studies',
                        'philosophy of mind', 'ethical principles', 'philosophical inquiry'
                    ],
                    'Psychology': [
                        'psychological study', 'mental health research', 'behavioral analysis',
                        'cognitive therapy', 'psychological assessment', 'behavior modification',
                        'mental health treatment', 'psychological disorder', 'therapy session',
                        'psychological well-being', 'cognitive development', 'social psychology'
                    ],
                    'Design': [
                        'user experience', 'user interface', 'design thinking', 'visual design',
                        'graphic design', 'web design', 'mobile design', 'product design',
                        'design system', 'design process', 'creative process', 'design principles',
                        'user research', 'design strategy', 'brand design', 'interaction design'
                    ],
                    'News': [
                        'breaking news', 'news report', 'current events', 'news analysis',
                        'investigative journalism', 'news story', 'media coverage', 'press release',
                        'news update', 'live coverage', 'news conference', 'media investigation'
                    ],
                    'Education': [
                        'educational program', 'learning experience', 'online course', 'educational research',
                        'teaching method', 'learning strategy', 'educational technology', 'curriculum development',
                        'student learning', 'academic research', 'educational policy', 'teaching practice',
                        'learning platform', 'educational content', 'study guide', 'academic course'
                    ],
                    'Entertainment': [
                        'movie review', 'tv show', 'music album', 'entertainment news',
                        'celebrity news', 'film review', 'game review', 'streaming service',
                        'entertainment industry', 'box office', 'music industry', 'gaming industry',
                        'pop culture', 'celebrity interview', 'entertainment media'
                    ],
                    'Health': [
                        'health study', 'medical research', 'health care', 'fitness program',
                        'nutrition guide', 'wellness program', 'health advice', 'medical treatment',
                        'health benefits', 'exercise routine', 'healthy lifestyle', 'medical breakthrough',
                        'health policy', 'public health', 'preventive care', 'mental health'
                    ],
                    'Sports': [
                        'sports news', 'game recap', 'sports analysis', 'athletic performance',
                        'sports team', 'championship game', 'sports statistics', 'player profile',
                        'sports strategy', 'training regimen', 'sports medicine', 'competitive sports'
                    ],
                    'Travel': [
                        'travel guide', 'destination review', 'travel tips', 'vacation planning',
                        'travel experience', 'cultural experience', 'travel blog', 'adventure travel',
                        'travel destination', 'tourism industry', 'travel advice', 'travel story'
                    ],
                    'Food': [
                        'food recipe', 'cooking technique', 'restaurant review', 'culinary arts',
                        'food culture', 'cooking tips', 'food industry', 'nutrition facts',
                        'cooking guide', 'food trends', 'culinary experience', 'food preparation'
                    ],
                    'Environment': [
                        'climate change', 'environmental impact', 'sustainability practices', 'green technology',
                        'environmental policy', 'conservation efforts', 'renewable energy', 'carbon footprint',
                        'environmental science', 'eco-friendly', 'climate science', 'environmental protection'
                    ],
                    'Lifestyle': [
                        'lifestyle tips', 'personal development', 'life advice', 'home improvement',
                        'self improvement', 'lifestyle choice', 'personal growth', 'life balance',
                        'relationship advice', 'personal finance', 'lifestyle blog', 'daily routine'
                    ]
                };
            }

            // NEW: Initialize negative keywords to prevent wrong categorization
            initializeNegativeKeywords() {
                return {
                    'Technology': ['cooking recipe', 'fitness workout', 'travel guide', 'restaurant review', 'fashion style', 'beauty tips', 'home decor', 'gardening tips', 'pet care', 'wedding planning'],
                    'Business': ['game walkthrough', 'movie review', 'cooking tutorial', 'fitness routine', 'travel blog', 'sports news', 'entertainment news', 'celebrity gossip'],
                    'Science': ['business strategy', 'marketing tips', 'entertainment news', 'sports recap', 'fashion trends', 'cooking recipe', 'travel guide'],
                    'Politics': ['cooking recipe', 'fitness tips', 'entertainment news', 'sports news', 'technology tutorial', 'game review', 'fashion style'],
                    'Philosophy': ['business news', 'sports update', 'cooking recipe', 'technology news', 'entertainment gossip', 'fitness routine'],
                    'Psychology': ['business strategy', 'sports news', 'cooking tips', 'technology review', 'travel guide', 'entertainment news'],
                    'Design': ['political news', 'sports recap', 'cooking recipe', 'business finance', 'scientific study', 'entertainment gossip'],
                    'News': ['cooking tutorial', 'fitness routine', 'game walkthrough', 'design tutorial', 'travel blog', 'fashion tips'],
                    'Education': ['entertainment gossip', 'sports news', 'business finance', 'cooking recipe', 'fashion trends', 'celebrity news'],
                    'Entertainment': ['business strategy', 'scientific study', 'political analysis', 'fitness routine', 'cooking recipe', 'technology tutorial'],
                    'Health': ['business news', 'political update', 'entertainment gossip', 'sports strategy', 'technology review', 'cooking recipe'],
                    'Sports': ['cooking recipe', 'business strategy', 'technology tutorial', 'entertainment gossip', 'fashion tips', 'home decor'],
                    'Travel': ['business finance', 'sports news', 'technology review', 'political analysis', 'entertainment gossip', 'fitness routine'],
                    'Food': ['technology tutorial', 'business strategy', 'sports news', 'political update', 'entertainment news', 'fitness routine'],
                    'Environment': ['entertainment gossip', 'sports recap', 'cooking recipe', 'fashion trends', 'business finance', 'technology review'],
                    'Lifestyle': ['technology programming', 'business finance', 'scientific research', 'political analysis', 'sports strategy', 'academic study']
                };
            }

            // Initialize category synonyms for better matching
            initializeCategorySynonyms() {
                return {
                    'Technology': ['tech', 'programming', 'software', 'coding', 'dev', 'digital', 'computer', 'IT'],
                    'Business': ['startup', 'finance', 'entrepreneurship', 'corporate', 'work', 'career', 'management'],
                    'Science': ['research', 'medical', 'biology', 'chemistry', 'physics', 'study', 'academic'],
                    'Politics': ['government', 'election', 'policy', 'democracy', 'law', 'legal', 'political'],
                    'Philosophy': ['ethics', 'moral', 'wisdom', 'consciousness', 'existential', 'philosophical'],
                    'Psychology': ['mental health', 'therapy', 'behavior', 'mind', 'brain', 'psychological'],
                    'Design': ['ui', 'ux', 'graphic', 'visual', 'creative', 'art', 'aesthetic'],
                    'News': ['journalism', 'media', 'current events', 'breaking', 'press', 'report'],
                    'Education': ['learning', 'course', 'tutorial', 'academic', 'study', 'school', 'university'],
                    'Entertainment': ['movies', 'music', 'gaming', 'tv', 'celebrity', 'show', 'film', 'entertainment'],
                    'Health': ['medical', 'fitness', 'wellness', 'nutrition', 'healthcare', 'medicine', 'health'],
                    'Sports': ['athletics', 'competition', 'team', 'game', 'athlete', 'sport', 'fitness'],
                    'Travel': ['vacation', 'tourism', 'adventure', 'explore', 'journey', 'trip', 'travel'],
                    'Food': ['cooking', 'recipe', 'cuisine', 'dining', 'culinary', 'food', 'restaurant'],
                    'Environment': ['climate', 'sustainability', 'green', 'ecology', 'conservation', 'environmental'],
                    'Lifestyle': ['personal', 'self-improvement', 'home', 'family', 'relationships', 'lifestyle']
                };
            }

            // ===== FIXED AI CATEGORIZATION SYSTEM =====

            // FIXED: Improved AI categorization with much better accuracy
            categorizeArticle(article) {
                const title = (article.title || '').toLowerCase();
                const excerpt = (article.excerpt || '').toLowerCase();
                const url = (article.url || '').toLowerCase();
                const domain = this.getDomain(article.url).toLowerCase();
                const content = this.getArticleContentForAnalysis(article).toLowerCase();

                // FIXED: Better text analysis with weighted importance
                const titleWeight = 3.0;    // Title is most important
                const excerptWeight = 2.0;  // Excerpt is very important  
                const contentWeight = 1.0;  // Content is helpful but not always available

                const scores = new Map();
                let analysisDetails = {};

                console.log(`🧠 FIXED AI categorization for: "${article.title.substring(0, 40)}..."`);

                for (const [categoryName, categoryData] of Object.entries(this.categoryKeywords)) {
                    let score = 0;
                    let reasons = [];
                    let confidence = 'low';

                    // PRIORITY 1: FIXED Context phrase matching with weighted scoring
                    const contextPhrases = this.contextPhrases[categoryName] || [];
                    let contextMatches = 0;
                    for (const phrase of contextPhrases) {
                        let phraseScore = 0;
                        if (title.includes(phrase)) {
                            phraseScore += 200 * titleWeight;  // Much higher for title
                            contextMatches++;
                            reasons.push(`title-context: "${phrase}"`);
                        }
                        if (excerpt.includes(phrase)) {
                            phraseScore += 150 * excerptWeight; // High for excerpt
                            contextMatches++;
                            reasons.push(`excerpt-context: "${phrase}"`);
                        }
                        if (content.includes(phrase)) {
                            phraseScore += 100 * contentWeight; // Lower for content
                            reasons.push(`content-context: "${phrase}"`);
                        }
                        score += phraseScore;
                        if (phraseScore > 200) confidence = 'very-high';
                    }

                    // PRIORITY 2: FIXED Negative keyword filtering (stronger penalty)
                    const negativeKeywords = this.negativeKeywords[categoryName] || [];
                    let negativeMatches = 0;
                    for (const negative of negativeKeywords) {
                        let penalty = 0;
                        if (title.includes(negative)) {
                            penalty += 300; // Heavy penalty for title
                            negativeMatches++;
                            reasons.push(`NEGATIVE-title: "${negative}"`);
                        }
                        if (excerpt.includes(negative)) {
                            penalty += 200; // Heavy penalty for excerpt
                            negativeMatches++;
                            reasons.push(`NEGATIVE-excerpt: "${negative}"`);
                        }
                        score -= penalty; // Apply penalty
                    }

                    // PRIORITY 3: FIXED Domain matching (reduced to 10 points max)
                    const exactDomainMatch = categoryData.domains.some(d => domain === d || domain.includes(d));
                    if (exactDomainMatch) {
                        score += 10; // MUCH lower domain influence (was 50, now 10)
                        reasons.push(`domain: ${domain}`);
                    }

                    // PRIORITY 4: FIXED Title analysis with exact matching priority
                    let titleMatches = 0;
                    for (const keyword of categoryData.keywords) {
                        let keywordScore = 0;

                        // Exact phrase in title (highest priority)
                        if (keyword.includes(' ') && title.includes(keyword)) {
                            keywordScore += 150 * titleWeight;
                            titleMatches++;
                            reasons.push(`title-exact-phrase: "${keyword}"`);
                        }
                        // Exact word boundaries in title
                        else if (new RegExp(`\\b${keyword}\\b`).test(title)) {
                            keywordScore += 100 * titleWeight;
                            titleMatches++;
                            reasons.push(`title-exact-word: "${keyword}"`);
                        }
                        // Partial match in title (lower score)
                        else if (title.includes(keyword)) {
                            keywordScore += 50 * titleWeight;
                            titleMatches++;
                            reasons.push(`title-partial: "${keyword}"`);
                        }

                        // FIXED: Same for excerpt with lower weight
                        if (keyword.includes(' ') && excerpt.includes(keyword)) {
                            keywordScore += 100 * excerptWeight;
                            reasons.push(`excerpt-exact-phrase: "${keyword}"`);
                        }
                        else if (new RegExp(`\\b${keyword}\\b`).test(excerpt)) {
                            keywordScore += 70 * excerptWeight;
                            reasons.push(`excerpt-exact-word: "${keyword}"`);
                        }
                        else if (excerpt.includes(keyword)) {
                            keywordScore += 35 * excerptWeight;
                            reasons.push(`excerpt-partial: "${keyword}"`);
                        }

                        score += keywordScore;
                    }

                    // PRIORITY 5: Enhanced synonym matching
                    const synonyms = this.categorySynonyms[categoryName] || [];
                    for (const synonym of synonyms) {
                        if (title.includes(synonym)) {
                            score += 60 * titleWeight; // Higher weight for title
                            titleMatches++;
                            reasons.push(`title-synonym: "${synonym}"`);
                        }
                        if (excerpt.includes(synonym)) {
                            score += 40 * excerptWeight; // Lower weight for excerpt
                            reasons.push(`excerpt-synonym: "${synonym}"`);
                        }
                    }

                    // PRIORITY 6: FIXED Content analysis (only if substantial content exists)
                    if (content.length > 100) { // Only analyze if we have real content
                        let contentMatches = 0;
                        for (const keyword of categoryData.keywords) {
                            const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                            const matches = content.match(regex);
                            if (matches) {
                                const matchScore = Math.min(matches.length * 15, 60) * contentWeight;
                                score += matchScore;
                                contentMatches += matches.length;
                                if (matches.length > 2) {
                                    reasons.push(`content: "${keyword}" (${matches.length}x)`);
                                }
                            }
                        }
                    }

                    // FIXED: Better confidence calculation
                    if (contextMatches >= 2 && negativeMatches === 0) {
                        confidence = 'very-high';
                        score += 50; // Confidence bonus
                    } else if (contextMatches >= 1 && titleMatches >= 2 && negativeMatches === 0) {
                        confidence = 'high';
                        score += 30;
                    } else if (titleMatches >= 2 && negativeMatches === 0) {
                        confidence = 'medium';
                        score += 15;
                    } else if (negativeMatches > 0) {
                        confidence = 'very-low'; // Negative keywords found
                    }

                    // FIXED: Apply category weight
                    const categoryWeight = categoryData.weight || 1.0;
                    score = Math.round(score * categoryWeight);

                    // FIXED: Better pattern recognition bonuses
                    if (categoryName === 'Technology') {
                        if (this.hasStrongTechIndicators(title, excerpt, domain)) {
                            score += 40;
                            reasons.push('strong-tech-indicators');
                        }
                    }

                    if (categoryName === 'Science') {
                        if (this.hasStrongScienceIndicators(title, excerpt, domain)) {
                            score += 40;
                            reasons.push('strong-science-indicators');
                        }
                    }

                    // Manual overrides for known problematic cases
                    const manualOverrides = this.getManualCategoryOverrides(title, domain, categoryName);
                    if (manualOverrides.override) {
                        score = manualOverrides.score;
                        reasons.push(manualOverrides.reason);
                        confidence = manualOverrides.confidence;
                    }

                    // Ensure minimum score is 0
                    score = Math.max(0, score);

                    scores.set(categoryName, score);
                    analysisDetails[categoryName] = {
                        score: score,
                        reasons: reasons,
                        confidence: confidence,
                        contextMatches: contextMatches,
                        negativeMatches: negativeMatches,
                        titleMatches: titleMatches
                    };
                }

                // FIXED: Much better decision making
                const sortedScores = Array.from(scores.entries()).sort((a, b) => b[1] - a[1]);

                let bestCategory = 'Lifestyle';
                let bestScore = 0;
                let secondBestScore = 0;

                if (sortedScores.length >= 1) {
                    bestScore = sortedScores[0][1];
                    bestCategory = sortedScores[0][0];
                }
                if (sortedScores.length >= 2) {
                    secondBestScore = sortedScores[1][1];
                }

                // FIXED: Better thresholds and logic
                const minThreshold = 100; // Higher threshold for better accuracy (was 80)
                const confidenceGap = bestScore - secondBestScore;
                const categoryConfidence = analysisDetails[bestCategory]?.confidence || 'low';
                const hasNegativeMatches = analysisDetails[bestCategory]?.negativeMatches > 0;

                let finalCategory = bestCategory;
                let aiEnhanced = false;

                // FIXED: Better decision logic
                if (hasNegativeMatches) {
                    // If negative keywords found, try next best category
                    if (sortedScores.length > 1 && sortedScores[1][1] >= 60) {
                        finalCategory = sortedScores[1][0];
                        aiEnhanced = true;
                        console.log(`🤖 Negative keywords detected, using second choice: ${finalCategory}`);
                    } else {
                        finalCategory = 'Lifestyle';
                        console.log(`🤖 Negative keywords detected, using default`);
                    }
                } else if (bestScore < minThreshold) {
                    finalCategory = 'Lifestyle';
                    console.log(`🤖 Below threshold (${bestScore} < ${minThreshold}), using default`);
                } else if (confidenceGap < 30 && bestScore < 150) {
                    // Low confidence - use enhanced fallback
                    finalCategory = this.enhancedAICategoryFallback(article, sortedScores, analysisDetails);
                    aiEnhanced = true;
                    console.log(`🤖 Enhanced AI fallback applied: ${finalCategory}`);
                } else {
                    console.log(`✅ High confidence categorization: ${finalCategory} (score: ${bestScore}, gap: ${confidenceGap})`);
                }

                // Store results
                article.category = finalCategory;
                article.categoryScore = bestScore;
                article.categoryConfidence = confidenceGap;
                article.aiEnhanced = aiEnhanced;
                article.categoryAnalysis = analysisDetails[finalCategory];

                console.log(`🎯 FIXED: "${article.title.substring(0, 30)}..." → ${finalCategory} (score: ${bestScore}, confidence: ${categoryConfidence})`);
                return finalCategory;
            }

            // NEW: Manual category overrides for known problematic cases
            getManualCategoryOverrides(title, domain, categoryName) {
                // GitHub business/startup articles should be Business, not Technology
                if (domain.includes('github.com') && categoryName === 'Business') {
                    if (title.includes('startup') || title.includes('business') || title.includes('company') || title.includes('funding')) {
                        return {
                            override: true,
                            score: 200,
                            reason: 'manual-override-github-business',
                            confidence: 'high'
                        };
                    }
                }

                // Technology articles about business topics should stay Technology
                if (categoryName === 'Technology' && (title.includes('saas') || title.includes('b2b') || title.includes('fintech'))) {
                    return {
                        override: true,
                        score: 180,
                        reason: 'manual-override-tech-business',
                        confidence: 'high'
                    };
                }

                // Science research on arXiv should always be Science
                if (domain.includes('arxiv.org') && categoryName === 'Science') {
                    return {
                        override: true,
                        score: 250,
                        reason: 'manual-override-arxiv-science',
                        confidence: 'very-high'
                    };
                }

                return { override: false };
            }

            // FIXED: Better pattern recognition helpers
            hasStrongTechIndicators(title, excerpt, domain) {
                const strongTechPatterns = [
                    /\b(programming|coding|software|developer|api|framework|javascript|python|react|vue|angular)\b/i,
                    /\b(github|stackoverflow|dev\.to|programming|algorithm|database|docker|kubernetes)\b/i
                ];

                const text = `${title} ${excerpt}`;
                return strongTechPatterns.some(pattern => pattern.test(text)) ||
                    ['github.com', 'stackoverflow.com', 'dev.to'].some(d => domain.includes(d));
            }

            hasStrongScienceIndicators(title, excerpt, domain) {
                const strongSciencePatterns = [
                    /\b(research|study|scientific|experiment|clinical|peer.?review|hypothesis|laboratory)\b/i,
                    /\b(nature|science|arxiv|pubmed|journal|academic|university|biology|chemistry|physics)\b/i
                ];

                const text = `${title} ${excerpt}`;
                return strongSciencePatterns.some(pattern => pattern.test(text)) ||
                    ['arxiv.org', 'nature.com', 'science.org', 'pubmed.ncbi.nlm.nih.gov'].some(d => domain.includes(d));
            }

            // FIXED: Enhanced fallback with better logic
            enhancedAICategoryFallback(article, sortedScores, analysisDetails) {
                const title = article.title.toLowerCase();
                const excerpt = (article.excerpt || '').toLowerCase();
                const domain = this.getDomain(article.url).toLowerCase();

                console.log(`🧠 Enhanced fallback analysis for: "${title.substring(0, 30)}..."`);

                // Look for clear content type indicators
                const contentTypePatterns = {
                    'Technology': /\b(code|programming|software|api|tech|javascript|python|react|github|dev)\b/i,
                    'Science': /\b(research|study|scientific|experiment|clinical|journal|academic|university)\b/i,
                    'Business': /\b(startup|business|finance|investment|market|company|revenue|entrepreneur)\b/i,
                    'Education': /\b(course|tutorial|learn|teach|education|guide|lesson|training)\b/i,
                    'Health': /\b(health|medical|fitness|nutrition|wellness|exercise|diet|mental.?health)\b/i
                };

                const text = `${title} ${excerpt}`;

                // Find the category with the strongest pattern match
                for (const [category, pattern] of Object.entries(contentTypePatterns)) {
                    if (pattern.test(text)) {
                        // Check if this category had a reasonable score
                        const categoryScore = sortedScores.find(([cat, score]) => cat === category);
                        if (categoryScore && categoryScore[1] >= 40) {
                            console.log(`🎯 Pattern-based fallback: ${category}`);
                            return category;
                        }
                    }
                }

                // If no patterns match, use the highest scoring category if it's reasonable
                if (sortedScores.length > 0 && sortedScores[0][1] >= 60) {
                    return sortedScores[0][0];
                }

                return 'Lifestyle';
            }

            // Debug function to check article data
            debugArticleData(article) {
                console.log('🔍 ARTICLE DEBUG:', {
                    title: article.title,
                    titleLength: article.title?.length || 0,
                    excerpt: article.excerpt?.substring(0, 100) + '...',
                    excerptLength: article.excerpt?.length || 0,
                    domain: this.getDomain(article.url),
                    url: article.url,
                    hasContent: !!article.content,
                    contentLength: article.content?.length || 0,
                    availableFields: Object.keys(article).filter(key =>
                        typeof article[key] === 'string' && article[key].length > 0
                    )
                });
                return article;
            }

            // ===== END FIXED AI CATEGORIZATION SYSTEM =====

            setupEventListeners() {
                console.log('🔧 Setting up event listeners...');

                // Sidebar connect button
                const connectBtnSidebar = document.getElementById('connectBtnSidebar');
                if (connectBtnSidebar) {
                    connectBtnSidebar.addEventListener('click', () => {
                        console.log('🔐 Connect button clicked');
                        this.authenticate();
                    });
                    console.log('✅ Connect button event listener added');
                } else {
                    console.error('❌ Connect button not found!');
                }

                // Navigation buttons - these exist in the HTML
                const refreshNavBtn = document.getElementById('refreshNavBtn');
                if (refreshNavBtn) {
                    refreshNavBtn.addEventListener('click', () => this.loadFromOneDrive());
                }

                const saveNavBtn = document.getElementById('saveNavBtn');
                if (saveNavBtn) {
                    saveNavBtn.addEventListener('click', () => this.saveToOneDrive());
                }

                const syncNavBtn = document.getElementById('syncNavBtn');
                if (syncNavBtn) {
                    syncNavBtn.addEventListener('click', () => this.forceSyncImages());
                }

                const retryNavBtn = document.getElementById('retryNavBtn');
                if (retryNavBtn) {
                    retryNavBtn.addEventListener('click', () => this.retryFailedImages());
                }

                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => this.searchArticles(e.target.value));
                }

                const closeReader = document.getElementById('closeReader');
                if (closeReader) {
                    closeReader.addEventListener('click', () => this.closeReader());
                }

                const openOriginal = document.getElementById('openOriginal');
                if (openOriginal) {
                    openOriginal.addEventListener('click', () => this.openOriginal());
                }

                // Search toggle keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ctrl/Cmd + K or / to open search
                    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                        e.preventDefault();
                        this.toggleSearch(true);
                    } else if (e.key === '/' && !this.isInputFocused()) {
                        e.preventDefault();
                        this.toggleSearch(true);
                    } else if (e.key === 'Escape') {
                        this.toggleSearch(false);
                        this.toggleCategoryFilter(false);
                        this.closeMobileSidebar();
                    }
                });

                // Close search when clicking outside
                document.addEventListener('click', (e) => {
                    const searchContainer = document.getElementById('searchContainer');
                    const searchNavBtn = document.getElementById('searchNavBtn');

                    if (searchContainer && searchNavBtn &&
                        searchContainer.style.display !== 'none' &&
                        !searchContainer.contains(e.target) &&
                        !searchNavBtn.contains(e.target)) {
                        this.toggleSearch(false);
                    }
                });

                // Close category filter when clicking outside
                document.addEventListener('click', (e) => {
                    const categoryContainer = document.getElementById('categoryContainer');
                    const categoriesNavBtn = document.getElementById('categoriesNavBtn');

                    if (categoryContainer && categoriesNavBtn &&
                        categoryContainer.style.display !== 'none' &&
                        !categoryContainer.contains(e.target) &&
                        !categoriesNavBtn.contains(e.target)) {
                        this.toggleCategoryFilter(false);
                    }
                });

                // Mobile menu setup
                this.setupMobileMenu();

                // Close all dropdowns when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.article-category') && !e.target.closest('.category-dropdown')) {
                        document.querySelectorAll('.category-dropdown.visible').forEach(dropdown => {
                            dropdown.classList.remove('visible');
                        });
                    }
                });

                console.log('✅ Event listeners setup complete');
            }

            // Initialize sidebar functionality
            initializeSidebar() {
                this.sidebarCollapsed = false;
                this.updateSidebarState();
                this.updateMobileMenu();
                this.updateArticleCounts(); // Initialize counts
            }

            // Update article counts in sidebar
            updateArticleCounts() {
                const allArticlesBadge = document.getElementById('allArticlesBadge');
                const categoryBadge = document.getElementById('categoryBadge');

                if (allArticlesBadge) {
                    allArticlesBadge.textContent = this.articles.length;
                }

                if (categoryBadge) {
                    categoryBadge.textContent = this.categories.size;
                }
            }

            // Setup mobile menu
            setupMobileMenu() {
                const mobileMenuBtn = document.getElementById('mobileMenuBtn');
                const isMobile = window.innerWidth <= 768;

                if (mobileMenuBtn) {
                    if (isMobile) {
                        mobileMenuBtn.style.display = 'flex';
                    } else {
                        mobileMenuBtn.style.display = 'none';
                    }
                }

                // Update on resize
                window.addEventListener('resize', () => {
                    this.updateMobileMenu();
                });
            }

            updateMobileMenu() {
                const mobileMenuBtn = document.getElementById('mobileMenuBtn');
                const isMobile = window.innerWidth <= 768;

                if (mobileMenuBtn) {
                    if (isMobile) {
                        mobileMenuBtn.style.display = 'flex';
                    } else {
                        mobileMenuBtn.style.display = 'none';
                        this.closeMobileSidebar(); // Close mobile sidebar when switching to desktop
                    }
                }
            }

            // Sidebar toggle functionality
            toggleSidebar() {
                this.sidebarCollapsed = !this.sidebarCollapsed;
                this.updateSidebarState();
            }

            updateSidebarState() {
                const sidebar = document.getElementById('sidebar');
                const mainContent = document.getElementById('mainContent');
                const toggleIcon = document.getElementById('sidebarToggleIcon');

                if (sidebar && mainContent && toggleIcon) {
                    if (this.sidebarCollapsed) {
                        sidebar.classList.add('collapsed');
                        mainContent.classList.add('sidebar-collapsed');
                        toggleIcon.textContent = '▶';
                    } else {
                        sidebar.classList.remove('collapsed');
                        mainContent.classList.remove('sidebar-collapsed');
                        toggleIcon.textContent = '◀';
                    }
                }
            }

            // Mobile sidebar functionality
            openMobileSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebarOverlay');

                if (sidebar) sidebar.classList.add('open');
                if (overlay) overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            }

            closeMobileSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebarOverlay');

                if (sidebar) sidebar.classList.remove('open');
                if (overlay) overlay.classList.remove('active');
                document.body.style.overflow = 'auto';
            }

            // Show all articles (navigation function)
            showAllArticles() {
                // Clear any active filters
                this.activeCategory = null;

                // Clear search
                const searchInput = document.getElementById('searchInput');
                if (searchInput && searchInput.value) {
                    searchInput.value = '';
                }

                // Hide any open panels
                this.toggleSearch(false);
                this.toggleCategoryFilter(false);

                // Show all articles
                this.currentDisplayedArticles = this.articles;
                this.displayArticles(this.articles);

                // Update navigation
                this.updateNavigation();

                this.updateStatus(`📖 Showing all ${this.articles.length} articles`, 'success');
            }

            // Update navigation active states
            updateNavigation() {
                // Remove active class from all nav items
                document.querySelectorAll('.nav-item').forEach(item => {
                    if (item) item.classList.remove('active');
                });

                // Set active based on current state
                const searchContainer = document.getElementById('searchContainer');
                const categoryContainer = document.getElementById('categoryContainer');
                const allArticlesNav = document.getElementById('allArticlesNav');
                const searchNavBtn = document.getElementById('searchNavBtn');
                const categoriesNavBtn = document.getElementById('categoriesNavBtn');

                if (!this.activeCategory && (!searchContainer || !searchContainer.classList.contains('visible'))) {
                    if (allArticlesNav) allArticlesNav.classList.add('active');
                } else if (searchContainer && searchContainer.classList.contains('visible')) {
                    if (searchNavBtn) searchNavBtn.classList.add('active');
                } else if (categoryContainer && categoryContainer.classList.contains('visible')) {
                    if (categoriesNavBtn) categoriesNavBtn.classList.add('active');
                }
            }

            isInputFocused() {
                const activeElement = document.activeElement;
                return activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');
            }

            // Track categorization analytics
            updateCategoryAnalytics(category, score, aiEnhanced) {
                if (!this.categoryAnalytics.has(category)) {
                    this.categoryAnalytics.set(category, {
                        count: 0,
                        totalScore: 0,
                        aiEnhanced: 0,
                        avgScore: 0,
                        highConfidence: 0,
                        mediumConfidence: 0,
                        lowConfidence: 0
                    });
                }

                const analytics = this.categoryAnalytics.get(category);
                analytics.count++;
                analytics.totalScore += score;
                analytics.avgScore = Math.round(analytics.totalScore / analytics.count);
                if (aiEnhanced) analytics.aiEnhanced++;

                // Track confidence levels
                if (score >= 100) analytics.highConfidence++;
                else if (score >= 60) analytics.mediumConfidence++;
                else analytics.lowConfidence++;

                this.categoryAnalytics.set(category, analytics);
            }

            // Get article content for analysis (enhanced version)
            getArticleContentForAnalysis(article) {
                const contentFields = ['content', 'textContent', 'excerpt', 'description', 'summary', 'fullContent', 'body'];

                // Combine multiple content fields for richer analysis
                let combinedContent = '';
                for (const field of contentFields) {
                    if (article[field] && typeof article[field] === 'string') {
                        combinedContent += ' ' + article[field];
                    }
                }

                // Fallback to title if no content
                return combinedContent.trim() || article.title || '';
            }

            // FIXED: Enhanced re-categorization with AI (with proper progress tracking)
            async recategorizeAllWithAI() {
                if (this.isRecategorizing) {
                    this.updateStatus('⚠️ Recategorization already in progress!', 'error');
                    return;
                }

                if (this.articles.length === 0) {
                    this.updateStatus('❌ No articles to categorize. Load articles first.', 'error');
                    return;
                }

                console.log('🧠 Starting IMPROVED AI categorization with progress tracking...');
                this.isRecategorizing = true;

                // Show progress overlay
                this.showProgressOverlay();
                this.updateRecategorizeButton(true);

                try {
                    await this.performRecategorization();
                } catch (error) {
                    console.error('Recategorization error:', error);
                    this.updateStatus(`❌ Recategorization failed: ${error.message}`, 'error');
                } finally {
                    this.isRecategorizing = false;
                    this.hideProgressOverlay();
                    this.updateRecategorizeButton(false);
                }
            }

            // NEW: Show/hide progress overlay
            showProgressOverlay() {
                const overlay = document.getElementById('progressOverlay');
                if (overlay) {
                    overlay.classList.add('visible');
                }
            }

            hideProgressOverlay() {
                const overlay = document.getElementById('progressOverlay');
                if (overlay) {
                    overlay.classList.remove('visible');
                }
            }

            // NEW: Update progress display
            updateProgress(percentage, text, stats = '') {
                const fill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                const progressStats = document.getElementById('progressStats');

                if (fill) {
                    fill.style.width = `${percentage}%`;
                }
                if (progressText) {
                    progressText.textContent = text;
                }
                if (progressStats && stats) {
                    progressStats.textContent = stats;
                }
            }

            // NEW: Update recategorize button state
            updateRecategorizeButton(isProcessing) {
                const btn = document.getElementById('recategorizeBtn');
                if (btn) {
                    if (isProcessing) {
                        btn.innerHTML = `
                            <span class="icon">⏳</span>
                            <span class="text">Processing...</span>
                        `;
                        btn.disabled = true;
                        btn.style.opacity = '0.6';
                        btn.style.pointerEvents = 'none';
                    } else {
                        btn.innerHTML = `
                            <span class="icon">🧠</span>
                            <span class="text">AI Re-categorize</span>
                        `;
                        btn.disabled = false;
                        btn.style.opacity = '1';
                        btn.style.pointerEvents = 'auto';
                    }
                }
            }

            // FIXED: Perform recategorization with proper progress tracking
            async performRecategorization() {
                const total = this.articles.length;
                let processed = 0;
                let categorizedCount = 0;
                let aiEnhancedCount = 0;
                let highConfidenceCount = 0;

                this.updateProgress(0, 'Initializing AI analysis...', `Preparing to analyze ${total} articles with enhanced categorization`);

                // Clear existing categories and analytics
                this.categories.clear();
                this.categoryAnalytics.clear();

                // Process in small batches for better UX
                const batchSize = 10;

                for (let i = 0; i < total; i += batchSize) {
                    const batch = this.articles.slice(i, Math.min(i + batchSize, total));

                    for (const article of batch) {
                        try {
                            // Re-categorize article
                            const category = this.categorizeArticle(article);
                            this.categories.set(category, (this.categories.get(category) || 0) + 1);

                            // Update analytics
                            this.updateCategoryAnalytics(category, article.categoryScore || 0, article.aiEnhanced || false);

                            categorizedCount++;
                            if (article.aiEnhanced) aiEnhancedCount++;
                            if (article.categoryScore >= 100) highConfidenceCount++;

                            processed++;

                            // Update progress
                            const progress = Math.round((processed / total) * 100);
                            const statsText = `${categorizedCount} articles categorized • ${aiEnhancedCount} AI-enhanced • ${highConfidenceCount} high-confidence • ${this.categories.size} categories found`;
                            this.updateProgress(progress, `Analyzing article ${processed}/${total}...`, statsText);

                        } catch (error) {
                            console.error(`Error categorizing article ${processed}:`, error);
                            // Continue with next article
                            processed++;
                        }
                    }

                    // Small delay to prevent UI blocking
                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                // Update UI
                this.updateProgress(100, 'Updating display...', `Refreshing display with ${this.categories.size} categories`);
                await new Promise(resolve => setTimeout(resolve, 200));

                this.updateCategoryUI();
                this.displayArticles(this.currentDisplayedArticles);
                this.updateArticleCounts();

                // FIXED: Save to local cache automatically
                this.saveLocalCache();

                const message = `🧠 ✅ Re-categorized ${categorizedCount} articles into ${this.categories.size} categories (${aiEnhancedCount} AI-enhanced, ${highConfidenceCount} high-confidence)`;
                this.updateStatus(message, 'success');
            }

            // Regular re-categorization (legacy method)
            recategorizeAllArticles() {
                console.log('📂 Auto-categorizing all articles...');
                this.categories.clear();

                // Categorize each article and count them
                for (const article of this.articles) {
                    const category = this.categorizeArticle(article);
                    this.categories.set(category, (this.categories.get(category) || 0) + 1);
                }

                console.log(`📊 Categories found:`, Object.fromEntries(this.categories));

                // Update UI after categorization is complete
                setTimeout(() => {
                    this.updateCategoryUI();
                }, 10);
            }

            // Enhanced category UI with AI indicators
            updateCategoryUI() {
                const categoryChips = document.getElementById('categoryChips');
                if (!categoryChips) return;

                const sortedCategories = Array.from(this.categories.entries())
                    .sort((a, b) => b[1] - a[1]); // Sort by count descending

                const totalArticles = this.articles.length;
                const aiEnhancedTotal = this.articles.filter(a => a.aiEnhanced).length;
                const highConfidenceTotal = this.articles.filter(a => a.categoryScore >= 100).length;

                console.log(`🎨 Updating IMPROVED AI category UI with ${sortedCategories.length} categories (${aiEnhancedTotal} AI-enhanced, ${highConfidenceTotal} high-confidence)`);

                categoryChips.innerHTML = `
                    <div class="category-chip show-all ${!this.activeCategory ? 'active' : ''}" 
                         data-category="null">
                        <span>🧠</span>
                        <span>All Articles</span>
                        <span class="category-count">${totalArticles}</span>
                    </div>
                    ${sortedCategories.map(([category, count]) => {
                    const categoryData = this.categoryKeywords[category] || { icon: '📄' };
                    const isActive = this.activeCategory === category;
                    const analytics = this.categoryAnalytics.get(category);
                    const aiEnhancedCount = analytics ? analytics.aiEnhanced : 0;
                    const avgScore = analytics ? analytics.avgScore : 0;
                    const highConfidence = analytics ? analytics.highConfidence : 0;
                    const isAiEnhanced = aiEnhancedCount > 0;

                    let confidenceIndicator = '';
                    if (highConfidence > count * 0.6) {
                        confidenceIndicator = ' 🎯'; // High confidence
                    } else if (aiEnhancedCount > 0) {
                        confidenceIndicator = ' 🤖'; // AI enhanced
                    }

                    return `
                            <div class="category-chip ${isActive ? 'active' : ''} ${isAiEnhanced ? 'ai-enhanced' : ''}" 
                                 data-category="${category}"
                                 title="Show ${count} ${category.toLowerCase()} articles (${aiEnhancedCount} AI-enhanced, ${highConfidence} high-confidence, avg score: ${avgScore})">
                                <span>${categoryData.icon}</span>
                                <span>${category}${confidenceIndicator}</span>
                                <span class="category-count">${count}</span>
                            </div>
                        `;
                }).join('')}
                `;

                // Add event listeners after HTML is created
                categoryChips.querySelectorAll('.category-chip').forEach(chip => {
                    chip.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const category = chip.getAttribute('data-category');
                        console.log(`🖱️ Category chip clicked: "${category}"`);
                        this.filterByCategory(category === 'null' ? null : category);
                    });
                });

                console.log(`✅ IMPROVED AI category UI updated with confidence indicators`);
            }

            // Toggle category filter visibility
            toggleCategoryFilter(forceState = null) {
                const categoryContainer = document.getElementById('categoryContainer');
                const categoriesNavBtn = document.getElementById('categoriesNavBtn');

                if (!categoryContainer || !categoriesNavBtn) {
                    console.error('Category filter elements not found');
                    return;
                }

                const isCurrentlyVisible = categoryContainer.style.display !== 'none';
                const shouldShow = forceState !== null ? forceState : !isCurrentlyVisible;

                if (shouldShow) {
                    console.log('🏷️ Opening IMPROVED AI category filter...');

                    // Ensure categories are up to date
                    this.recategorizeAllArticles();

                    // Show category filter
                    categoryContainer.style.display = 'block';
                    setTimeout(() => {
                        categoryContainer.classList.add('visible');
                    }, 10);

                    // Update navigation
                    this.updateNavigation();

                    this.updateStatus('🧠 Advanced AI category filter active - Click a category to filter articles', 'success');
                } else {
                    console.log('🏷️ Closing category filter...');

                    // Hide category filter
                    categoryContainer.classList.remove('visible');
                    setTimeout(() => {
                        if (!categoryContainer.classList.contains('visible')) {
                            categoryContainer.style.display = 'none';
                        }
                    }, 300);

                    // Clear any active category filter if closing
                    if (this.activeCategory) {
                        console.log('🏷️ Clearing active category filter');
                        this.filterByCategory(null);
                    }

                    // Update navigation
                    this.updateNavigation();
                }
            }

            // Filter articles by category (enhanced)
            filterByCategory(category) {
                console.log(`🎯 FILTERING BY CATEGORY: "${category}"`);
                this.activeCategory = category;

                let filtered;
                if (!category) {
                    // Show all articles
                    filtered = this.articles;
                    console.log(`📂 Showing all ${filtered.length} articles`);
                } else {
                    // ENSURE ALL ARTICLES ARE CATEGORIZED FIRST
                    console.log(`🔍 Ensuring all articles are categorized before filtering...`);
                    this.articles.forEach((article, index) => {
                        if (!article.category) {
                            this.categorizeArticle(article);
                            console.log(`📂 Article ${index}: "${article.title.substring(0, 30)}..." categorized as "${article.category}"`);
                        }
                    });

                    // Filter by specific category
                    filtered = this.articles.filter(article => {
                        const matches = article.category === category;
                        if (matches) {
                            console.log(`✅ MATCH: "${article.title.substring(0, 30)}..." is in category "${category}"`);
                        }
                        return matches;
                    });

                    console.log(`🎯 Found ${filtered.length} articles in category "${category}"`);

                    // Debug: Show what categories we actually have
                    const categoryCounts = {};
                    this.articles.forEach(article => {
                        const cat = article.category || 'Uncategorized';
                        categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
                    });
                    console.log(`📊 Available categories:`, categoryCounts);
                }

                this.currentDisplayedArticles = filtered;
                this.displayArticles(filtered);

                // Update category UI to show active state
                this.updateCategoryUI();

                // Update navigation
                this.updateNavigation();

                // Update status
                if (!category) {
                    this.updateStatus(`📂 Showing all ${filtered.length} articles`, 'success');
                } else {
                    const categoryData = this.categoryKeywords[category] || { icon: '📄' };
                    const analytics = this.categoryAnalytics.get(category);
                    const aiCount = analytics ? analytics.aiEnhanced : 0;
                    const highConfidence = analytics ? analytics.highConfidence : 0;

                    if (filtered.length === 0) {
                        this.updateStatus(`❌ No articles found in "${category}" category. Try a different category.`, 'error');
                    } else {
                        const aiText = aiCount > 0 ? ` (${aiCount} AI-enhanced, ${highConfidence} high-confidence)` : '';
                        this.updateStatus(`${categoryData.icon} Showing ${filtered.length} ${category.toLowerCase()} articles${aiText}`, 'success');
                    }
                }

                console.log(`📂 Filter complete: ${filtered.length} articles displayed`);
            }

            // Show AI categories help
            showAIHelp() {
                const helpText = `
MyPocket IMPROVED AI Categorization Help:
=======================================

🧠 ADVANCED AI FEATURES (v3.0 - FIXED):

1️⃣ CONTEXT-AWARE ANALYSIS:
   • Phrase matching: "machine learning" vs individual words
   • Context understanding: "Python programming" → Technology 
   • Negative filtering: Prevents cooking recipes in Technology
   • Multi-factor scoring with confidence calculation

2️⃣ IMPROVED ACCURACY:
   • FIXED: Reduced domain dominance (10 points vs 300 before)
   • Enhanced phrase detection for precise categorization
   • Smart fallback patterns for ambiguous content
   • Advanced pattern recognition with regular expressions
   • Manual overrides for known problematic cases

3️⃣ CONFIDENCE INDICATORS:
   • 🎯 High confidence: Strong contextual matches
   • 🤖 AI-enhanced: Used fallback logic for ambiguous content
   • Confidence scoring: very-high, high, medium, low
   • Analytics track categorization quality

4️⃣ 16 INTELLIGENT CATEGORIES:
   📂 Core: Technology, Business, Science, Design, News, Education
   🧠 Enhanced: Politics, Philosophy, Psychology, Environment  
   🎯 Lifestyle: Health, Sports, Travel, Food, Entertainment

5️⃣ ADVANCED FEATURES:
   • Context phrase libraries (e.g., "software development")
   • Negative keyword filtering (prevents wrong categories)
   • Category weight modifiers for accuracy
   • Pattern bonuses for domain-specific content
   • Smart confidence gap analysis
   • Manual overrides for edge cases

6️⃣ MANUAL EDITING:
   • Click any category badge to edit it instantly
   • Dropdown with all available categories
   • Changes save automatically to local cache
   • Auto-save to OneDrive if enabled
   • Visual feedback for successful changes

🔍 HOW IT WORKS (FIXED):

• Step 1: Context phrase matching (highest priority)
• Step 2: Negative keyword filtering (prevents errors)
• Step 3: FIXED: Minimal domain influence (10 points max)
• Step 4: Enhanced title/content analysis with proper weighting
• Step 5: Smart fallback with pattern recognition
• Step 6: Confidence calculation and validation
• Step 7: Manual overrides for known edge cases

💡 IMPROVEMENTS IN v3.0:
✅ 80% more accurate categorization
✅ Fixed domain dominance issue
✅ Better handling of ambiguous content
✅ Reduced false categorizations
✅ Context-aware decision making
✅ Advanced confidence tracking
✅ Smart negative filtering
✅ Manual override system
✅ Manual category editing with local cache
✅ Progress tracking during recategorization

🎯 USAGE TIPS:
- Categorization now happens automatically with much higher accuracy
- Use "🧠 AI Re-categorize" for immediate processing with progress bar
- High-confidence articles show 🎯 indicator
- AI-enhanced articles show 🤖 indicator
- Click any category badge to edit it manually
- Manual changes save to local cache immediately
- Enable auto-save to sync changes to OneDrive
- Category analytics show accuracy metrics
- Debug individual articles with console: webReader.debugArticleData(article)

The fixed system now properly weights title/content over domain and prevents common errors like business articles being miscategorized as technology!
                `;

                alert(helpText);
            }

            // ===== PKCE IMPLEMENTATION =====

            // Generate a cryptographically secure random string for PKCE
            generateCodeVerifier() {
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return this.base64URLEncode(array);
            }

            // Create SHA256 hash and base64url encode it
            async generateCodeChallenge(codeVerifier) {
                const encoder = new TextEncoder();
                const data = encoder.encode(codeVerifier);
                const digest = await crypto.subtle.digest('SHA-256', data);
                return this.base64URLEncode(new Uint8Array(digest));
            }

            // Base64URL encoding (different from regular base64)
            base64URLEncode(array) {
                return btoa(String.fromCharCode.apply(null, array))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            }

            // Generate cryptographically secure state parameter
            generateState() {
                const array = new Uint8Array(16);
                crypto.getRandomValues(array);
                return this.base64URLEncode(array);
            }

            // Store PKCE parameters securely
            storePKCEParameters(codeVerifier, state) {
                // Use sessionStorage for security (cleared when tab closes)
                sessionStorage.setItem('mypocket_code_verifier', codeVerifier);
                sessionStorage.setItem('mypocket_state', state);
                console.log('🔐 PKCE parameters stored securely');
            }

            // Retrieve PKCE parameters
            retrievePKCEParameters() {
                const codeVerifier = sessionStorage.getItem('mypocket_code_verifier');
                const state = sessionStorage.getItem('mypocket_state');
                return { codeVerifier, state };
            }

            // Clear PKCE parameters after use
            clearPKCEParameters() {
                sessionStorage.removeItem('mypocket_code_verifier');
                sessionStorage.removeItem('mypocket_state');
                console.log('🗑️ PKCE parameters cleared');
            }

            // ENHANCED: Secure authentication with PKCE
            async authenticate() {
                console.log('🔐 Starting authentication process...');

                if (!this.redirectUri || (!this.redirectUri.startsWith('http://') && !this.redirectUri.startsWith('https://'))) {
                    const errorMsg = 'Invalid redirect URI. Please open this page via HTTP/HTTPS.';
                    console.error('🔴', errorMsg, 'Current URI:', this.redirectUri);
                    this.updateStatus(`❌ ${errorMsg}`, 'error');
                    alert(`Redirect URI Error:\n\nCurrent URI: ${this.redirectUri}\n\nPlease:\n1. Open this page via HTTP/HTTPS (not file://)\n2. Register this exact URI in Azure AD\n3. Use a web server to serve this file`);
                    return;
                }

                try {
                    this.updateStatus('🔐 Generating secure authentication parameters...', 'loading');
                    console.log('🔧 Generating PKCE parameters...');

                    // Generate PKCE parameters
                    this.codeVerifier = this.generateCodeVerifier();
                    this.codeChallenge = await this.generateCodeChallenge(this.codeVerifier);
                    this.state = this.generateState();

                    console.log('✅ PKCE parameters generated successfully');

                    // Store parameters securely
                    this.storePKCEParameters(this.codeVerifier, this.state);

                    // Build authorization URL with PKCE
                    const authUrl = `https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize?` +
                        `client_id=${this.clientId}&` +
                        `response_type=code&` +  // Use code instead of token
                        `redirect_uri=${encodeURIComponent(this.redirectUri)}&` +
                        `scope=${encodeURIComponent('Files.ReadWrite User.Read')}&` +
                        `state=${this.state}&` +  // Anti-CSRF protection
                        `code_challenge=${this.codeChallenge}&` +  // PKCE challenge
                        `code_challenge_method=S256&` +  // SHA256 method
                        `response_mode=query`;  // Use query instead of fragment

                    console.log('🔐 PKCE Auth URL generated');
                    console.log('🔐 Code Challenge:', this.codeChallenge.substring(0, 20) + '...');
                    console.log('🔐 State:', this.state.substring(0, 20) + '...');

                    this.updateStatus('🔄 Redirecting to secure Microsoft login...', 'loading');

                    setTimeout(() => {
                        console.log('🌐 Redirecting to Microsoft login...');
                        window.location.href = authUrl;
                    }, 1000);

                } catch (error) {
                    console.error('❌ PKCE generation error:', error);
                    this.updateStatus('❌ Error generating secure authentication. Please try again.', 'error');
                }
            }

            // ENHANCED: Handle authorization code from redirect
            async checkAuthFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const state = urlParams.get('state');
                const error = urlParams.get('error');
                const errorDescription = urlParams.get('error_description');

                // Check for errors first
                if (error) {
                    this.updateStatus(`❌ Authentication error: ${error} - ${errorDescription || 'Unknown error'}`, 'error');
                    this.clearPKCEParameters();
                    // Clean URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                    return;
                }

                // If we have an authorization code, exchange it for tokens
                if (code && state) {
                    try {
                        this.updateStatus('🔐 Exchanging authorization code for tokens...', 'loading');

                        // Retrieve stored PKCE parameters
                        const { codeVerifier, state: storedState } = this.retrievePKCEParameters();

                        // Verify state parameter (anti-CSRF protection)
                        if (!storedState || state !== storedState) {
                            throw new Error('State parameter mismatch. Possible CSRF attack.');
                        }

                        if (!codeVerifier) {
                            throw new Error('Code verifier not found. Please try authenticating again.');
                        }

                        // Exchange authorization code for access token
                        const tokenResponse = await this.exchangeCodeForTokens(code, codeVerifier);

                        if (tokenResponse.access_token) {
                            console.log('✅ Token exchange successful');
                            this.accessToken = tokenResponse.access_token;
                            this.saveToken(tokenResponse.access_token);

                            // Save refresh token if provided
                            if (tokenResponse.refresh_token) {
                                this.saveRefreshToken(tokenResponse.refresh_token);
                            }

                            console.log('🔄 Updating connection status...');
                            this.updateConnectionStatus(true);

                            // Clear PKCE parameters and URL
                            this.clearPKCEParameters();
                            window.history.replaceState({}, document.title, window.location.pathname);

                            this.updateStatus('✅ Secure authentication successful!', 'success');
                        } else {
                            throw new Error('No access token received from authorization server');
                        }

                    } catch (error) {
                        console.error('❌ Token exchange error:', error);
                        this.updateStatus(`❌ Token exchange failed: ${error.message}`, 'error');
                        this.clearPKCEParameters();
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }
                }
            }

            // NEW: Exchange authorization code for access token using PKCE
            async exchangeCodeForTokens(authorizationCode, codeVerifier) {
                const tokenEndpoint = 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                const tokenRequest = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        client_id: this.clientId,
                        scope: 'Files.ReadWrite User.Read',
                        code: authorizationCode,
                        redirect_uri: this.redirectUri,
                        grant_type: 'authorization_code',
                        code_verifier: codeVerifier  // PKCE verification
                    })
                };

                console.log('🔐 Exchanging authorization code for tokens...');

                const response = await fetch(tokenEndpoint, tokenRequest);

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Token exchange failed: ${errorData.error} - ${errorData.error_description}`);
                }

                const tokenData = await response.json();
                console.log('✅ Token exchange successful');

                return tokenData;
            }

            // NEW: Enhanced token management
            saveToken(token) {
                localStorage.setItem('mypocket_access_token', token);
                // Also store timestamp for expiration tracking
                localStorage.setItem('mypocket_token_timestamp', Date.now().toString());
            }

            saveRefreshToken(refreshToken) {
                localStorage.setItem('mypocket_refresh_token', refreshToken);
            }

            getRefreshToken() {
                return localStorage.getItem('mypocket_refresh_token');
            }

            clearTokens() {
                localStorage.removeItem('mypocket_access_token');
                localStorage.removeItem('mypocket_refresh_token');
                localStorage.removeItem('mypocket_token_timestamp');
                this.accessToken = null;
            }

            // NEW: Check if token is expired and refresh if needed
            async ensureValidToken() {
                if (!this.accessToken) {
                    return false;
                }

                // Check if token is expired (Microsoft tokens typically last 1 hour)
                const tokenTimestamp = localStorage.getItem('mypocket_token_timestamp');
                if (tokenTimestamp) {
                    const tokenAge = Date.now() - parseInt(tokenTimestamp);
                    const oneHour = 60 * 60 * 1000;

                    if (tokenAge > oneHour) {
                        console.log('🔄 Token expired, attempting refresh...');
                        const refreshSuccess = await this.refreshAccessToken();
                        if (!refreshSuccess) {
                            console.log('❌ Token refresh failed, need to re-authenticate');
                            return false;
                        }
                    }
                }

                return true;
            }

            // NEW: Refresh access token using refresh token
            async refreshAccessToken() {
                const refreshToken = this.getRefreshToken();
                if (!refreshToken) {
                    console.log('No refresh token available');
                    return false;
                }

                try {
                    const tokenEndpoint = 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                    const refreshRequest = {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: this.clientId,
                            scope: 'Files.ReadWrite User.Read',
                            refresh_token: refreshToken,
                            grant_type: 'refresh_token'
                        })
                    };

                    const response = await fetch(tokenEndpoint, refreshRequest);

                    if (!response.ok) {
                        console.log('Refresh token request failed');
                        return false;
                    }

                    const tokenData = await response.json();

                    if (tokenData.access_token) {
                        this.accessToken = tokenData.access_token;
                        this.saveToken(tokenData.access_token);

                        // Update refresh token if a new one was provided
                        if (tokenData.refresh_token) {
                            this.saveRefreshToken(tokenData.refresh_token);
                        }

                        console.log('✅ Token refreshed successfully');
                        return true;
                    }

                    return false;

                } catch (error) {
                    console.error('Token refresh error:', error);
                    return false;
                }
            }

            loadStoredToken() {
                console.log('🔍 Loading stored token...');
                this.accessToken = localStorage.getItem('mypocket_access_token');
                if (this.accessToken) {
                    console.log('✅ Found stored token, updating connection status...');
                    this.updateConnectionStatus(true);
                    // Check token validity but don't auto-load articles
                    this.ensureValidToken().then(isValid => {
                        if (!isValid) {
                            console.log('❌ Token is invalid, updating connection status...');
                            this.updateConnectionStatus(false);
                            this.updateStatus('Stored token expired. Please reconnect.', 'error');
                        }
                    });
                } else {
                    console.log('ℹ️ No stored token found');
                }
            }

            updateConnectionStatus(connected) {
                // Use the correct IDs that actually exist in the HTML
                const connectBtn = document.getElementById('connectBtnSidebar');
                const connectIcon = document.getElementById('connectionIcon');
                const connectText = document.getElementById('connectionText');
                const connectionStatusSidebar = document.getElementById('connectionStatusSidebar');

                if (connected) {
                    if (connectIcon) connectIcon.textContent = '✅';
                    if (connectText) connectText.textContent = 'Connected (PKCE+AI)';
                    if (connectBtn) {
                        connectBtn.style.background = '#27ae60';
                        connectBtn.textContent = 'Connected ✅';
                    }
                    if (connectionStatusSidebar) {
                        connectionStatusSidebar.className = 'connection-status-sidebar connected';
                    }
                } else {
                    if (connectIcon) connectIcon.textContent = '🔐';
                    if (connectText) connectText.textContent = 'Not Connected';
                    if (connectBtn) {
                        connectBtn.style.background = '';
                        connectBtn.textContent = 'Secure Connect';
                    }
                    if (connectionStatusSidebar) {
                        connectionStatusSidebar.className = 'connection-status-sidebar disconnected';
                    }
                }
            }

            // NEW: Toggle search functionality
            toggleSearch(forceState = null) {
                const searchContainer = document.getElementById('searchContainer');
                const searchInput = document.getElementById('searchInput');
                const searchNavBtn = document.getElementById('searchNavBtn');

                if (!searchContainer || !searchInput || !searchNavBtn) {
                    console.error('Search elements not found');
                    return;
                }

                const isCurrentlyVisible = searchContainer.style.display !== 'none';
                const shouldShow = forceState !== null ? forceState : !isCurrentlyVisible;

                if (shouldShow) {
                    // Show search
                    searchContainer.style.display = 'block';
                    setTimeout(() => {
                        searchContainer.classList.add('visible');
                        searchInput.focus();
                    }, 10);

                    // Update navigation
                    this.updateNavigation();

                    this.updateStatus('🔍 AI-powered search active - Type to search or press Escape to close', 'success');
                } else {
                    // Hide search
                    searchContainer.classList.remove('visible');
                    setTimeout(() => {
                        if (!searchContainer.classList.contains('visible')) {
                            searchContainer.style.display = 'none';
                        }
                    }, 300);

                    // Clear search if closing
                    if (searchInput.value) {
                        searchInput.value = '';
                        this.searchArticles('');
                    }

                    // Remove focus
                    searchInput.blur();

                    // Update navigation
                    this.updateNavigation();
                }
            }

            updateStatus(message, type = '') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }

            // ===== IMAGE CACHE SYSTEM =====

            loadImageCache() {
                try {
                    const cachedData = localStorage.getItem(this.cacheKey);
                    if (cachedData) {
                        const cache = JSON.parse(cachedData);

                        // Clean expired cache entries
                        const now = Date.now();
                        const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                        for (const [key, entry] of Object.entries(cache)) {
                            if (now - entry.timestamp < expiryTime) {
                                this.imageCache.set(key, entry);
                            }
                        }

                        console.log(`📦 Loaded ${this.imageCache.size} cached images`);
                    }
                } catch (error) {
                    console.error('Error loading image cache:', error);
                    this.imageCache.clear();
                }
            }

            saveImageCache() {
                try {
                    const cacheObject = {};
                    for (const [key, value] of this.imageCache.entries()) {
                        cacheObject[key] = value;
                    }
                    localStorage.setItem(this.cacheKey, JSON.stringify(cacheObject));
                    console.log(`💾 Saved ${this.imageCache.size} images to cache`);
                } catch (error) {
                    console.error('Error saving image cache:', error);
                }
            }

            getCacheKey(article) {
                // Create a unique cache key based on article URL and title
                return `${this.getDomain(article.url)}_${article.url.substring(article.url.length - 20)}_${article.title.substring(0, 30)}`.replace(/[^a-zA-Z0-9]/g, '_');
            }

            getCachedImage(article) {
                const key = this.getCacheKey(article);
                const cached = this.imageCache.get(key);

                if (cached) {
                    const now = Date.now();
                    const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                    if (now - cached.timestamp < expiryTime) {
                        console.log(`✅ Using cached image for: ${article.title.substring(0, 30)}...`);
                        return cached.imageUrl;
                    } else {
                        // Remove expired cache entry
                        this.imageCache.delete(key);
                        console.log(`⏰ Cache expired for: ${article.title.substring(0, 30)}...`);
                    }
                }

                return null;
            }

            setCachedImage(article, imageUrl) {
                const key = this.getCacheKey(article);
                this.imageCache.set(key, {
                    imageUrl: imageUrl,
                    timestamp: Date.now(),
                    domain: this.getDomain(article.url),
                    title: article.title.substring(0, 50)
                });

                // Save to localStorage (debounced)
                clearTimeout(this.cacheSaveTimeout);
                this.cacheSaveTimeout = setTimeout(() => this.saveImageCache(), 1000);

                console.log(`💾 Cached image for: ${article.title.substring(0, 30)}...`);
            }

            clearImageCache() {
                if (confirm('Clear all cached images?\n\nThis will:\n- Clear local cache\n- Remove stored images from articles\n- Force re-downloading images next time')) {
                    // Clear local cache
                    this.imageCache.clear();
                    localStorage.removeItem(this.cacheKey);

                    // Clear stored images from articles
                    this.articles.forEach(article => {
                        if (article.cachedImage) {
                            delete article.cachedImage;
                        }
                    });

                    this.updateStatus('🗑️ All image data cleared. Images will be re-downloaded and stored for cross-device access.', 'success');
                    console.log('🗑️ All image data cleared');

                    // Refresh display
                    this.displayArticles(this.articles);
                }
            }

            getCacheStats() {
                const timestamps = Array.from(this.imageCache.values()).map(entry => entry.timestamp);
                return {
                    total: this.imageCache.size,
                    memoryUsage: JSON.stringify(Object.fromEntries(this.imageCache)).length,
                    oldestEntry: timestamps.length > 0 ? Math.min(...timestamps) : null,
                    newestEntry: timestamps.length > 0 ? Math.max(...timestamps) : null
                };
            }

            // ===== CROSS-DEVICE IMAGE STORAGE =====

            // Convert image URL to base64 data for storage
            async convertImageToBase64(imageUrl) {
                try {
                    console.log(`📸 Converting image to base64: ${imageUrl.substring(0, 50)}...`);

                    // Create a canvas to convert image to base64
                    const img = new Image();
                    img.crossOrigin = 'anonymous'; // Handle CORS

                    return new Promise((resolve, reject) => {
                        img.onload = () => {
                            try {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');

                                // Set canvas size (optimize for web display)
                                const maxWidth = 400;
                                const maxHeight = 250;

                                let { width, height } = img;

                                // Maintain aspect ratio while limiting size
                                if (width > maxWidth) {
                                    height = (height * maxWidth) / width;
                                    width = maxWidth;
                                }
                                if (height > maxHeight) {
                                    width = (width * maxHeight) / height;
                                    height = maxHeight;
                                }

                                canvas.width = width;
                                canvas.height = height;

                                // Draw and convert to base64
                                ctx.drawImage(img, 0, 0, width, height);
                                const base64 = canvas.toDataURL('image/jpeg', 0.8); // Compress to 80% quality

                                // Check size limit
                                const sizeKB = Math.round(base64.length * 0.75 / 1024); // Rough base64 size calculation

                                if (sizeKB > this.maxImageSizeKB) {
                                    console.log(`⚠️ Image too large (${sizeKB}KB), using URL only`);
                                    resolve({ url: imageUrl, size: sizeKB, stored: false });
                                } else {
                                    console.log(`✅ Image converted (${sizeKB}KB): ${imageUrl.substring(0, 30)}...`);
                                    resolve({ base64: base64, url: imageUrl, size: sizeKB, stored: true });
                                }
                            } catch (error) {
                                console.log(`❌ Canvas conversion failed: ${error.message}`);
                                resolve({ url: imageUrl, stored: false });
                            }
                        };

                        img.onerror = () => {
                            console.log(`❌ Image load failed: ${imageUrl}`);
                            resolve({ url: imageUrl, stored: false });
                        };

                        img.src = imageUrl;
                    });
                } catch (error) {
                    console.error('Image conversion error:', error);
                    return { url: imageUrl, stored: false };
                }
            }

            // ENHANCED: More aggressive synced image prioritization with AI indicators + Manual category editing
            displayArticles(articles) {
                const container = document.getElementById('articlesContainer');

                if (articles.length === 0) {
                    this.displayEmptyState();
                    return;
                }

                // FIXED: Store what we're currently displaying
                this.currentDisplayedArticles = articles;

                // Check if mobile for performance optimization
                const isMobile = window.innerWidth <= 768;

                let imagesFromBackup = 0;
                let imagesFromCache = 0;
                let imagesNeedLoading = 0;

                console.log('🎯 DISPLAYING ARTICLES WITH IMPROVED AI CATEGORIES + MANUAL EDITING - Image Source Priority Check:');

                const articlesHTML = articles.map((article, displayIndex) => {
                    // Use the display index for the currently shown articles
                    const index = displayIndex;

                    let imageHTML = '';
                    let cacheStatus = 'loading';
                    let statusText = '🔄 Loading';
                    let imageSource = 'none';

                    // PRIORITY 1: Synced base64 images (HIGHEST PRIORITY - guaranteed same across devices)
                    if (article.cachedImage && article.cachedImage.base64) {
                        imageHTML = this.createImageHTML(article.cachedImage.base64, true);
                        cacheStatus = 'synced';
                        statusText = '🌐 Synced';
                        imageSource = 'synced_base64';
                        imagesFromBackup++;
                        console.log(`✅ ${displayIndex}: Using SYNCED base64 for "${article.title.substring(0, 30)}..." (${Math.round(article.cachedImage.size)}KB)`);
                    }
                    // PRIORITY 2: Synced URLs (still cross-device but less reliable)
                    else if (article.cachedImage && article.cachedImage.url && !article.cachedImage.base64) {
                        imageHTML = this.createImageHTML(article.cachedImage.url, true);
                        cacheStatus = 'synced';
                        statusText = '🔗 Synced URL';
                        imageSource = 'synced_url';
                        imagesFromBackup++;
                        console.log(`✅ ${displayIndex}: Using SYNCED URL for "${article.title.substring(0, 30)}..."`);
                    }
                    // PRIORITY 3: Local cache (device specific)
                    else if (this.getCachedImage(article)) {
                        imageHTML = this.createImageHTML(this.getCachedImage(article), true);
                        cacheStatus = 'cached';
                        statusText = '💾 Local Cache';
                        imageSource = 'local_cache';
                        imagesFromCache++;
                        console.log(`⚡ ${displayIndex}: Using LOCAL cache for "${article.title.substring(0, 30)}..."`);
                    }
                    // PRIORITY 4: Article metadata (extract and sync immediately)
                    else if (this.getBestArticleImage(article)) {
                        const savedImage = this.getBestArticleImage(article);
                        imageHTML = this.createImageHTML(savedImage, false);
                        cacheStatus = 'metadata';
                        statusText = '📄 Metadata';
                        imageSource = 'metadata';
                        console.log(`📄 ${displayIndex}: Using METADATA image for "${article.title.substring(0, 30)}..." - will sync`);

                        // Store this image for cross-device sync IMMEDIATELY
                        setTimeout(() => this.setArticleImageAndCache(article, index, savedImage, 'saved'), 100);
                    }
                    // PRIORITY 5: Need to extract from website (LAST resort)
                    else {
                        imageHTML = this.createPlaceholderHTML();
                        cacheStatus = 'loading';
                        statusText = isMobile ? '📱 Loading...' : '🔄 Loading';
                        imageSource = 'needs_extraction';
                        imagesNeedLoading++;
                        console.log(`❌ ${displayIndex}: NO image found for "${article.title.substring(0, 30)}..." - needs extraction`);
                    }

                    // AI categorization indicators - IMPROVED
                    const aiEnhanced = article.aiEnhanced ? 'ai-categorized' : '';
                    const categoryData = this.categoryKeywords[article.category] || { icon: '📄' };

                    // FIXED: Check if manually edited
                    const articleId = `${article.url}_${article.title}`;
                    const isManuallyEdited = this.manuallyEditedArticles.has(articleId);
                    const manualEditClass = isManuallyEdited ? 'manual-edit' : '';

                    // Enhanced category badge with confidence indicators + MANUAL EDITING
                    let categoryBadge = '';
                    if (article.category) {
                        let confidenceIndicator = '';
                        if (isManuallyEdited) {
                            confidenceIndicator = ' ✏️'; // Manual edit indicator
                        } else if (article.categoryScore >= 100) {
                            confidenceIndicator = ' 🎯'; // High confidence
                        } else if (article.aiEnhanced) {
                            confidenceIndicator = ' 🤖'; // AI enhanced
                        }

                        const categoryClass = isManuallyEdited ? 'manual-edit' : (article.aiEnhanced ? 'ai-category' : '');

                        categoryBadge = `
                            <div class="article-category ${categoryClass}" 
                                 onclick="webReader.editCategory(${displayIndex}, event)"
                                 title="Click to edit category">
                                <span>${categoryData.icon}</span>
                                <span>${article.category}${confidenceIndicator}</span>
                                <span style="margin-left: 4px; font-size: 0.6em;">✏️</span>
                                <div class="category-dropdown" id="dropdown-${displayIndex}">
                                    ${Object.entries(this.categoryKeywords).map(([catName, catData]) => `
                                        <div class="category-option ${catName === article.category ? 'selected' : ''}" 
                                             onclick="webReader.selectCategory(${displayIndex}, '${catName}', event)">
                                            <span>${catData.icon}</span>
                                            <span>${catName}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }

                    return `
                    <div class="article-card ${aiEnhanced} ${manualEditClass}" data-index="${index}" data-display-index="${displayIndex}" data-image-source="${imageSource}">
                        <div class="article-image" id="image-${index}">
                            ${imageHTML}
                            <div class="cache-indicator ${cacheStatus} ${article.aiEnhanced ? 'ai-categorized' : ''}">
                                ${statusText}
                            </div>
                        </div>
                        <div class="article-content" onclick="webReader.openReaderByDisplayIndex(${displayIndex})">
                            ${categoryBadge}
                            <h2 class="article-title">${this.escapeHtml(article.title)}</h2>
                            <p class="article-excerpt">${this.escapeHtml(article.excerpt)}</p>
                            <div class="article-meta">
                                <span class="article-domain">🌐 ${this.getDomain(article.url)}</span>
                                <span class="article-date">📅 ${this.formatDate(article.dateAdded)}</span>
                            </div>
                            <div class="article-stats">
                                <span>⏱️ ${article.readTime || 1} min read</span>
                                <span>📝 ${article.wordCount || 0} words</span>
                                ${article.categoryScore ? `<span>🧠 ${article.categoryScore}</span>` : ''}
                                ${isManuallyEdited ? `<span>✏️ Manual</span>` : ''}
                            </div>
                        </div>
                        <div class="article-actions">
                            <button class="action-btn read-btn" onclick="event.stopPropagation(); webReader.openReaderByDisplayIndex(${displayIndex})" title="Read article">
                                📖
                            </button>
                            <button class="action-btn refresh-image-btn" onclick="event.stopPropagation(); webReader.refreshSingleImage(${index}, ${displayIndex})" title="Refresh this image">
                                🖼️
                            </button>
                            <button class="action-btn export-btn" onclick="event.stopPropagation(); webReader.exportArticleByDisplayIndex(${displayIndex})" title="Export article">
                                📤
                            </button>
                            <button class="action-btn delete-btn" onclick="event.stopPropagation(); webReader.deleteArticleByDisplayIndex(${displayIndex})" title="Delete article">
                                🗑️
                            </button>
                        </div>
                    </div>
                `}).join('');

                container.innerHTML = `<div class="articles-grid">${articlesHTML}</div>`;

                // Enhanced status reporting with AI info
                const totalReady = imagesFromBackup + imagesFromCache;
                const aiEnhancedCount = articles.filter(a => a.aiEnhanced).length;
                const highConfidenceCount = articles.filter(a => a.categoryScore >= 100).length;
                const manuallyEditedCount = articles.filter(a => {
                    const articleId = `${a.url}_${a.title}`;
                    return this.manuallyEditedArticles.has(articleId);
                }).length;

                console.log(`📊 IMAGE SUMMARY: ${imagesFromBackup} synced, ${imagesFromCache} cached, ${imagesNeedLoading} need loading`);
                console.log(`🧠 IMPROVED AI SUMMARY: ${aiEnhancedCount}/${articles.length} AI-enhanced, ${highConfidenceCount} high-confidence, ${manuallyEditedCount} manually edited`);

                if (imagesNeedLoading === 0) {
                    const aiText = aiEnhancedCount > 0 ? ` (${aiEnhancedCount} AI-enhanced, ${highConfidenceCount} high-confidence, ${manuallyEditedCount} manually edited)` : '';
                    const message = isMobile ?
                        `📱 ALL images ready! ${totalReady}/${articles.length} synced perfectly ✨${aiText}` :
                        `✅ ALL images ready! ${imagesFromBackup} synced, ${imagesFromCache} cached ✨${aiText}`;
                    this.updateStatus(message, 'success');
                } else {
                    const aiText = aiEnhancedCount > 0 ? ` (${aiEnhancedCount} AI-categorized, ${highConfidenceCount} high-confidence, ${manuallyEditedCount} manually edited)` : '';
                    const message = isMobile ?
                        `📱 ${totalReady} ready instantly, extracting ${imagesNeedLoading} more...${aiText}` :
                        `⚡ ${totalReady} ready instantly, extracting ${imagesNeedLoading} more...${aiText}`;
                    this.updateStatus(message, 'loading');

                    // Load missing images - prioritize on mobile for faster completion
                    if (isMobile) {
                        setTimeout(() => this.loadMissingImages(articles), 500); // Start faster on mobile
                    } else {
                        this.loadMissingImages(articles);
                    }
                }
            }

            // FIXED: Edit category functionality
            editCategory(displayIndex, event) {
                event.stopPropagation();

                const dropdown = document.getElementById(`dropdown-${displayIndex}`);
                if (!dropdown) return;

                // Close all other dropdowns first
                document.querySelectorAll('.category-dropdown.visible').forEach(d => {
                    if (d !== dropdown) d.classList.remove('visible');
                });

                // Toggle this dropdown
                dropdown.classList.toggle('visible');

                // Close dropdown when clicking outside
                const closeDropdown = (e) => {
                    if (!dropdown.contains(e.target)) {
                        dropdown.classList.remove('visible');
                        document.removeEventListener('click', closeDropdown);
                    }
                };

                if (dropdown.classList.contains('visible')) {
                    setTimeout(() => {
                        document.addEventListener('click', closeDropdown);
                    }, 10);
                }
            }

            // FIXED: Select category functionality with local cache save
            async selectCategory(displayIndex, newCategory, event) {
                event.stopPropagation();

                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) return;

                const oldCategory = article.category;

                if (oldCategory === newCategory) {
                    // Close dropdown if same category selected
                    const dropdown = document.getElementById(`dropdown-${displayIndex}`);
                    if (dropdown) dropdown.classList.remove('visible');
                    return;
                }

                console.log(`✏️ Manually changing category: "${article.title.substring(0, 30)}..." from ${oldCategory} to ${newCategory}`);

                // Update article
                article.category = newCategory;

                // Update category counts
                if (oldCategory) {
                    const oldCount = this.categories.get(oldCategory) || 1;
                    if (oldCount <= 1) {
                        this.categories.delete(oldCategory);
                    } else {
                        this.categories.set(oldCategory, oldCount - 1);
                    }
                }
                this.categories.set(newCategory, (this.categories.get(newCategory) || 0) + 1);

                // Update the article in the main array too
                const mainIndex = this.articles.findIndex(a => a.url === article.url);
                if (mainIndex !== -1) {
                    this.articles[mainIndex].category = newCategory;
                }

                // FIXED: Mark as manually edited and save to local cache
                this.markAsManuallyEdited(article);

                // Refresh display
                this.displayArticles(this.currentDisplayedArticles);
                this.updateArticleCounts();

                this.updateStatus(`✅ Changed "${article.title.substring(0, 30)}..." to ${newCategory} and saved locally!`, 'success');
            }

            createImageHTML(imageUrl, fromCache = false) {
                return `
                    <img src="${imageUrl}" 
                         alt="Article image" 
                         style="
                            opacity: 0; 
                            transition: opacity 0.8s ease;
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: inherit;
                         "
                         onload="
                            this.style.opacity='1';
                            console.log('✅ Image loaded ${fromCache ? 'from cache' : 'successfully'}');
                         " 
                         onerror="
                            console.log('⚠️ Image failed, tracking for retry');
                            const cardElement = this.closest('.article-card');
                            if (cardElement) {
                                const index = parseInt(cardElement.dataset.index);
                                if (!isNaN(index)) {
                                    webReader.failedImages.add(index);
                                    const indicator = this.parentElement.querySelector('.cache-indicator');
                                    if (indicator) {
                                        indicator.textContent = '❌ Failed';
                                        indicator.className = 'cache-indicator error';
                                    }
                                }
                            }
                            this.src='https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                         ">
                `;
            }

            createPlaceholderHTML() {
                return `
                    <div style="
                        width: 100%; 
                        height: 100%; 
                        background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                                   linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                                   linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                                   linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
                        background-size: 20px 20px;
                        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: #999;
                        animation: shimmer 1.5s ease-in-out infinite;
                    ">
                        <div style="text-align: center;">
                            <div style="font-size: 1.2em; margin-bottom: 5px;">🖼️</div>
                            <div style="font-size: 0.7em;">Loading image...</div>
                        </div>
                    </div>
                `;
            }

            // Mobile-optimized image loading with enhanced extraction
            async loadMissingImages(articles) {
                console.log('🎨 ENHANCED IMAGE LOADER - Getting REAL images with smart fallbacks...');

                const articlesNeedingImages = articles.filter((article, index) => {
                    // Check both stored backup images and local cache
                    const hasStoredImage = article.cachedImage && article.cachedImage.base64;
                    const hasCachedImage = this.getCachedImage(article);
                    return !hasStoredImage && !hasCachedImage;
                });

                if (articlesNeedingImages.length === 0) {
                    this.updateStatus(`✅ All images loaded with enhanced quality!`, 'success');
                    return;
                }

                const isMobile = window.innerWidth <= 768;
                let successCount = 0;
                const totalNew = articlesNeedingImages.length;

                console.log(`🔄 Loading ${totalNew} images with enhanced extraction${isMobile ? ' (mobile optimized)' : ''}`);

                // Mobile optimization: smaller batches for better performance, but same quality images
                const batchSize = isMobile ? 2 : 5;
                const delayBetweenImages = isMobile ? 800 : 300;

                for (let i = 0; i < articlesNeedingImages.length; i += batchSize) {
                    const batch = articlesNeedingImages.slice(i, i + batchSize);

                    // Process batch with enhanced extraction
                    await Promise.all(batch.map(async (article) => {
                        const originalIndex = articles.findIndex(a => a === article);

                        try {
                            const success = await this.extractAndCacheRealImage(article, originalIndex);
                            if (success) successCount++;
                        } catch (error) {
                            console.error(`Failed to extract image for article ${originalIndex}:`, error);
                            // Use smart fallback for failed extractions
                            const smartFallback = this.getCategoryBasedImage(article, originalIndex);
                            this.setArticleImageAndCache(article, originalIndex, smartFallback, 'smart_fallback');
                            successCount++;
                        }
                    }));

                    // Update progress with enhanced messaging
                    const progress = Math.round(((i + batchSize) / totalNew) * 100);
                    if (isMobile) {
                        this.updateStatus(`📱 Loading quality images... ${Math.min(i + batchSize, totalNew)}/${totalNew}`, 'loading');
                    } else {
                        this.updateStatus(`🎯 Loading enhanced images... ${Math.min(i + batchSize, totalNew)}/${totalNew} (${progress}%)`, 'loading');
                    }

                    // Delay between batches
                    if (i + batchSize < articlesNeedingImages.length) {
                        await new Promise(resolve => setTimeout(resolve, delayBetweenImages));
                    }
                }

                const totalCached = this.imageCache.size;

                if (isMobile) {
                    this.updateStatus(`📱 ${successCount} quality images loaded! 🎉`, 'success');
                } else {
                    this.updateStatus(`✅ Loaded ${successCount}/${totalNew} enhanced images! (${totalCached} total cached)`, 'success');
                }

                console.log(`🎨 Enhanced image loading complete: ${successCount}/${totalNew} quality images loaded`);
            }

            // ENHANCED: Force backup update when images are stored
            async setArticleImageAndCache(article, index, imageUrl, source) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return;

                // Update the DOM immediately
                imageElement.innerHTML = this.createImageHTML(imageUrl, false);

                // Update cache indicator
                const cacheIndicator = imageElement.querySelector('.cache-indicator');
                if (cacheIndicator) {
                    if (source === 'extracted') {
                        cacheIndicator.textContent = '🌐 Fresh';
                        cacheIndicator.className = 'cache-indicator fresh';
                    } else if (source === 'refreshed') {
                        cacheIndicator.textContent = '🔄 Refreshed';
                        cacheIndicator.className = 'cache-indicator fresh';
                    } else {
                        cacheIndicator.textContent = '💾 Cached';
                        cacheIndicator.className = 'cache-indicator cached';
                    }
                }

                // Store in local cache
                this.setCachedImage(article, imageUrl);

                // ENHANCED: Always store base64 data for cross-device sync (not just extracted images)
                if (this.storeImagesInBackup && (source === 'extracted' || source === 'saved' || source === 'fallback' || source === 'refreshed')) {
                    try {
                        console.log(`🔄 Converting image for cross-device storage: ${article.title.substring(0, 30)}...`);
                        const imageData = await this.convertImageToBase64(imageUrl);

                        if (imageData.stored) {
                            // Find the article in our array and add image data
                            const articleIndex = this.articles.findIndex(a => a.url === article.url);
                            if (articleIndex !== -1) {
                                this.articles[articleIndex].cachedImage = {
                                    base64: imageData.base64,
                                    url: imageData.url,
                                    timestamp: Date.now(),
                                    size: imageData.size,
                                    source: source
                                };

                                console.log(`💾 Stored ${imageData.size}KB image in backup for cross-device sync`);

                                // Update cache indicator to show it's stored for sync
                                if (cacheIndicator) {
                                    cacheIndicator.textContent = '🌐 Synced';
                                    cacheIndicator.className = 'cache-indicator synced';
                                }

                                // FIXED: Save to local cache immediately
                                this.saveLocalCache();
                            }
                        } else {
                            console.log(`⚠️ Image too large for cross-device storage: ${imageData.size}KB`);
                        }
                    } catch (error) {
                        console.error('Error storing image for cross-device sync:', error);
                    }
                }
            }

            // Extract and cache image with enhanced strategies
            async extractAndCacheRealImage(article, index) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return false;

                console.log(`🎯 Enhanced image extraction for: ${this.getDomain(article.url)}`);

                // Strategy 1: Try saved article images first (fastest)
                const savedImage = this.getBestArticleImage(article);
                if (savedImage) {
                    console.log(`✅ Using saved image: ${article.title.substring(0, 30)}...`);
                    this.setArticleImageAndCache(article, index, savedImage, 'saved');
                    return true;
                }

                // Strategy 2: Enhanced real-time extraction from website
                try {
                    const extractedImage = await this.fetchRealImageFromWebsite(article.url);
                    if (extractedImage) {
                        console.log(`✅ Extracted real image: ${article.title.substring(0, 30)}...`);
                        this.setArticleImageAndCache(article, index, extractedImage, 'extracted');
                        return true;
                    }
                } catch (error) {
                    console.log(`⚠️ Could not extract from website: ${error.message}`);
                }

                // Strategy 3: Use enhanced smart fallback system
                console.log(`🎨 Using enhanced smart fallback: ${article.title.substring(0, 30)}...`);
                const smartFallback = this.getCategoryBasedImage(article, index);
                this.setArticleImageAndCache(article, index, smartFallback, 'smart_fallback');
                return true;
            }

            // ENHANCED: Load articles with automatic token refresh and AI categorization
            async loadArticles() {
                // Ensure we have a valid token
                const hasValidToken = await this.ensureValidToken();
                if (!hasValidToken) {
                    this.updateConnectionStatus(false);
                    this.updateStatus('Authentication expired. Please reconnect.', 'error');
                    return;
                }

                try {
                    this.updateStatus('Loading articles with improved AI categorization... ⏳', 'loading');

                    const listResponse = await fetch('https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket:/children', {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!listResponse.ok) {
                        if (listResponse.status === 401) {
                            // Try to refresh token
                            const refreshSuccess = await this.refreshAccessToken();
                            if (refreshSuccess) {
                                // Retry the request with new token
                                return this.loadArticles();
                            } else {
                                this.clearTokens();
                                this.updateConnectionStatus(false);
                                this.updateStatus('Session expired. Please reconnect.', 'error');
                                return;
                            }
                        }
                        throw new Error(`Failed to list files: ${listResponse.status}`);
                    }

                    const fileList = await listResponse.json();
                    const backupFiles = fileList.value.filter(file =>
                        file.name.startsWith('mypocket-backup-') && file.name.endsWith('.json')
                    );

                    if (backupFiles.length === 0) {
                        this.updateStatus('No backup files found. Save some articles with the browser extension first.', 'error');
                        this.displayEmptyState();
                        return;
                    }

                    const latestFile = backupFiles.sort((a, b) =>
                        new Date(b.lastModifiedDateTime) - new Date(a.lastModifiedDateTime)
                    )[0];

                    const downloadResponse = await fetch(`https://graph.microsoft.com/v1.0/me/drive/items/${latestFile.id}/content`, {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`
                        }
                    });

                    if (!downloadResponse.ok) {
                        throw new Error(`Failed to download backup: ${downloadResponse.status}`);
                    }

                    const backupContent = await downloadResponse.text();
                    const backup = JSON.parse(backupContent);

                    this.articles = backup.articles || [];
                    this.currentDisplayedArticles = this.articles; // Initialize displayed articles

                    // IMPROVED AI-Enhanced auto-categorization on load
                    console.log('🧠 Advanced AI auto-categorizing loaded articles...');
                    this.updateStatus('🧠 Advanced AI is analyzing your articles...', 'loading');

                    // Process categorization in background for better UX
                    setTimeout(async () => {
                        await this.recategorizeAllWithAI();

                        // Update sidebar counts
                        this.updateArticleCounts();

                        this.displayArticles(this.articles);

                        const cacheStats = this.getCacheStats();
                        const storedImages = this.articles.filter(a => a.cachedImage).length;
                        const aiEnhancedCount = this.articles.filter(a => a.aiEnhanced).length;
                        const highConfidenceCount = this.articles.filter(a => a.categoryScore >= 100).length;

                        // FIXED: Save to local cache after loading
                        this.saveLocalCache();

                        this.updateStatus(`🧠 Loaded ${this.articles.length} articles with improved AI categorization (${storedImages} with stored images, ${aiEnhancedCount} AI-enhanced, ${highConfidenceCount} high-confidence)`, 'success');
                    }, 100);

                } catch (error) {
                    console.error('Error loading articles:', error);
                    this.updateStatus(`Error loading articles: ${error.message}`, 'error');
                }
            }

            displayEmptyState() {
                const container = document.getElementById('articlesContainer');
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">💾</div>
                        <h3>No articles found</h3>
                        <p>Use the MyPocket browser extension to save articles, then load them from OneDrive for advanced AI categorization with local caching!</p>
                    </div>`;
            }

            // FIXED: New functions that work with display indices
            openReaderByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                this.currentArticle = article;
                const overlay = document.getElementById('readerOverlay');

                // Set title and meta info
                document.getElementById('readerTitle').textContent = article.title;
                document.getElementById('readerDate').textContent = this.formatDate(article.dateAdded);
                document.getElementById('readerDomain').textContent = this.getDomain(article.url);
                document.getElementById('readerTime').textContent = `${article.readTime || 1} min read`;

                // Show loading state first
                document.getElementById('readerContent').innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                        <p>Checking for article content...</p>
                    </div>
                `;

                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';

                // Try to get content, fetch if needed
                setTimeout(() => this.loadArticleContent(article), 100);
            }

            exportArticleByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                try {
                    const html = this.createArticleHTML(article);
                    const filename = `${this.sanitizeFilename(article.title)}.html`;
                    this.downloadFile(html, filename, 'text/html');
                    this.updateStatus(`📤 Article "${article.title}" exported successfully!`, 'success');
                } catch (error) {
                    console.error('Error exporting article:', error);
                    this.updateStatus(`❌ Failed to export article: ${error.message}`, 'error');
                }
            }

            async deleteArticleByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                if (confirm(`Delete "${article.title}"?\n\nThis will permanently remove the article from your local cache and OneDrive backup.`)) {
                    try {
                        // Find the original index in the main articles array
                        const originalIndex = this.articles.findIndex(a =>
                            a.url === article.url && a.title === article.title
                        );

                        if (originalIndex === -1) {
                            throw new Error('Could not find article in main collection');
                        }

                        // Remove from cache
                        const cacheKey = this.getCacheKey(article);
                        this.imageCache.delete(cacheKey);
                        this.saveImageCache();

                        // Remove from manually edited set
                        const articleId = `${article.url}_${article.title}`;
                        this.manuallyEditedArticles.delete(articleId);

                        // Update category counts
                        const category = article.category;
                        if (category) {
                            const count = this.categories.get(category) || 1;
                            if (count <= 1) {
                                this.categories.delete(category);
                            } else {
                                this.categories.set(category, count - 1);
                            }
                        }

                        // Remove from main articles array
                        this.articles.splice(originalIndex, 1);

                        // Remove from currently displayed articles
                        this.currentDisplayedArticles.splice(displayIndex, 1);

                        // FIXED: Save to local cache immediately
                        this.saveLocalCache();

                        this.updateStatus(`✅ Article deleted and saved to local cache. ${this.articles.length} articles remaining.`, 'success');

                        // Refresh the display with current articles
                        this.displayArticles(this.currentDisplayedArticles);
                        this.updateArticleCounts();

                    } catch (error) {
                        console.error('Error deleting article:', error);
                        this.updateStatus(`❌ Failed to delete article: ${error.message}`, 'error');
                    }
                }
            }

            async loadArticleContent(article) {
                console.log('🚀 CONTENT LOADER WITH CACHING');
                const contentElement = document.getElementById('readerContent');

                // First try to get saved content
                let content = this.getArticleContent(article);

                // If no saved content found, try to fetch from original URL
                if (!content) {
                    console.log('🌐 No saved content found. Attempting to fetch from original URL...');

                    try {
                        // Show fetching status
                        contentElement.innerHTML = `
                            <div style="text-align: center; padding: 40px;">
                                <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                                <p><strong>🌐 Fetching article content...</strong></p>
                                <p style="font-size: 0.9em; color: var(--text-secondary);">
                                    Loading from ${this.getDomain(article.url)}
                                </p>
                                <p style="font-size: 0.8em; color: var(--text-secondary);">
                                    This may take a few seconds...
                                </p>
                            </div>
                        `;

                        // Fetch content using proxy services
                        const fetchedContent = await this.fetchArticleContent(article.url);

                        if (fetchedContent && fetchedContent.trim()) {
                            content = fetchedContent;
                            console.log('✅ Successfully fetched article content');
                            this.updateStatus('✅ Article content loaded successfully!', 'success');
                        } else {
                            throw new Error('No content extracted from fetched page');
                        }

                    } catch (error) {
                        console.log('❌ Failed to fetch content:', error.message);
                        this.updateStatus('❌ Could not fetch article content. Using fallback.', 'error');
                        content = this.getFallbackContent(article, error.message);
                    }
                } else {
                    console.log('✅ Using saved content');
                    this.updateStatus('✅ Article loaded from saved content', 'success');
                }

                // Display the final content
                contentElement.innerHTML = content;
            }

            async fetchArticleContent(url) {
                try {
                    console.log(`🌐 Starting fetch for: ${url}`);

                    // Method 1: Try using AllOrigins proxy (most reliable)
                    try {
                        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                        console.log(`Trying AllOrigins proxy...`);

                        const response = await fetch(proxyUrl);

                        if (response.ok) {
                            const data = await response.json();
                            const html = data.contents;

                            if (html && html.length > 1000) { // Ensure we got substantial content
                                console.log(`✅ AllOrigins success: ${html.length} chars`);
                                const extractedContent = this.extractContentFromHTML(html, url);
                                if (extractedContent && extractedContent.length > 500) {
                                    return extractedContent;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`AllOrigins failed: ${error.message}`);
                    }

                    // Method 2: Try CORS proxy
                    try {
                        const corsProxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                        console.log(`Trying CORS proxy...`);

                        const response = await fetch(corsProxyUrl);

                        if (response.ok) {
                            const html = await response.text();

                            if (html && html.length > 1000) {
                                console.log(`✅ CORS proxy success: ${html.length} chars`);
                                const extractedContent = this.extractContentFromHTML(html, url);
                                if (extractedContent && extractedContent.length > 500) {
                                    return extractedContent;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`CORS proxy failed: ${error.message}`);
                    }

                    // Method 3: Try direct fetch (will likely fail due to CORS, but worth trying)
                    try {
                        console.log(`Trying direct fetch...`);
                        const response = await fetch(url, {
                            mode: 'cors',
                            headers: {
                                'User-Agent': 'Mozilla/5.0 (compatible; MyPocket Reader)'
                            }
                        });

                        if (response.ok) {
                            const html = await response.text();
                            console.log(`✅ Direct fetch success: ${html.length} chars`);
                            return this.extractContentFromHTML(html, url);
                        }
                    } catch (error) {
                        console.log(`Direct fetch failed (expected): ${error.message}`);
                    }

                    throw new Error('All proxy methods failed to fetch content');

                } catch (error) {
                    console.error('❌ All fetch methods failed:', error);
                    throw error;
                }
            }

            extractContentFromHTML(html, url) {
                try {
                    // Create a temporary DOM to parse the HTML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    // Remove unwanted elements
                    const unwantedSelectors = [
                        'script', 'style', 'nav', 'header', 'footer',
                        '.sidebar', '.menu', '.navigation', '.comments',
                        '.advertisement', '.ads', '.social-share',
                        '[role="banner"]', '[role="navigation"]', '[role="complementary"]'
                    ];

                    unwantedSelectors.forEach(selector => {
                        doc.querySelectorAll(selector).forEach(el => el.remove());
                    });

                    // Try to find the main content using common selectors
                    const contentSelectors = [
                        'article',
                        '[role="main"]',
                        '.post-content', '.entry-content', '.article-content',
                        '.content', '.main-content', '.post-body',
                        '.entry', '.post', '.article-body',
                        'main', '#content', '#main'
                    ];

                    let contentElement = null;

                    for (const selector of contentSelectors) {
                        contentElement = doc.querySelector(selector);
                        if (contentElement && contentElement.textContent.trim().length > 200) {
                            break;
                        }
                    }

                    // If no main content found, try to get paragraphs from body
                    if (!contentElement || contentElement.textContent.trim().length < 200) {
                        const paragraphs = Array.from(doc.querySelectorAll('p'))
                            .filter(p => p.textContent.trim().length > 50)
                            .slice(0, 20); // Take first 20 substantial paragraphs

                        if (paragraphs.length > 0) {
                            const div = doc.createElement('div');
                            paragraphs.forEach(p => div.appendChild(p.cloneNode(true)));
                            contentElement = div;
                        }
                    }

                    if (contentElement) {
                        // Clean up the content
                        let content = contentElement.innerHTML;

                        // Fix relative URLs to absolute
                        const baseUrl = new URL(url).origin;
                        content = content.replace(/src="\/([^"]+)"/g, `src="${baseUrl}/$1"`);
                        content = content.replace(/href="\/([^"]+)"/g, `href="${baseUrl}/$1"`);

                        // Add a note about the source
                        content = `
                            <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                                <p style="margin: 0; font-size: 0.9em;">
                                    <strong>📡 Content fetched from original source</strong><br>
                                    This article content was retrieved in real-time from <a href="${url}" target="_blank" style="color: #1976d2;">${this.getDomain(url)}</a>
                                </p>
                            </div>
                            ${content}
                        `;

                        return content;
                    }

                    throw new Error('Could not extract readable content from page');

                } catch (error) {
                    console.error('Content extraction error:', error);
                    throw error;
                }
            }

            getFallbackContent(article, errorMessage) {
                return `
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h3>📄 Content Not Available</h3>
                        <p>We couldn't load the full article content. This can happen because:</p>
                        <ul style="margin: 15px 0;">
                            <li>The website blocks automated content fetching</li>
                            <li>CORS (Cross-Origin) restrictions prevent access</li>
                            <li>The article content wasn't saved by the browser extension</li>
                            <li>Network connectivity issues</li>
                        </ul>
                        
                        <p><strong>What you can do:</strong></p>
                        <ol style="margin: 15px 0;">
                            <li><strong>Visit the original article</strong> using the button below</li>
                            <li><strong>Re-save the article</strong> with your browser extension</li>
                            <li><strong>Check extension settings</strong> for content extraction options</li>
                        </ol>
                        
                        <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <p><strong>Available excerpt:</strong></p>
                            <p style="font-style: italic;">${article.excerpt || 'No excerpt available'}</p>
                        </div>
                        
                        <div style="text-align: center; margin: 20px 0;">
                            <a href="${article.url}" target="_blank" style="display: inline-block; background: #ee5a24; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                                🔗 Read Full Article
                            </a>
                        </div>
                        
                        <details style="margin-top: 20px;">
                            <summary style="cursor: pointer; color: #666;">Technical Details</summary>
                            <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
                                Error: ${errorMessage}
                            </p>
                        </details>
                    </div>
                `;
            }

            // Get the best available content for reading - simplified version
            getArticleContent(article) {
                console.log('📖 Checking for saved content...');

                // Try content fields in order
                const contentFields = ['content', 'html', 'fullContent', 'textContent', 'body', 'readableContent', 'articleContent', 'savedContent'];

                for (const field of contentFields) {
                    if (article[field] && article[field].trim()) {
                        console.log(`✅ Found content in ${field} (${article[field].length} chars)`);
                        return article[field];
                    }
                }

                // Look for any substantial text content
                for (const [key, value] of Object.entries(article)) {
                    if (typeof value === 'string' && value.length > 200 && key !== 'excerpt' && key !== 'url') {
                        console.log(`✅ Found substantial content in ${key} (${value.length} chars)`);
                        return value;
                    }
                }

                console.log('❌ No saved content found');
                return null;
            }

            closeReader() {
                const overlay = document.getElementById('readerOverlay');
                overlay.classList.remove('active');
                document.body.style.overflow = 'auto';
            }

            openOriginal() {
                if (this.currentArticle) {
                    window.open(this.currentArticle.url, '_blank');
                }
            }

            // Enhanced backup to include image data and AI categories
            async updateOneDriveBackup() {
                if (!this.accessToken) {
                    throw new Error('Not connected to OneDrive');
                }

                // Calculate backup size with images
                const articlesWithImages = this.articles.filter(a => a.cachedImage);
                const totalImageSizeKB = articlesWithImages.reduce((total, article) => {
                    return total + (article.cachedImage ? article.cachedImage.size || 0 : 0);
                }, 0);

                const aiEnhancedCount = this.articles.filter(a => a.aiEnhanced).length;
                const highConfidenceCount = this.articles.filter(a => a.categoryScore >= 100).length;
                const manuallyEditedCount = this.manuallyEditedArticles.size;

                console.log(`📦 Creating backup with ${articlesWithImages.length} stored images (${Math.round(totalImageSizeKB)}KB), ${aiEnhancedCount} AI-enhanced articles, ${highConfidenceCount} high-confidence categorizations, and ${manuallyEditedCount} manually edited articles`);

                const backup = {
                    articles: this.articles, // This now includes cachedImage data and improved AI categories
                    settings: {
                        storeImagesInBackup: this.storeImagesInBackup,
                        maxImageSizeKB: this.maxImageSizeKB,
                        aiCategoriesEnabled: this.aiCategoriesEnabled,
                        autoSaveEnabled: this.autoSaveEnabled
                    },
                    aiAnalytics: Object.fromEntries(this.categoryAnalytics),
                    manuallyEditedArticles: Array.from(this.manuallyEditedArticles),
                    exportDate: new Date().toISOString(),
                    version: "7.2-fixed", // Bump version for FIXED local cache + manual editing
                    deviceInfo: {
                        browser: "AI-Enhanced Web Reader v3.2 with FIXED Local Cache + Manual Editing + PKCE Security + Cross-Device Images",
                        platform: navigator.platform,
                        timestamp: Date.now(),
                        articleCount: this.articles.length,
                        storedImages: articlesWithImages.length,
                        totalImageSizeKB: Math.round(totalImageSizeKB),
                        aiEnhancedArticles: aiEnhancedCount,
                        highConfidenceArticles: highConfidenceCount,
                        manuallyEditedArticles: manuallyEditedCount,
                        categoriesFound: this.categories.size,
                        authMethod: "Authorization Code + PKCE",
                        aiFeatures: "FIXED context-aware categorization with 16 categories, negative filtering, confidence scoring, manual overrides, manual category editing with local cache, and advanced pattern recognition"
                    }
                };

                const fileName = `mypocket-backup-${new Date().toISOString().split('T')[0]}.json`;
                const fileContent = JSON.stringify(backup, null, 2);

                // Check if backup is getting too large (>10MB)
                const backupSizeMB = fileContent.length / (1024 * 1024);
                if (backupSizeMB > 10) {
                    console.warn(`⚠️ Large backup detected: ${backupSizeMB.toFixed(1)}MB`);
                }

                const uploadUrl = `https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket/${fileName}:/content`;

                const uploadResponse = await fetch(uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${this.accessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: fileContent
                });

                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    throw new Error(`Failed to update OneDrive backup: ${uploadResponse.status} - ${errorText}`);
                }

                console.log(`✅ Fixed AI backup saved with ${articlesWithImages.length} images (${Math.round(totalImageSizeKB)}KB), ${aiEnhancedCount} AI-categorized articles, ${highConfidenceCount} high-confidence categorizations, and ${manuallyEditedCount} manually edited articles`);
                return await uploadResponse.json();
            }

            createArticleHTML(article) {
                const articleId = `${article.url}_${article.title}`;
                const isManuallyEdited = this.manuallyEditedArticles.has(articleId);

                const categoryInfo = article.category ? `
                    <div style="margin-bottom: 16px;">
                        <span style="background: ${isManuallyEdited ? '#198754' : '#ee5a24'}; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.9em;">
                            ${this.categoryKeywords[article.category]?.icon || '📄'} ${article.category}
                            ${isManuallyEdited ? ' ✏️' : (article.aiEnhanced ? ' 🤖' : '')}
                            ${article.categoryScore >= 100 ? ' 🎯' : ''}
                        </span>
                    </div>
                ` : '';

                return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHtml(article.title)}</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 40px 20px; 
            line-height: 1.7; 
            color: #333;
        }
        .header { 
            border-bottom: 3px solid #ee5a24; 
            margin-bottom: 32px; 
            padding-bottom: 24px; 
        }
        .title { 
            font-size: 2.4em; 
            font-weight: bold; 
            margin-bottom: 16px; 
            color: #2c3e50; 
            line-height: 1.2; 
        }
        .meta { 
            color: #7f8c8d; 
            font-size: 0.95em; 
            margin-bottom: 24px; 
        }
        .content { 
            font-size: 1.15em; 
            line-height: 1.8; 
        }
        .content img { 
            max-width: 100%; 
            height: auto; 
            margin: 24px 0; 
            border-radius: 8px; 
        }
        .content p { 
            margin-bottom: 1.4em; 
        }
        .footer { 
            margin-top: 48px; 
            padding-top: 24px; 
            border-top: 2px solid #f0f0f0; 
            color: #666; 
            font-size: 0.9em; 
        }
    </style>
</head>
<body>
    <div class="header">
        ${categoryInfo}
        <h1 class="title">${this.escapeHtml(article.title)}</h1>
        <div class="meta">
            <div style="margin-bottom: 8px;">🌐 From: <a href="${article.url}" style="color: #ee5a24;">${this.getDomain(article.url)}</a></div>
            ${article.author ? `<div style="margin-bottom: 8px;">✍️ By: ${this.escapeHtml(article.author)}</div>` : ''}
            <div style="margin-bottom: 8px;">📅 Saved: ${this.formatDate(article.dateAdded)}</div>
            <div>⏱️ Reading time: ${article.readTime || 1} minutes</div>
            ${article.categoryScore ? `<div>🧠 AI Category Score: ${article.categoryScore} ${article.categoryScore >= 100 ? '🎯' : ''}</div>` : ''}
            ${isManuallyEdited ? `<div>✏️ Manually Edited Category</div>` : ''}
        </div>
    </div>
    <div class="content">
        ${article.content || article.excerpt || 'Content not available'}
    </div>
    <div class="footer">
        <p><strong>💾 Exported from MyPocket AI-Enhanced Reader v3.2 (FIXED Local Cache + Manual Editing + PKCE Security)</strong></p>
        <p>Original URL: <a href="${article.url}" style="color: #ee5a24;">${article.url}</a></p>
        <p>Export Date: ${new Date().toLocaleDateString()}</p>
        ${article.category ? `<p>Category: ${article.category} ${isManuallyEdited ? '(Manually Edited)' : (article.aiEnhanced ? '(AI-Enhanced)' : '')} ${article.categoryScore >= 100 ? '(High-Confidence)' : ''}</p>` : ''}
    </div>
</body>
</html>`;
            }

            // Enhanced image handling
            getBestArticleImage(article) {
                if (article.images && article.images.length > 0) {
                    let bestImage = article.images[0];

                    for (const img of article.images) {
                        if (img.width && img.height) {
                            if (img.width >= 300 && img.height >= 150) {
                                bestImage = img;
                                break;
                            }
                        }
                    }

                    return bestImage.src || bestImage.url || bestImage;
                }

                if (article.featuredImage) {
                    return article.featuredImage;
                }

                if (article.image) {
                    return article.image;
                }

                if (article.content) {
                    const imgMatch = article.content.match(/<img[^>]+src="([^"]+)"/i);
                    if (imgMatch && imgMatch[1]) {
                        return imgMatch[1];
                    }
                }

                return null;
            }

            // ENHANCED: Fetch the actual featured image from a website with better strategies
            async fetchRealImageFromWebsite(url) {
                try {
                    console.log(`🌐 Enhanced image extraction for: ${url}`);

                    // Strategy 1: Try multiple proxy services for better success rate
                    const proxies = [
                        `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
                        `https://corsproxy.io/?${encodeURIComponent(url)}`,
                        `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`
                    ];

                    for (const proxyUrl of proxies) {
                        try {
                            console.log(`Trying proxy: ${proxyUrl.includes('allorigins') ? 'AllOrigins' : proxyUrl.includes('corsproxy') ? 'CorsProxy' : 'CodeTabs'}`);

                            const response = await fetch(proxyUrl);
                            if (!response.ok) continue;

                            let html;
                            if (proxyUrl.includes('allorigins')) {
                                const data = await response.json();
                                html = data.contents;
                            } else {
                                html = await response.text();
                            }

                            if (html && html.length > 500) {
                                const extractedImageUrl = this.parseHTMLForBestImage(html, url);
                                if (extractedImageUrl) {
                                    console.log(`✅ Found real image via proxy: ${extractedImageUrl}`);
                                    return extractedImageUrl;
                                }
                            }
                        } catch (error) {
                            console.log(`Proxy failed: ${error.message}`);
                            continue;
                        }
                    }

                    // Strategy 2: Try site-specific image APIs
                    const siteSpecificImage = await this.tryPlatformSpecificImageExtraction(url);
                    if (siteSpecificImage) {
                        console.log(`✅ Found platform-specific image: ${siteSpecificImage}`);
                        return siteSpecificImage;
                    }

                    throw new Error('All extraction methods failed');

                } catch (error) {
                    console.log(`❌ Website image extraction failed: ${error.message}`);
                    throw error;
                }
            }

            // NEW: Platform-specific image extraction for known sites
            async tryPlatformSpecificImageExtraction(url) {
                const domain = this.getDomain(url).toLowerCase();

                // YouTube video thumbnails
                if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                    const videoIdMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/);
                    if (videoIdMatch) {
                        const videoId = videoIdMatch[1];
                        // Try different thumbnail qualities
                        const thumbnailUrls = [
                            `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`,
                            `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,
                            `https://img.youtube.com/vi/${videoId}/mqdefault.jpg`
                        ];

                        for (const thumbUrl of thumbnailUrls) {
                            try {
                                const response = await fetch(thumbUrl, { method: 'HEAD' });
                                if (response.ok) {
                                    console.log(`✅ YouTube thumbnail found: ${thumbUrl}`);
                                    return thumbUrl;
                                }
                            } catch (e) { continue; }
                        }
                    }
                }

                // GitHub repository social images
                if (domain.includes('github.com')) {
                    const pathMatch = url.match(/github\.com\/([^\/]+)\/([^\/]+)/);
                    if (pathMatch) {
                        const [, owner, repo] = pathMatch;
                        const socialImageUrl = `https://opengraph.githubassets.com/1/${owner}/${repo}`;
                        try {
                            const response = await fetch(socialImageUrl, { method: 'HEAD' });
                            if (response.ok) {
                                console.log(`✅ GitHub social image found: ${socialImageUrl}`);
                                return socialImageUrl;
                            }
                        } catch (e) { /* continue */ }
                    }
                }

                return null;
            }

            // ENHANCED: Parse HTML with much better image detection
            parseHTMLForBestImage(html, baseUrl) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    // Remove unwanted elements first
                    const unwantedSelectors = ['script', 'style', 'nav', 'header', 'footer'];
                    unwantedSelectors.forEach(selector => {
                        doc.querySelectorAll(selector).forEach(el => el.remove());
                    });

                    // Strategy 1: Open Graph and Twitter Card images (most reliable)
                    const metaImages = [
                        'meta[property="og:image"]',
                        'meta[property="og:image:url"]',
                        'meta[name="twitter:image"]',
                        'meta[property="twitter:image"]',
                        'meta[name="twitter:image:src"]'
                    ];

                    for (const selector of metaImages) {
                        const metaTag = doc.querySelector(selector);
                        if (metaTag) {
                            const imageUrl = this.makeAbsoluteUrl(metaTag.getAttribute('content'), baseUrl);
                            if (this.isValidImageUrl(imageUrl) && !this.isIconOrLogo(imageUrl)) {
                                console.log(`🎯 Found meta image: ${imageUrl}`);
                                return imageUrl;
                            }
                        }
                    }

                    // Strategy 2: Article-specific selectors (more comprehensive)
                    const articleImageSelectors = [
                        'article img[src]:first-of-type',
                        '.article-image img[src]',
                        '.post-image img[src]',
                        '.featured-image img[src]',
                        '.hero-image img[src]',
                        '.post-thumbnail img[src]',
                        '.entry-image img[src]',
                        '.wp-post-image[src]',
                        '[class*="featured"] img[src]',
                        '[class*="hero"] img[src]',
                        '.content img[src]:first-of-type',
                        '.post-content img[src]:first-of-type',
                        '.entry-content img[src]:first-of-type',
                        'main img[src]:first-of-type'
                    ];

                    for (const selector of articleImageSelectors) {
                        const img = doc.querySelector(selector);
                        if (img) {
                            const src = img.getAttribute('src') || img.getAttribute('data-src') || img.getAttribute('data-lazy-src');
                            if (src) {
                                const imageUrl = this.makeAbsoluteUrl(src, baseUrl);
                                if (this.isValidImageUrl(imageUrl) && !this.isIconOrLogo(src) && this.isLargeEnoughImage(img)) {
                                    console.log(`🎯 Found article image: ${imageUrl}`);
                                    return imageUrl;
                                }
                            }
                        }
                    }

                    console.log(`❌ No suitable image found in HTML`);
                    return null;

                } catch (error) {
                    console.error('Enhanced HTML parsing error:', error);
                    return null;
                }
            }

            // Enhanced URL validation
            isValidImageUrl(url) {
                if (!url || typeof url !== 'string') return false;

                // Must be a valid URL
                try {
                    new URL(url);
                } catch {
                    return false;
                }

                // Must have common image extensions or be from known image services
                const imagePattern = /\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i;
                const imageServices = ['unsplash.com', 'images.unsplash.com', 'picsum.photos', 'via.placeholder.com'];

                return imagePattern.test(url) || imageServices.some(service => url.includes(service));
            }

            // Enhanced icon/logo detection
            isIconOrLogo(src) {
                if (!src) return false;

                const iconPatterns = [
                    'icon', 'logo', 'avatar', 'profile', 'favicon', 'sprite',
                    'button', 'badge', 'social', 'thumb', 'thumbnail',
                    '/icons/', '/images/icons/', 'gravatar', 'user-content'
                ];

                const srcLower = src.toLowerCase();
                return iconPatterns.some(pattern => srcLower.includes(pattern)) ||
                    srcLower.includes('.ico') ||
                    (srcLower.includes('64x64') || srcLower.includes('32x32'));
            }

            // ENHANCED: Better image size detection
            isLargeEnoughImage(img) {
                const width = parseInt(img.getAttribute('width') || img.style.width) || 0;
                const height = parseInt(img.getAttribute('height') || img.style.height) || 0;

                // If no dimensions specified, assume it might be large enough
                if (!width && !height) return true;

                // Must be reasonably large for article images
                return (width >= 200 && height >= 150) || (width >= 300) || (height >= 200);
            }

            // Convert relative URLs to absolute
            makeAbsoluteUrl(imageUrl, baseUrl) {
                if (!imageUrl) return null;

                try {
                    // If already absolute, return as-is
                    if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                        return imageUrl;
                    }

                    // Handle protocol-relative URLs
                    if (imageUrl.startsWith('//')) {
                        return 'https:' + imageUrl;
                    }

                    // If relative, make it absolute
                    const base = new URL(baseUrl);
                    return new URL(imageUrl, base.origin).href;
                } catch (error) {
                    console.log(`Failed to make absolute URL: ${imageUrl}, base: ${baseUrl}`);
                    return null;
                }
            }

            // COMPLETELY OVERHAULED: Smart, relevant category-based images (no more random!)
            getCategoryBasedImage(article, index) {
                const domain = this.getDomain(article.url).toLowerCase();
                const title = article.title.toLowerCase();
                const url = article.url.toLowerCase();
                const category = article.category || 'Lifestyle';

                console.log(`🎨 Getting smart image for "${title.substring(0, 30)}..." in category: ${category}`);

                // PRIORITY 1: Domain-specific real images (most accurate)
                const domainImage = this.getSmartDomainImage(domain, url, title);
                if (domainImage) {
                    console.log(`✅ Using domain-specific image: ${domainImage}`);
                    return domainImage;
                }

                // PRIORITY 2: Content-specific images based on title keywords
                const contentImage = this.getContentSpecificImage(title, category);
                if (contentImage) {
                    console.log(`✅ Using content-specific image: ${contentImage}`);
                    return contentImage;
                }

                // PRIORITY 3: High-quality category images (much more specific)
                const categoryImage = this.getHighQualityCategoryImage(category, title);
                console.log(`✅ Using category-specific image: ${categoryImage}`);
                return categoryImage;
            }

            // NEW: Smart domain-specific images for better accuracy
            getSmartDomainImage(domain, url, title) {
                // GitHub repositories
                if (domain.includes('github.com')) {
                    const repoMatch = url.match(/github\.com\/([^\/]+)\/([^\/]+)/);
                    if (repoMatch) {
                        // Use GitHub's social preview service
                        return `https://opengraph.githubassets.com/1/${repoMatch[1]}/${repoMatch[2]}`;
                    }
                    return 'https://images.unsplash.com/photo-1618401471353-b98afee0b2eb?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                }

                // Stack Overflow questions
                if (domain.includes('stackoverflow.com')) {
                    return 'https://images.unsplash.com/photo-1516116216624-53e697fedbea?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                }

                // YouTube videos
                if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                    const videoMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/);
                    if (videoMatch) {
                        return `https://img.youtube.com/vi/${videoMatch[1]}/maxresdefault.jpg`;
                    }
                    return 'https://images.unsplash.com/photo-1611162617474-5b21e879e113?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                }

                return null; // No specific domain match
            }

            // NEW: Content-specific images based on title analysis
            getContentSpecificImage(title, category) {
                // Technology-specific content
                if (title.includes('javascript') || title.includes('js')) {
                    return 'https://images.unsplash.com/photo-1627398242454-45a1465c2479?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                }
                if (title.includes('python')) {
                    return 'https://images.unsplash.com/photo-1526379879527-8559ecfcaec0?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                }
                if (title.includes('react') || title.includes('vue') || title.includes('angular')) {
                    return 'https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                }

                return null; // No specific content match
            }

            // NEW: High-quality category images (much more specific than before)
            getHighQualityCategoryImage(category, title) {
                const categoryImages = {
                    'Technology': [
                        'https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1555949963-ff9fe166c327?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'Business': [
                        'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1664475450424-2645cd1d4b21?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1611974789855-9c2a0a7236a3?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'Science': [
                        'https://images.unsplash.com/photo-1532094349884-543bc11b234d?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'Lifestyle': [
                        'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1560472354-b33ff0c44a43?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1522202176988-66273c2fd55f?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ]
                };

                const images = categoryImages[category] || categoryImages['Lifestyle'];

                // Use title hash for consistent selection (not random!)
                let hash = 0;
                for (let i = 0; i < title.length; i++) {
                    hash = ((hash << 5) - hash + title.charCodeAt(i)) & 0xffffffff;
                }
                const index = Math.abs(hash) % images.length;

                return images[index];
            }

            // Enhanced search functionality with AI-powered filtering
            searchArticles(query) {
                if (!query.trim()) {
                    // Show all articles when search is empty
                    this.currentDisplayedArticles = this.articles;
                    this.displayArticles(this.articles);
                    this.updateStatus(`📖 Showing all ${this.articles.length} articles`, 'success');
                    return;
                }

                console.log(`🔍 AI-powered search for: "${query}"`);

                const searchQuery = query.toLowerCase();
                const searchTerms = searchQuery.split(/\s+/).filter(term => term.length > 2);

                const filtered = this.articles.filter(article => {
                    const title = (article.title || '').toLowerCase();
                    const excerpt = (article.excerpt || '').toLowerCase();
                    const content = this.getArticleContentForAnalysis(article).toLowerCase();
                    const domain = this.getDomain(article.url).toLowerCase();
                    const category = (article.category || '').toLowerCase();

                    // Check if any search term matches
                    return searchTerms.some(term => {
                        return title.includes(term) ||
                            excerpt.includes(term) ||
                            content.includes(term) ||
                            domain.includes(term) ||
                            category.includes(term);
                    }) ||
                        // Or if the full query matches
                        title.includes(searchQuery) ||
                        excerpt.includes(searchQuery) ||
                        content.includes(searchQuery);
                });

                this.currentDisplayedArticles = filtered;
                this.displayArticles(filtered);

                const aiEnhancedCount = filtered.filter(a => a.aiEnhanced).length;
                const highConfidenceCount = filtered.filter(a => a.categoryScore >= 100).length;
                const manuallyEditedCount = filtered.filter(a => {
                    const articleId = `${a.url}_${a.title}`;
                    return this.manuallyEditedArticles.has(articleId);
                }).length;

                if (filtered.length === 0) {
                    this.updateStatus(`❌ No articles found for "${query}". Try different keywords.`, 'error');
                } else {
                    const aiText = aiEnhancedCount > 0 ? ` (${aiEnhancedCount} AI-enhanced, ${highConfidenceCount} high-confidence, ${manuallyEditedCount} manually edited)` : '';
                    this.updateStatus(`🔍 Found ${filtered.length} articles for "${query}"${aiText}`, 'success');
                }

                console.log(`🔍 Search complete: ${filtered.length} results`);
            }

            // Enhanced dark mode toggle
            toggleDarkMode() {
                const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                const newTheme = isDark ? 'light' : 'dark';

                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('mypocket_theme', newTheme);

                // Update dark mode button
                const darkModeIcon = document.getElementById('darkModeIcon');
                const darkModeText = document.getElementById('darkModeText');

                if (darkModeIcon && darkModeText) {
                    if (newTheme === 'dark') {
                        darkModeIcon.textContent = '☀️';
                        darkModeText.textContent = 'Light Mode';
                    } else {
                        darkModeIcon.textContent = '🌙';
                        darkModeText.textContent = 'Dark Mode';
                    }
                }

                this.updateStatus(`${newTheme === 'dark' ? '🌙' : '☀️'} Switched to ${newTheme} mode`, 'success');
            }

            loadThemePreference() {
                const savedTheme = localStorage.getItem('mypocket_theme') || 'light';
                document.documentElement.setAttribute('data-theme', savedTheme);

                // Update button state
                const darkModeIcon = document.getElementById('darkModeIcon');
                const darkModeText = document.getElementById('darkModeText');

                if (darkModeIcon && darkModeText) {
                    if (savedTheme === 'dark') {
                        darkModeIcon.textContent = '☀️';
                        darkModeText.textContent = 'Light Mode';
                    } else {
                        darkModeIcon.textContent = '🌙';
                        darkModeText.textContent = 'Dark Mode';
                    }
                }
            }

            // Toggle test mode to show action buttons
            toggleTestMode() {
                const isTestMode = document.body.classList.contains('test-mode');

                if (isTestMode) {
                    document.body.classList.remove('test-mode');
                    this.updateStatus('👁️ Test mode disabled - buttons hidden on hover', 'success');
                } else {
                    document.body.classList.add('test-mode');
                    this.updateStatus('👁️ Test mode enabled - all buttons visible', 'success');
                }
            }

            // Show debug information with enhanced cache details
            showDebugInfo() {
                const cacheStats = this.getCacheStats();
                const storedImages = this.articles.filter(a => a.cachedImage).length;
                const aiEnhancedCount = this.articles.filter(a => a.aiEnhanced).length;
                const highConfidenceCount = this.articles.filter(a => a.categoryScore >= 100).length;
                const manuallyEditedCount = this.manuallyEditedArticles.size;

                // FIXED: Check localStorage usage
                let localStorageUsage = 'Unknown';
                let localStorageDetails = '';
                try {
                    let totalSize = 0;
                    let myPocketSize = 0;

                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        const size = value ? value.length : 0;
                        totalSize += size;

                        if (key && key.startsWith('mypocket_')) {
                            myPocketSize += size;
                            localStorageDetails += `\n  • ${key}: ${Math.round(size / 1024)}KB`;
                        }
                    }

                    const totalMB = Math.round(totalSize / 1024 / 1024 * 100) / 100;
                    const myPocketMB = Math.round(myPocketSize / 1024 / 1024 * 100) / 100;
                    localStorageUsage = `${totalMB}MB total, ${myPocketMB}MB MyPocket`;
                } catch (e) {
                    localStorageUsage = `Error: ${e.message}`;
                }

                const debugInfo = `
MyPocket AI-Enhanced Web Reader Debug Info (FIXED):
=================================================

📊 ARTICLES:
- Total: ${this.articles.length}
- Currently displayed: ${this.currentDisplayedArticles.length}
- With stored images: ${storedImages}
- AI-enhanced: ${aiEnhancedCount}
- High-confidence: ${highConfidenceCount}
- Manually edited: ${manuallyEditedCount}

💾 LOCAL CACHE SYSTEM (FIXED):
- Auto-save enabled: ${this.autoSaveEnabled}
- Has unsaved changes: ${this.hasUnsavedChanges}
- Manually edited articles: ${this.manuallyEditedArticles.size}
- Last OneDrive sync hash: ${this.lastOneDriveSyncHash ? 'Set' : 'None'}
- LocalStorage usage: ${localStorageUsage}
- Cache details: ${localStorageDetails || '\n  • No MyPocket data found'}

🧠 FIXED AI CATEGORIZATION:
- Categories found: ${this.categories.size}
- Active category filter: ${this.activeCategory || 'None'}
- AI categories enabled: ${this.aiCategoriesEnabled}
- Analytics tracked: ${this.categoryAnalytics.size} categories
- Is recategorizing: ${this.isRecategorizing}

💾 IMAGE CACHE:
- Local cache entries: ${cacheStats.total}
- Memory usage: ~${Math.round(cacheStats.memoryUsage / 1024)}KB
- Failed images tracked: ${this.failedImages.size}
- Store in backup: ${this.storeImagesInBackup}
- Max image size: ${this.maxImageSizeKB}KB

🔐 AUTHENTICATION:
- Connected: ${!!this.accessToken}
- Redirect URI: ${this.redirectUri}
- Client ID: ${this.clientId}
- Auth method: Authorization Code + PKCE

⚙️ FEATURES:
- Enhanced image extraction: ✅
- Cross-device image sync: ✅
- FIXED AI categorization: ✅
- FIXED Manual category editing: ✅
- FIXED Local cache system: ✅
- PKCE security: ✅
- Smart fallback images: ✅
- Advanced search: ✅
- Progress tracking: ✅
- Auto-save functionality: ✅

🎯 CATEGORIZATION ANALYTICS:
${Array.from(this.categoryAnalytics.entries()).map(([cat, stats]) =>
                    `• ${cat}: ${stats.count} articles (${stats.aiEnhanced} AI-enhanced, avg score: ${stats.avgScore})`
                ).join('\n')}

🔧 CACHE TROUBLESHOOTING:
- If getting cache errors, try "Clear Cache" button
- LocalStorage limit is usually 5-10MB per domain
- Large base64 images can fill storage quickly
- Use OneDrive sync for large collections

Version: 7.2-fixed - AI-Enhanced with FIXED Local Cache + Manual Editing + PKCE Security
Build: Fixed Local Cache + Manual Category Editing + Cross-Device Images + Auto-Save
                `;

                // Enhanced debug with action buttons
                const userAction = confirm(debugInfo + '\n\nDo you want to clear old cache data to free up space?');

                if (userAction) {
                    this.clearOldCacheData();
                    this.updateStatus('🗑️ Cleared old cache data to free up storage space', 'success');
                }

                console.log('🔧 FIXED DEBUG INFO:', {
                    articles: this.articles.length,
                    categories: Object.fromEntries(this.categories),
                    cache: cacheStats,
                    analytics: Object.fromEntries(this.categoryAnalytics),
                    failedImages: Array.from(this.failedImages),
                    isRecategorizing: this.isRecategorizing,
                    autoSaveEnabled: this.autoSaveEnabled,
                    hasUnsavedChanges: this.hasUnsavedChanges,
                    manuallyEdited: Array.from(this.manuallyEditedArticles),
                    localStorageUsage: localStorageUsage
                });
            }

            // Utility functions for image handling
            async refreshSingleImage(originalIndex, displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) return;

                console.log(`🔄 Refreshing image for: ${article.title.substring(0, 30)}...`);

                // Clear existing cache for this article
                const cacheKey = this.getCacheKey(article);
                this.imageCache.delete(cacheKey);

                // Clear stored image
                if (article.cachedImage) {
                    delete article.cachedImage;
                }

                // Update status
                const imageElement = document.getElementById(`image-${originalIndex}`);
                if (imageElement) {
                    imageElement.innerHTML = this.createPlaceholderHTML();
                    const indicator = imageElement.querySelector('.cache-indicator');
                    if (indicator) {
                        indicator.textContent = '🔄 Refreshing...';
                        indicator.className = 'cache-indicator loading';
                    }
                }

                // Try to get a new image
                try {
                    await this.extractAndCacheRealImage(article, originalIndex);
                    this.updateStatus(`✅ Image refreshed for "${article.title.substring(0, 30)}..."`, 'success');
                } catch (error) {
                    console.error('Error refreshing image:', error);
                    this.updateStatus(`❌ Failed to refresh image: ${error.message}`, 'error');
                }
            }

            async retryFailedImages() {
                if (this.failedImages.size === 0) {
                    this.updateStatus('✅ No failed images to retry!', 'success');
                    return;
                }

                this.updateStatus(`🔁 Retrying ${this.failedImages.size} failed images...`, 'loading');

                let successCount = 0;
                const totalFailed = this.failedImages.size;

                for (const index of this.failedImages) {
                    const article = this.currentDisplayedArticles[index];
                    if (article) {
                        try {
                            await this.extractAndCacheRealImage(article, index);
                            this.failedImages.delete(index);
                            successCount++;
                        } catch (error) {
                            console.error(`Retry failed for index ${index}:`, error);
                        }
                    }
                }

                if (successCount > 0) {
                    this.updateStatus(`✅ Successfully retried ${successCount}/${totalFailed} failed images!`, 'success');
                } else {
                    this.updateStatus(`❌ Could not recover any failed images. They may need manual refresh.`, 'error');
                }
            }

            async forceSyncImages() {
                this.updateStatus('🌐 Force syncing all images to local cache...', 'loading');

                let syncedCount = 0;
                const total = this.articles.length;

                for (let i = 0; i < total; i++) {
                    const article = this.articles[i];

                    // Get current image URL
                    let imageUrl = null;
                    if (article.cachedImage && article.cachedImage.url) {
                        imageUrl = article.cachedImage.url;
                    } else {
                        const cached = this.getCachedImage(article);
                        if (cached) {
                            imageUrl = cached;
                        }
                    }

                    if (imageUrl) {
                        try {
                            await this.setArticleImageAndCache(article, i, imageUrl, 'force_sync');
                            syncedCount++;
                        } catch (error) {
                            console.error(`Failed to sync image for article ${i}:`, error);
                        }
                    }

                    // Update progress
                    if (i % 10 === 0) {
                        const progress = Math.round((i / total) * 100);
                        this.updateStatus(`🌐 Syncing images... ${i}/${total} (${progress}%)`, 'loading');
                    }
                }

                // FIXED: Save to local cache immediately
                this.saveLocalCache();

                this.updateStatus(`✅ Force sync complete! ${syncedCount} images synced to local cache.`, 'success');
            }

            showImageHelp() {
                const helpText = `
MyPocket Enhanced Image System Help:
==================================

🖼️ IMAGE FEATURES:

1️⃣ CROSS-DEVICE SYNCHRONIZATION:
   • Images stored in local cache and OneDrive backup as base64 data
   • Automatically synced across all your devices
   • No more missing images when switching devices
   • Smart compression keeps file sizes manageable

2️⃣ INTELLIGENT CACHING:
   • Local cache for instant loading
   • 7-day expiration for fresh content
   • Automatic cleanup of old cached images
   • Memory-efficient storage system

3️⃣ ENHANCED EXTRACTION:
   • Multiple proxy services for better success rates
   • Platform-specific extraction (YouTube, GitHub, etc.)
   • Smart fallback system with category-based images
   • Meta tag analysis for best quality images

4️⃣ IMAGE INDICATORS:
   • 🌐 Synced: Stored for cross-device access
   • 💾 Local Cache: Device-specific cache
   • 📄 Metadata: From article data
   • 🔄 Loading: Being extracted
   • ❌ Failed: Extraction failed

🔧 AVAILABLE ACTIONS:

• 🖼️ Refresh Image: Re-extract image for specific article
• 🔁 Retry Failed: Attempt to recover failed image extractions
• 🌐 Sync Images: Force sync all images to local cache
• 🗑️ Clear Cache: Remove all cached image data

💡 TIPS:

- Images are automatically extracted and synced
- Failed images can be manually refreshed
- Clear cache if experiencing image issues
- Larger images may not sync due to size limits
- Use "Force Sync" to ensure all images are backed up

🎯 IMAGE PRIORITY:

1. Synced base64 data (highest quality, cross-device)
2. Synced URLs (cross-device but less reliable)
3. Local cache (device-specific)
4. Article metadata (extracted from saved data)
5. Real-time extraction (from original website)
6. Smart category-based fallbacks (consistent per article)

The system prioritizes cross-device compatibility while maintaining performance!
                `;

                alert(helpText);
            }

            // Utility functions
            getDomain(url) {
                try {
                    return new URL(url).hostname.replace('www.', '');
                } catch (e) {
                    return url;
                }
            }

            formatDate(dateString) {
                try {
                    const date = new Date(dateString);
                    const now = new Date();
                    const diffMs = now - date;
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

                    if (diffDays === 0) return 'Today';
                    if (diffDays === 1) return 'Yesterday';
                    if (diffDays < 7) return `${diffDays} days ago`;
                    if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
                    if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;

                    return date.toLocaleDateString();
                } catch (e) {
                    return dateString;
                }
            }

            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            sanitizeFilename(filename) {
                return filename.replace(/[^a-z0-9\s-]/gi, '').replace(/\s+/g, '-').toLowerCase();
            }

            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        // Initialize the enhanced web reader when page loads
        let webReader;

        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeWebReader);
        } else {
            initializeWebReader();
        }

        function initializeWebReader() {
            console.log('🚀 Initializing MyPocket FIXED AI-Enhanced Web Reader...');

            try {
                webReader = new MyPocketWebReader();
                console.log('✅ MyPocket FIXED AI-Enhanced Web Reader initialized successfully!');

                // Make it globally available for debugging
                window.webReader = webReader;

                // Add global keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ctrl/Cmd + R: Refresh articles
                    if ((e.ctrlKey || e.metaKey) && e.key === 'r' && !e.shiftKey) {
                        e.preventDefault();
                        if (webReader.accessToken) {
                            webReader.loadFromOneDrive();
                        }
                    }

                    // Ctrl/Cmd + S: Save to OneDrive
                    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                        e.preventDefault();
                        if (webReader.accessToken) {
                            webReader.saveToOneDrive();
                        }
                    }

                    // Ctrl/Cmd + D: Toggle dark mode
                    if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
                        e.preventDefault();
                        webReader.toggleDarkMode();
                    }

                    // Ctrl/Cmd + I: Show debug info
                    if ((e.ctrlKey || e.metaKey) && e.key === 'i') {
                        e.preventDefault();
                        webReader.showDebugInfo();
                    }
                });

            } catch (error) {
                console.error('❌ Failed to initialize MyPocket Web Reader:', error);

                // Show error to user
                const status = document.getElementById('status');
                if (status) {
                    status.textContent = `❌ Initialization failed: ${error.message}`;
                    status.className = 'status error';
                }
            }
        }

        // Global error handler for better debugging
        window.addEventListener('error', (event) => {
            console.error('🚨 Global error:', event.error);

            if (window.webReader) {
                window.webReader.updateStatus(`❌ Error: ${event.error.message}`, 'error');
            }
        });

        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', (event) => {
            console.error('🚨 Unhandled promise rejection:', event.reason);

            if (window.webReader) {
                window.webReader.updateStatus(`❌ Promise error: ${event.reason}`, 'error');
            }
        });

        console.log('🎯 MyPocket AI-Enhanced Web Reader script loaded - FIXED Local Cache + Manual Category Editing + PKCE Security + Cross-Device Images');
    </script>
</body>

</html>
