<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https:; img-src 'self' data: https:; connect-src 'self' https:;">
    <title>MyPocket - AI-Enhanced Web Reader (Improved & Secure)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #ee5a24;
            --secondary-color: #667eea;
            --background: #f8f9fa;
            --surface: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --border: #e9ecef;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.15);
            --success: #27ae60;
            --warning: #f39c12;
            --error: #e74c3c;
        }

        [data-theme="dark"] {
            --primary-color: #ff6b35;
            --secondary-color: #7b88f7;
            --background: #0d1117;
            --surface: #161b22;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --border: #30363d;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.6);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.8);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--background);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header Styles */
        .header {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            color: white;
            padding: 20px 0;
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-left: 60px;
        }

        .logo {
            font-size: 1.8em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* Sidebar Styles */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: var(--surface);
            border-right: 1px solid var(--border);
            z-index: 101;
            overflow-y: auto;
            transition: transform 0.3s ease;
            box-shadow: var(--shadow);
        }

        .sidebar.collapsed {
            transform: translateX(-220px);
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: var(--background);
        }

        .sidebar-brand {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.2em;
            font-weight: 600;
            color: var(--text-primary);
        }

        .sidebar-toggle {
            position: absolute;
            right: -40px;
            top: 20px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0 8px 8px 0;
            padding: 8px;
            cursor: pointer;
            color: var(--text-primary);
            transition: all 0.2s ease;
            z-index: 102;
        }

        .sidebar-toggle:hover {
            background: var(--primary-color);
            color: white;
        }

        .sidebar-nav {
            padding: 20px 0;
        }

        .nav-section {
            margin-bottom: 30px;
        }

        .nav-section-title {
            padding: 0 20px 10px;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            letter-spacing: 0.5px;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            color: var(--text-primary);
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 14px;
        }

        .nav-item:hover {
            background: var(--background);
            color: var(--primary-color);
        }

        .nav-item.active {
            background: var(--primary-color);
            color: white;
            border-right: 3px solid var(--secondary-color);
        }

        .nav-item .icon {
            width: 20px;
            text-align: center;
            font-size: 16px;
        }

        .nav-item .text {
            flex: 1;
        }

        .nav-item .badge {
            background: var(--border);
            color: var(--text-secondary);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: 500;
        }

        .nav-item.active .badge {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        /* Connection Panel */
        .connection-panel {
            padding: 15px 20px;
            margin: 10px 0;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
        }

        .connection-status-sidebar {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9em;
        }

        .connection-status-sidebar.connected {
            color: var(--success);
        }

        .connection-status-sidebar.disconnected {
            color: var(--error);
        }

        .connect-btn-sidebar {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .connect-btn-sidebar:hover {
            background: var(--secondary-color);
            transform: translateY(-1px);
        }

        .connect-btn-sidebar.connected {
            background: var(--success);
        }

        /* Main Content */
        .main-content {
            margin-left: 280px;
            min-height: 100vh;
            transition: margin-left 0.3s ease;
        }

        .main-content.sidebar-collapsed {
            margin-left: 60px;
        }

        /* Button Styles */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
            transform: translateY(-1px);
        }

        /* Search Styles */
        .search-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 90;
            padding: 30px 0;
        }

        .search-container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .search-box {
            position: relative;
            max-width: 600px;
            margin: 0 auto;
        }

        .search-input {
            width: 100%;
            padding: 15px 50px 15px 20px;
            border: 2px solid var(--border);
            border-radius: 25px;
            font-size: 16px;
            background: var(--background);
            transition: border-color 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .search-close-btn {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .search-close-btn:hover {
            background: var(--border);
            color: var(--text-primary);
            transform: translateY(-50%) scale(1.1);
        }

        /* Category Filter Styles */
        .category-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 89;
            padding: 20px 0;
        }

        .category-container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .category-filter {
            max-width: 800px;
            margin: 0 auto;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .category-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.2em;
        }

        .category-close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .category-close-btn:hover {
            background: var(--border);
            color: var(--text-primary);
            transform: scale(1.1);
        }

        .category-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .category-chip {
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
        }

        .category-chip:hover {
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: white;
            transform: translateY(-2px);
        }

        .category-chip.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        .category-chip.show-all {
            background: var(--secondary-color);
            border-color: var(--secondary-color);
            color: white;
            font-weight: 600;
        }

        .category-chip.show-all:hover {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .category-count {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .category-chip:not(.active) .category-count {
            background: var(--border);
            color: var(--text-secondary);
        }

        .category-chip.ai-enhanced {
            border-color: #9c27b0;
            background: linear-gradient(45deg, var(--background), #f3e5f5);
        }

        .category-chip.ai-enhanced:hover {
            background: linear-gradient(45deg, var(--primary-color), #9c27b0);
        }

        .category-chip.ai-enhanced::after {
            content: "🤖";
            font-size: 0.7em;
            margin-left: 4px;
        }

        /* Status Styles */
        .status {
            padding: 20px 0;
            text-align: center;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .status.loading {
            color: var(--secondary-color);
        }

        .status.error {
            color: var(--error);
        }

        .status.success {
            color: var(--success);
        }

        /* Local Cache Status */
        .local-cache-status {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 15px;
            margin: 15px 0;
            font-size: 0.9em;
            text-align: center;
            transition: all 0.3s ease;
        }

        .local-cache-status.has-changes {
            background: #fff3cd;
            border-color: #ffeaa7;
            color: #856404;
        }

        .local-cache-status.synced {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        [data-theme="dark"] .local-cache-status.has-changes {
            background: #3a3019;
            border-color: #675a1a;
            color: #fff3cd;
        }

        [data-theme="dark"] .local-cache-status.synced {
            background: #1a2e1a;
            border-color: #2d5a2d;
            color: #d4edda;
        }

        /* Articles Grid */
        .articles-section {
            padding: 40px 0;
            min-height: 60vh;
        }

        .articles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 18px;
            margin-top: 20px;
        }

        .article-card {
            background: var(--surface);
            border-radius: 32px 24px 32px 24px;
            overflow: visible;
            box-shadow: var(--shadow);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border: 1px solid var(--border);
            position: relative;
            display: flex;
            flex-direction: column;
            transform-origin: center center;
        }

        .article-card:nth-child(3n+1) {
            border-radius: 28px 36px 28px 36px;
        }

        .article-card:nth-child(3n+2) {
            border-radius: 35px 25px 35px 25px;
        }

        .article-card:nth-child(3n+3) {
            border-radius: 30px 30px 40px 20px;
        }

        .article-card:nth-child(4n+1) {
            border-radius: 40px 20px 30px 30px;
        }

        .article-card:nth-child(5n+1) {
            border-radius: 25px 35px 25px 35px;
        }

        .article-card:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-8px) scale(1.02) rotate(1deg);
            border-color: var(--primary-color);
        }

        .article-card:nth-child(even):hover {
            transform: translateY(-8px) scale(1.02) rotate(-1deg);
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
        }

        .article-card.ai-categorized {
            border-color: #9c27b0;
        }

        .article-card.ai-categorized::before {
            content: "🤖 AI";
            position: absolute;
            top: 5px;
            left: 10px;
            background: rgba(156, 39, 176, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7em;
            z-index: 10;
        }

        .article-card.manual-edit::before {
            content: "✏️ Manual";
            position: absolute;
            top: 5px;
            left: 10px;
            background: rgba(25, 135, 84, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7em;
            z-index: 10;
        }

        .article-image {
            width: 100%;
            height: 100px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: white;
            position: relative;
            overflow: hidden;
            border-radius: inherit;
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 16px;
        }

        .article-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.4s ease, opacity 0.3s ease;
        }

        .article-image:hover img {
            transform: scale(1.08);
        }

        .article-content {
            padding: 15px;
            flex: 1;
            cursor: pointer;
            border-radius: 0 0 inherit inherit;
        }

        .article-title {
            font-size: 1em;
            font-weight: 600;
            margin-bottom: 6px;
            line-height: 1.3;
            color: var(--text-primary);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-excerpt {
            color: var(--text-secondary);
            font-size: 0.8em;
            line-height: 1.4;
            margin-bottom: 10px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
            color: var(--text-secondary);
            font-size: 0.75em;
            margin-bottom: 6px;
        }

        .article-domain {
            font-weight: 500;
        }

        .article-date {
            opacity: 0.8;
        }

        .article-stats {
            display: flex;
            gap: 10px;
            font-size: 0.7em;
            color: var(--text-secondary);
        }

        .article-category {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: var(--primary-color);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.65em;
            font-weight: 500;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .article-category:hover {
            background: var(--secondary-color);
            transform: scale(1.05);
        }

        .article-category.ai-category {
            background: linear-gradient(45deg, var(--primary-color), #9c27b0);
        }

        .article-category.manual-edit {
            background: linear-gradient(45deg, #198754, #20c997);
            border: 1px solid #28a745;
        }

        .category-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--surface);
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            box-shadow: var(--shadow-hover);
            z-index: 200;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            min-width: 150px;
        }

        .category-dropdown.visible {
            display: block;
        }

        .category-option {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9em;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--text-primary);
        }

        .category-option:hover {
            background: var(--background);
        }

        .category-option.selected {
            background: var(--primary-color);
            color: white;
        }

        .category-option:last-child {
            border-bottom: none;
        }

        .article-actions {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 6px;
            opacity: 0 !important;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid var(--border);
            border-radius: 50%;
            padding: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            min-width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn:hover {
            transform: translateY(-4px) scale(1.15);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
            border-radius: 40% 60% 70% 30%;
        }

        .read-btn:hover {
            background: #e3f2fd;
            border-color: #2196f3;
            border-radius: 60% 40% 30% 70%;
        }

        .export-btn:hover {
            background: #e8f5e8;
            border-color: #4caf50;
            border-radius: 30% 70% 60% 40%;
        }

        .refresh-image-btn:hover {
            background: #fff3e0;
            border-color: #ff9800;
            border-radius: 40% 60% 40% 60%;
        }

        .delete-btn {
            color: #f44336;
        }

        .delete-btn:hover {
            background: #ffebee;
            border-color: #f44336;
            color: #d32f2f;
            border-radius: 70% 30% 40% 60%;
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
        }

        body.test-mode .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
            background: rgba(255, 255, 0, 0.1);
            border: 2px dashed #ff9800;
            border-radius: 20px;
            padding: 5px;
        }

        .article-actions:hover {
            opacity: 1 !important;
            visibility: visible !important;
        }

        /* Reader View */
        .reader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            overflow-y: auto;
        }

        .reader-overlay.active {
            display: block;
        }

        .reader-container {
            max-width: 800px;
            margin: 40px auto;
            background: var(--surface);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.3);
        }

        .reader-header {
            padding: 30px;
            border-bottom: 1px solid var(--border);
            background: var(--background);
        }

        .reader-title {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 15px;
            line-height: 1.3;
        }

        .reader-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .reader-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .reader-content {
            padding: 40px;
            font-size: 1.1em;
            line-height: 1.8;
            max-width: none;
        }

        .reader-content h1,
        .reader-content h2,
        .reader-content h3 {
            margin: 30px 0 15px;
            color: var(--text-primary);
        }

        .reader-content p {
            margin-bottom: 20px;
        }

        .reader-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
        }

        .reader-content blockquote {
            border-left: 4px solid var(--primary-color);
            margin: 20px 0;
            padding: 15px 20px;
            background: var(--background);
            font-style: italic;
        }

        .close-reader {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-reader:hover {
            border-radius: 30% 70% 70% 30%;
            transform: scale(1.1);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Cache Indicators */
        .cache-indicator {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            z-index: 5;
        }

        .cache-indicator.cached {
            background: rgba(39, 174, 96, 0.8);
        }

        .cache-indicator.fresh {
            background: rgba(52, 152, 219, 0.8);
        }

        .cache-indicator.synced {
            background: rgba(76, 175, 80, 0.8);
            color: white;
        }

        .cache-indicator.fallback {
            background: rgba(255, 152, 0, 0.8);
            color: white;
        }

        .cache-indicator.metadata {
            background: rgba(103, 58, 183, 0.8);
            color: white;
        }

        .cache-indicator.error {
            background: rgba(244, 67, 54, 0.8);
            color: white;
        }

        .cache-indicator.ai-categorized {
            background: rgba(156, 39, 176, 0.9);
            color: white;
        }

        .cache-indicator.smart-categorized {
            background: rgba(103, 58, 183, 0.9);
            color: white;
        }

        /* Progress Overlay */
        .progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1001;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .progress-overlay.visible {
            display: flex;
        }

        .progress-container {
            background: var(--surface);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            box-shadow: var(--shadow-hover);
            text-align: center;
        }

        .progress-title {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: var(--background);
            border-radius: 6px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            border-radius: 6px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-top: 10px;
        }

        .progress-stats {
            font-size: 0.8em;
            color: var(--text-secondary);
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border);
        }

        /* Enhanced Dark Mode Support */
        [data-theme="dark"] .article-card {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .article-card:hover {
            border-color: #484f58;
            transform: translateY(-2px) scale(1.02);
        }

        [data-theme="dark"] .search-input {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .search-input:focus {
            border-color: var(--primary-color);
            background: var(--surface);
        }

        [data-theme="dark"] .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.8;
        }

        [data-theme="dark"] .search-close-btn:hover {
            background: #21262d;
            color: var(--text-primary);
        }

        [data-theme="dark"] .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border-color: var(--border);
        }

        [data-theme="dark"] .btn-secondary:hover {
            background: #21262d;
            border-color: #484f58;
            color: var(--text-primary);
        }

        [data-theme="dark"] .action-btn {
            background: rgba(22, 27, 34, 0.95);
            border-color: var(--border);
            color: var(--text-primary);
            backdrop-filter: blur(10px);
        }

        [data-theme="dark"] .action-btn:hover {
            background: rgba(33, 38, 45, 0.95);
            border-color: #484f58;
        }

        [data-theme="dark"] .category-dropdown {
            background: var(--surface);
            border-color: var(--primary-color);
        }

        [data-theme="dark"] .category-option {
            color: var(--text-primary);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .category-option:hover {
            background: var(--background);
        }

        [data-theme="dark"] .category-option.selected {
            background: var(--primary-color);
            color: white;
        }

        /* Animations */
        @keyframes float {

            0%,
            100% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-6px);
            }
        }

        @keyframes floatPattern {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        @keyframes shimmer {
            0% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.6;
            }
        }

        .article-card:nth-child(7n+1) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 0s;
        }

        .article-card:nth-child(7n+2) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 0.5s;
        }

        .article-card:nth-child(7n+3) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 1s;
        }

        /* Organic gradient backgrounds */
        .article-image:nth-child(odd) {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .article-image:nth-child(3n+1) {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .article-image:nth-child(3n+2) {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .article-image:nth-child(3n+3) {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }

        .article-image:nth-child(5n+1) {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        /* Mobile Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 0 12px;
            }

            .sidebar {
                transform: translateX(-100%);
                width: 100%;
                max-width: 280px;
                z-index: 105;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .sidebar.collapsed {
                transform: translateX(-100%);
            }

            .sidebar-toggle {
                display: none;
            }

            .header {
                padding: 15px 0;
                position: fixed;
                width: 100%;
                top: 0;
                z-index: 104;
            }

            .header-content {
                padding-left: 20px;
                padding-right: 20px;
            }

            .mobile-menu-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 6px;
                color: white;
                padding: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-size: 18px;
                width: 36px;
                height: 36px;
            }

            .mobile-menu-btn:hover {
                background: rgba(255, 255, 255, 0.3);
            }

            .main-content {
                margin-left: 0;
                padding-top: 80px;
            }

            .main-content.sidebar-collapsed {
                margin-left: 0;
            }

            .sidebar-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 103;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s ease;
            }

            .sidebar-overlay.active {
                opacity: 1;
                visibility: visible;
            }

            .logo {
                font-size: 1.4em;
            }

            .header-right {
                gap: 10px;
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
                border-radius: 20px;
            }

            .search-container {
                padding: 20px 0;
                top: 80px;
            }

            .search-input {
                font-size: 16px !important;
                padding: 12px 45px 12px 16px;
                border-radius: 20px;
            }

            .search-close-btn {
                right: 12px;
                width: 28px;
                height: 28px;
                font-size: 16px;
            }

            .category-container {
                padding: 15px 0;
                top: 80px;
            }

            .category-header h3 {
                font-size: 1.1em;
            }

            .category-chips {
                gap: 8px;
            }

            .category-chip {
                padding: 6px 12px;
                font-size: 0.8em;
                border-radius: 16px;
            }

            .category-count {
                font-size: 0.7em;
                padding: 1px 4px;
            }

            .status {
                padding: 15px 0;
                font-size: 14px;
                line-height: 1.4;
            }

            .articles-section {
                padding: 20px 0;
            }

            .articles-grid {
                display: block;
                margin-top: 15px;
            }

            .article-card {
                display: block !important;
                width: 100% !important;
                margin-bottom: 20px !important;
                border-radius: 20px !important;
                overflow: hidden;
                background: var(--surface);
                border: 1px solid var(--border);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                transform: none !important;
                animation: none !important;
            }

            .article-card:hover {
                transform: none !important;
                box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
            }

            .article-image {
                width: 100% !important;
                height: 140px !important;
                border-radius: 20px 20px 0 0 !important;
                position: relative;
            }

            .article-content {
                padding: 20px !important;
                cursor: pointer;
            }

            .article-title {
                font-size: 1.25em !important;
                font-weight: 600;
                margin-bottom: 10px !important;
                line-height: 1.4 !important;
                color: var(--text-primary);
                display: block !important;
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-excerpt {
                font-size: 1em !important;
                line-height: 1.5 !important;
                margin-bottom: 15px !important;
                color: var(--text-secondary);
                display: block !important;
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-meta {
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-wrap: wrap;
                gap: 8px;
                color: var(--text-secondary);
                font-size: 0.9em !important;
                margin-bottom: 10px;
            }

            .article-stats {
                display: flex;
                gap: 15px;
                font-size: 0.85em !important;
                color: var(--text-secondary);
                margin-bottom: 10px;
            }

            .article-category {
                font-size: 0.8em !important;
                padding: 4px 10px;
                margin-bottom: 10px;
            }

            .article-actions {
                position: static !important;
                opacity: 1 !important;
                visibility: visible !important;
                display: flex !important;
                justify-content: center;
                gap: 12px;
                padding: 15px 20px;
                background: var(--background);
                border-radius: 0;
                margin: 0;
                border-top: 1px solid var(--border);
            }

            .action-btn {
                min-width: 45px !important;
                height: 45px !important;
                font-size: 18px !important;
                border-radius: 50% !important;
                padding: 0;
                background: var(--surface);
                border: 2px solid var(--border);
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .action-btn:hover,
            .action-btn:active {
                border-radius: 50% !important;
                transform: scale(1.05);
                background: var(--primary-color);
                color: white;
                border-color: var(--primary-color);
            }

            .reader-overlay {
                padding: 0;
                z-index: 106;
            }

            .reader-container {
                margin: 0 !important;
                border-radius: 0 !important;
                height: 100vh;
                max-width: none;
                display: flex;
                flex-direction: column;
            }

            .reader-header {
                padding: 20px;
                border-radius: 0;
                flex-shrink: 0;
            }

            .reader-title {
                font-size: 1.4em !important;
                line-height: 1.3;
                margin-bottom: 15px;
            }

            .reader-meta {
                font-size: 0.9em;
                gap: 15px;
            }

            .reader-content {
                padding: 20px;
                font-size: 1.1em !important;
                line-height: 1.7 !important;
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            .close-reader {
                top: 15px;
                right: 15px;
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .empty-state {
                padding: 40px 20px;
            }

            .empty-state-icon {
                font-size: 3em;
                margin-bottom: 15px;
            }

            .empty-state h3 {
                font-size: 1.3em;
                margin-bottom: 8px;
            }

            .empty-state p {
                font-size: 1em;
                line-height: 1.5;
            }

            .progress-container {
                max-width: 350px;
                padding: 25px;
            }

            .progress-title {
                font-size: 1.1em;
            }

            .category-dropdown {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 280px;
                max-height: 300px;
                border-radius: 12px;
            }
        }

        @media (max-width: 480px) {
            .article-title {
                font-size: 1.15em !important;
            }

            .article-excerpt {
                font-size: 0.95em !important;
            }

            .article-content {
                padding: 16px !important;
            }

            .header-actions {
                gap: 6px;
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
            }
        }
    </style>
</head>

<body>
    <!-- Left Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-brand">
                <span>🤖</span>
                <span>MyPocket AI</span>
            </div>
        </div>

        <!-- Connection Status -->
        <div class="connection-panel">
            <div class="connection-status-sidebar" id="connectionStatusSidebar">
                <span id="connectionIcon">🔐</span>
                <span id="connectionText">Not Connected</span>
            </div>
            <button id="connectBtnSidebar" class="connect-btn-sidebar">
                Secure Connect
            </button>
        </div>

        <!-- Navigation -->
        <nav class="sidebar-nav">
            <!-- Main Actions -->
            <div class="nav-section">
                <div class="nav-section-title">Library</div>
                <button class="nav-item" id="allArticlesNav" onclick="webReader.showAllArticles()">
                    <span class="icon">📖</span>
                    <span class="text">All Articles</span>
                    <span class="badge" id="allArticlesBadge">0</span>
                </button>
                <button class="nav-item" id="searchNavBtn" onclick="webReader.toggleSearch()">
                    <span class="icon">🔍</span>
                    <span class="text">Search</span>
                </button>
                <button class="nav-item" id="categoriesNavBtn" onclick="webReader.toggleCategoryFilter()">
                    <span class="icon">🤖</span>
                    <span class="text">AI Categories</span>
                    <span class="badge" id="categoryBadge">0</span>
                </button>
            </div>

            <!-- Data Management Tools -->
            <div class="nav-section">
                <div class="nav-section-title">Data</div>
                <button class="nav-item" id="refreshNavBtn" onclick="webReader.loadFromOneDrive()">
                    <span class="icon">☁️</span>
                    <span class="text">Load from OneDrive</span>
                </button>
                <button class="nav-item" id="saveNavBtn" onclick="webReader.saveToOneDrive()">
                    <span class="icon">💾</span>
                    <span class="text">Save to OneDrive</span>
                </button>
                <button class="nav-item" id="autoSaveNavBtn" onclick="webReader.toggleAutoSave()">
                    <span class="icon">🔄</span>
                    <span class="text">Auto-Save: <span id="autoSaveStatus">OFF</span></span>
                </button>
            </div>

            <!-- Tools -->
            <div class="nav-section">
                <div class="nav-section-title">Tools</div>
                <button class="nav-item" id="syncNavBtn" onclick="webReader.forceSyncImages()">
                    <span class="icon">🌐</span>
                    <span class="text">Sync Images</span>
                </button>
                <button class="nav-item" id="retryNavBtn" onclick="webReader.retryFailedImages()">
                    <span class="icon">🔁</span>
                    <span class="text">Retry Failed</span>
                </button>
                <button class="nav-item" onclick="webReader.clearImageCache()">
                    <span class="icon">🗑️</span>
                    <span class="text">Clear Cache</span>
                </button>
                <button class="nav-item" id="recategorizeBtn" onclick="webReader.recategorizeAllWithAI()">
                    <span class="icon">🧠</span>
                    <span class="text">AI Re-categorize</span>
                </button>
            </div>

            <!-- Settings -->
            <div class="nav-section">
                <div class="nav-section-title">Settings</div>
                <button class="nav-item" onclick="webReader.toggleDarkMode()">
                    <span class="icon" id="darkModeIcon">🌙</span>
                    <span class="text" id="darkModeText">Dark Mode</span>
                </button>
                <button class="nav-item" onclick="webReader.toggleTestMode()">
                    <span class="icon">👁️</span>
                    <span class="text">Show Buttons</span>
                </button>
                <button class="nav-item" onclick="webReader.showImageHelp()">
                    <span class="icon">❓</span>
                    <span class="text">Image Help</span>
                </button>
                <button class="nav-item" onclick="webReader.showAIHelp()">
                    <span class="icon">🤖</span>
                    <span class="text">AI Categories Help</span>
                </button>
                <button class="nav-item" onclick="webReader.showDebugInfo()">
                    <span class="icon">🔧</span>
                    <span class="text">Debug Info</span>
                </button>
            </div>
        </nav>

        <!-- Sidebar Toggle -->
        <button class="sidebar-toggle" id="sidebarToggle" onclick="webReader.toggleSidebar()">
            <span id="sidebarToggleIcon">◀</span>
        </button>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="webReader.closeMobileSidebar()"></div>

    <!-- Main Content Area -->
    <div class="main-content" id="mainContent">
        <!-- Header -->
        <header class="header">
            <div class="container">
                <div class="header-content">
                    <!-- Mobile Menu Button -->
                    <button class="mobile-menu-btn" id="mobileMenuBtn" onclick="webReader.openMobileSidebar()"
                        style="display: none;">
                        <span>☰</span>
                    </button>

                    <div class="logo">
                        MyPocket AI Reader (Improved & Secure)
                    </div>

                    <div class="header-right">
                        <span id="headerStatus" class="header-status">🔒 Secure & Optimized!</span>
                    </div>
                </div>
            </div>
        </header>

        <!-- Local Cache Status -->
        <div class="local-cache-status" id="localCacheStatus" style="display: none;">
            <span id="cacheStatusText">📦 Using improved storage system!</span>
        </div>

        <!-- Search (Initially Hidden) -->
        <section class="search-container" id="searchContainer" style="display: none;">
            <div class="container">
                <div class="search-box">
                    <input type="text" id="searchInput" class="search-input"
                        placeholder="Search your saved articles... (🤖 AI-powered)" autocomplete="off">
                    <button class="search-close-btn" onclick="webReader.toggleSearch()" title="Close search">✕</button>
                </div>
            </div>
        </section>

        <!-- Category Filter (Initially Hidden) -->
        <section class="category-container" id="categoryContainer" style="display: none;">
            <div class="container">
                <div class="category-filter">
                    <div class="category-header">
                        <h3>🤖 AI-Enhanced Categories</h3>
                        <button class="category-close-btn" onclick="webReader.toggleCategoryFilter()"
                            title="Close categories">✕</button>
                    </div>
                    <div class="category-chips" id="categoryChips">
                        <!-- Categories will be populated here -->
                    </div>
                </div>
            </div>
        </section>

        <!-- Status -->
        <div class="status" id="status">
            🔒 Ready with improved security and storage! Connect to OneDrive to sync your articles.
        </div>

        <!-- Articles -->
        <section class="articles-section">
            <div class="container">
                <div id="articlesContainer">
                    <div class="empty-state">
                        <div class="empty-state-icon">🔒</div>
                        <h3>Welcome to MyPocket AI Reader (Improved)</h3>
                        <p>Connect to OneDrive to access your saved articles with enhanced security, improved storage,
                            and intelligent AI categorization!</p>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <!-- Reader Overlay -->
    <div class="reader-overlay" id="readerOverlay">
        <div class="reader-container">
            <button class="close-reader" id="closeReader">✕</button>
            <div class="reader-header">
                <h1 class="reader-title" id="readerTitle">Article Title</h1>
                <div class="reader-meta" id="readerMeta">
                    <span>📅 <span id="readerDate">Date</span></span>
                    <span>🌐 <span id="readerDomain">Domain</span></span>
                    <span>⏱️ <span id="readerTime">5 min read</span></span>
                </div>
                <div class="reader-actions">
                    <button class="btn btn-secondary" id="openOriginal">
                        🔗 Open Original
                    </button>
                </div>
            </div>
            <div class="reader-content" id="readerContent">
                Article content will appear here...
            </div>
        </div>
    </div>

    <!-- Progress Overlay for Recategorization -->
    <div class="progress-overlay" id="progressOverlay">
        <div class="progress-container">
            <div class="progress-title">🧠 AI Re-categorization in Progress</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Initializing AI analysis...</div>
            <div class="progress-stats" id="progressStats">
                Processing articles with enhanced categorization...
            </div>
        </div>
    </div>

    <script>
        'use strict';

        console.log('🚀 MyPocket AI-Enhanced Web Reader (Improved & Secure) starting...');

        // Enhanced Error Handling
        class ErrorHandler {
            static handleError(error, context = 'Unknown') {
                console.error(`❌ Error in ${context}:`, error);

                if (window.webReader && webReader.updateStatus) {
                    webReader.updateStatus(`❌ Error in ${context}: ${error.message}`, 'error');
                }

                // Report critical errors
                if (error.name === 'SecurityError' || error.name === 'NotAllowedError') {
                    console.error('🔒 Security error detected:', error);
                }
            }

            static async safeAsync(asyncFn, context = 'Async Operation') {
                try {
                    return await asyncFn();
                } catch (error) {
                    this.handleError(error, context);
                    return null;
                }
            }

            static safe(fn, context = 'Operation') {
                try {
                    return fn();
                } catch (error) {
                    this.handleError(error, context);
                    return null;
                }
            }
        }

        // Improved Storage Manager using IndexedDB
        class ImprovedStorageManager {
            constructor() {
                this.dbName = 'MyPocketDB';
                this.version = 1;
                this.db = null;
                this.isSupported = this.checkSupport();
            }

            checkSupport() {
                if (!window.indexedDB) {
                    console.warn('⚠️ IndexedDB not supported, falling back to localStorage');
                    return false;
                }
                return true;
            }

            async initDB() {
                if (!this.isSupported) return false;

                try {
                    return new Promise((resolve, reject) => {
                        const request = indexedDB.open(this.dbName, this.version);

                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => {
                            this.db = request.result;
                            console.log('✅ IndexedDB initialized successfully');
                            resolve(this.db);
                        };

                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;

                            // Create object stores
                            if (!db.objectStoreNames.contains('articles')) {
                                const articlesStore = db.createObjectStore('articles', { keyPath: 'id' });
                                articlesStore.createIndex('category', 'category', { unique: false });
                                articlesStore.createIndex('dateAdded', 'dateAdded', { unique: false });
                                console.log('📦 Created articles store');
                            }

                            if (!db.objectStoreNames.contains('images')) {
                                const imagesStore = db.createObjectStore('images', { keyPath: 'articleId' });
                                imagesStore.createIndex('timestamp', 'timestamp', { unique: false });
                                console.log('🖼️ Created images store');
                            }

                            if (!db.objectStoreNames.contains('metadata')) {
                                const metadataStore = db.createObjectStore('metadata', { keyPath: 'key' });
                                console.log('📊 Created metadata store');
                            }
                        };
                    });
                } catch (error) {
                    console.error('❌ IndexedDB initialization failed:', error);
                    return false;
                }
            }

            async storeArticles(articles) {
                if (!this.db && !(await this.initDB())) {
                    return this.fallbackStoreArticles(articles);
                }

                try {
                    const transaction = this.db.transaction(['articles'], 'readwrite');
                    const store = transaction.objectStore('articles');

                    // Clear existing articles
                    await store.clear();

                    // Store articles without images (keep them separate)
                    for (const article of articles) {
                        const articleCopy = { ...article };
                        delete articleCopy.cachedImage; // Store images separately
                        articleCopy.id = this.generateArticleId(article);

                        await store.add(articleCopy);
                    }

                    console.log(`💾 Stored ${articles.length} articles in IndexedDB`);
                    return true;
                } catch (error) {
                    console.error('❌ Failed to store articles in IndexedDB:', error);
                    return this.fallbackStoreArticles(articles);
                }
            }

            async storeImage(articleId, imageData) {
                if (!this.db && !(await this.initDB())) {
                    return false;
                }

                try {
                    const transaction = this.db.transaction(['images'], 'readwrite');
                    const store = transaction.objectStore('images');

                    const imageRecord = {
                        articleId,
                        data: imageData,
                        timestamp: Date.now()
                    };

                    await store.put(imageRecord);
                    console.log(`🖼️ Stored image for article: ${articleId}`);
                    return true;
                } catch (error) {
                    console.error('❌ Failed to store image:', error);
                    return false;
                }
            }

            async storeMetadata(key, data) {
                if (!this.db && !(await this.initDB())) {
                    return this.setSmallData(`metadata_${key}`, data);
                }

                try {
                    const transaction = this.db.transaction(['metadata'], 'readwrite');
                    const store = transaction.objectStore('metadata');

                    await store.put({ key, data, timestamp: Date.now() });
                    return true;
                } catch (error) {
                    console.error('❌ Failed to store metadata:', error);
                    return this.setSmallData(`metadata_${key}`, data);
                }
            }

            async getArticles() {
                if (!this.db && !(await this.initDB())) {
                    return this.fallbackGetArticles();
                }

                try {
                    const transaction = this.db.transaction(['articles'], 'readonly');
                    const store = transaction.objectStore('articles');

                    return new Promise((resolve, reject) => {
                        const request = store.getAll();
                        request.onsuccess = () => {
                            console.log(`📖 Retrieved ${request.result.length} articles from IndexedDB`);
                            resolve(request.result);
                        };
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('❌ Failed to get articles from IndexedDB:', error);
                    return this.fallbackGetArticles();
                }
            }

            async getImage(articleId) {
                if (!this.db && !(await this.initDB())) {
                    return null;
                }

                try {
                    const transaction = this.db.transaction(['images'], 'readonly');
                    const store = transaction.objectStore('images');

                    return new Promise((resolve, reject) => {
                        const request = store.get(articleId);
                        request.onsuccess = () => {
                            const result = request.result;
                            if (result && Date.now() - result.timestamp < 7 * 24 * 60 * 60 * 1000) {
                                resolve(result.data);
                            } else {
                                resolve(null);
                            }
                        };
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('❌ Failed to get image:', error);
                    return null;
                }
            }

            async getMetadata(key) {
                if (!this.db && !(await this.initDB())) {
                    return this.getSmallData(`metadata_${key}`);
                }

                try {
                    const transaction = this.db.transaction(['metadata'], 'readonly');
                    const store = transaction.objectStore('metadata');

                    return new Promise((resolve, reject) => {
                        const request = store.get(key);
                        request.onsuccess = () => {
                            const result = request.result;
                            resolve(result ? result.data : null);
                        };
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('❌ Failed to get metadata:', error);
                    return this.getSmallData(`metadata_${key}`);
                }
            }

            async clearOldImages() {
                if (!this.db && !(await this.initDB())) {
                    return false;
                }

                try {
                    const sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
                    const transaction = this.db.transaction(['images'], 'readwrite');
                    const store = transaction.objectStore('images');
                    const index = store.index('timestamp');

                    const range = IDBKeyRange.upperBound(sevenDaysAgo);
                    const request = index.openCursor(range);

                    let deletedCount = 0;
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            cursor.delete();
                            deletedCount++;
                            cursor.continue();
                        }
                    };

                    console.log(`🗑️ Cleared ${deletedCount} old images`);
                    return true;
                } catch (error) {
                    console.error('❌ Failed to clear old images:', error);
                    return false;
                }
            }

            generateArticleId(article) {
                return `${article.url}_${article.title}`.replace(/[^a-zA-Z0-9]/g, '_');
            }

            // Fallback methods using localStorage
            fallbackStoreArticles(articles) {
                try {
                    const articlesWithoutImages = articles.map(article => {
                        const copy = { ...article };
                        delete copy.cachedImage;
                        return copy;
                    });

                    const jsonData = JSON.stringify(articlesWithoutImages);
                    if (jsonData.length < 5000000) { // 5MB limit
                        localStorage.setItem('mypocket_articles_fallback', jsonData);
                        console.log('💾 Stored articles in localStorage fallback');
                        return true;
                    } else {
                        console.warn('⚠️ Articles too large for localStorage fallback');
                        return false;
                    }
                } catch (error) {
                    console.error('❌ Fallback storage failed:', error);
                    return false;
                }
            }

            fallbackGetArticles() {
                try {
                    const data = localStorage.getItem('mypocket_articles_fallback');
                    return data ? JSON.parse(data) : [];
                } catch (error) {
                    console.error('❌ Fallback retrieval failed:', error);
                    return [];
                }
            }

            setSmallData(key, data) {
                try {
                    const jsonData = JSON.stringify(data);
                    if (jsonData.length < 50000) { // 50KB limit
                        localStorage.setItem(key, jsonData);
                        return true;
                    }
                } catch (e) {
                    console.warn('Cannot store in localStorage:', e);
                }
                return false;
            }

            getSmallData(key) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : null;
                } catch (e) {
                    console.warn('Cannot read from localStorage:', e);
                    return null;
                }
            }

            async getStorageStats() {
                const stats = {
                    indexedDBSupported: this.isSupported,
                    indexedDBConnected: !!this.db,
                    articlesCount: 0,
                    imagesCount: 0,
                    localStorageUsage: 0
                };

                if (this.db) {
                    try {
                        const articles = await this.getArticles();
                        stats.articlesCount = articles.length;

                        const transaction = this.db.transaction(['images'], 'readonly');
                        const store = transaction.objectStore('images');
                        const countRequest = store.count();
                        stats.imagesCount = await new Promise(resolve => {
                            countRequest.onsuccess = () => resolve(countRequest.result);
                        });
                    } catch (error) {
                        console.error('❌ Failed to get storage stats:', error);
                    }
                }

                // Calculate localStorage usage
                try {
                    let totalSize = 0;
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        totalSize += (value ? value.length : 0);
                    }
                    stats.localStorageUsage = Math.round(totalSize / 1024); // KB
                } catch (error) {
                    console.error('❌ Failed to calculate localStorage usage:', error);
                }

                return stats;
            }
        }

        // Memory Manager for efficient resource handling
        class MemoryManager {
            constructor(maxMemoryMB = 50) {
                this.maxMemoryMB = maxMemoryMB;
                this.currentMemoryMB = 0;
                this.imageReferences = new Map();
                console.log(`💾 Memory Manager initialized with ${maxMemoryMB}MB limit`);
            }

            estimateImageSize(base64String) {
                if (!base64String) return 0;
                return (base64String.length * 0.75) / 1024; // Return KB
            }

            canAddImage(sizeKB) {
                const wouldExceed = (this.currentMemoryMB + sizeKB / 1024) > this.maxMemoryMB;
                if (wouldExceed) {
                    console.warn(`⚠️ Would exceed memory limit: ${this.currentMemoryMB + sizeKB / 1024}MB > ${this.maxMemoryMB}MB`);
                }
                return !wouldExceed;
            }

            addImage(articleId, base64Data, url) {
                const sizeKB = this.estimateImageSize(base64Data);

                this.removeImage(articleId);

                if (!this.canAddImage(sizeKB)) {
                    console.log(`🧹 Cleaning up memory to make space for ${sizeKB}KB image`);
                    this.cleanup();
                }

                if (this.canAddImage(sizeKB)) {
                    this.imageReferences.set(articleId, {
                        sizeKB: sizeKB,
                        url: url,
                        timestamp: Date.now()
                    });
                    this.currentMemoryMB += sizeKB / 1024;
                    console.log(`✅ Added ${sizeKB}KB image. Total memory: ${this.currentMemoryMB.toFixed(1)}MB`);
                    return true;
                }

                console.warn(`❌ Cannot add ${sizeKB}KB image - would exceed memory limit`);
                return false;
            }

            removeImage(articleId) {
                const existing = this.imageReferences.get(articleId);
                if (existing) {
                    this.currentMemoryMB -= existing.sizeKB / 1024;
                    this.imageReferences.delete(articleId);
                    console.log(`🗑️ Removed ${existing.sizeKB}KB image. Remaining: ${this.currentMemoryMB.toFixed(1)}MB`);
                    return true;
                }
                return false;
            }

            cleanup() {
                if (this.imageReferences.size === 0) return;

                const entries = Array.from(this.imageReferences.entries());
                const toRemove = Math.max(1, Math.floor(entries.length * 0.25));

                console.log(`🧹 Cleaning up ${toRemove} oldest images from memory`);

                entries
                    .sort((a, b) => a[1].timestamp - b[1].timestamp)
                    .slice(0, toRemove)
                    .forEach(([articleId, data]) => {
                        this.removeImage(articleId);
                    });
            }

            getMemoryStats() {
                return {
                    currentMB: this.currentMemoryMB,
                    maxMB: this.maxMemoryMB,
                    usagePercent: Math.round((this.currentMemoryMB / this.maxMemoryMB) * 100),
                    imageCount: this.imageReferences.size,
                    canAddMore: this.currentMemoryMB < (this.maxMemoryMB * 0.9)
                };
            }
        }

        // Secure Token Manager
        class SecureTokenManager {
            constructor() {
                this.tokenKey = 'mypocket_access_token';
                this.refreshTokenKey = 'mypocket_refresh_token';
                this.timestampKey = 'mypocket_token_timestamp';
            }

            saveToken(token, expiresIn = 3600) {
                try {
                    // Use sessionStorage for access tokens (more secure)
                    sessionStorage.setItem(this.tokenKey, token);
                    sessionStorage.setItem(this.timestampKey, Date.now().toString());
                    console.log('🔒 Access token saved securely');
                } catch (error) {
                    console.error('❌ Failed to save token:', error);
                }
            }

            getToken() {
                try {
                    return sessionStorage.getItem(this.tokenKey);
                } catch (error) {
                    console.error('❌ Failed to get token:', error);
                    return null;
                }
            }

            saveRefreshToken(refreshToken) {
                try {
                    // Store refresh token in localStorage (longer term)
                    localStorage.setItem(this.refreshTokenKey, refreshToken);
                    console.log('🔒 Refresh token saved');
                } catch (error) {
                    console.error('❌ Failed to save refresh token:', error);
                }
            }

            getRefreshToken() {
                try {
                    return localStorage.getItem(this.refreshTokenKey);
                } catch (error) {
                    console.error('❌ Failed to get refresh token:', error);
                    return null;
                }
            }

            isTokenExpired() {
                try {
                    const timestamp = sessionStorage.getItem(this.timestampKey);
                    if (!timestamp) return true;

                    const tokenAge = Date.now() - parseInt(timestamp);
                    const oneHour = 60 * 60 * 1000;
                    return tokenAge > oneHour;
                } catch (error) {
                    console.error('❌ Failed to check token expiry:', error);
                    return true;
                }
            }

            clearTokens() {
                try {
                    sessionStorage.removeItem(this.tokenKey);
                    sessionStorage.removeItem(this.timestampKey);
                    localStorage.removeItem(this.refreshTokenKey);
                    console.log('🗑️ All tokens cleared');
                } catch (error) {
                    console.error('❌ Failed to clear tokens:', error);
                }
            }
        }

        // Main MyPocket Web Reader Class (Improved)
        class MyPocketWebReader {
            constructor() {
                console.log('🏗️ Creating Improved & Secure MyPocketWebReader instance...');

                // Security
                this.clientId = '436e8796-8c40-47c3-9ad5-b8882f3ef7f7';
                this.redirectUri = this.getRedirectUri();
                this.tokenManager = new SecureTokenManager();
                this.accessToken = null;

                // Storage
                this.storageManager = new ImprovedStorageManager();
                this.memoryManager = new MemoryManager(50); // 50MB limit

                // Data
                this.articles = [];
                this.currentDisplayedArticles = [];
                this.currentArticle = null;

                // AI Categorization
                this.categories = new Map();
                this.activeCategory = null;
                this.categoryKeywords = this.initializeAIEnhancedCategoryKeywords();
                this.aiCategoriesEnabled = true;
                this.categorySynonyms = this.initializeCategorySynonyms();
                this.categoryAnalytics = new Map();
                this.contextPhrases = this.initializeContextPhrases();
                this.negativeKeywords = this.initializeNegativeKeywords();

                // Cache System
                this.imageCache = new Map();
                this.failedImages = new Set();
                this.cacheExpiryDays = 7;

                // Local Cache System
                this.autoSaveEnabled = false;
                this.hasUnsavedChanges = false;
                this.lastOneDriveSyncHash = null;
                this.manuallyEditedArticles = new Set();

                // PKCE
                this.codeVerifier = null;
                this.codeChallenge = null;
                this.state = null;

                // Progress
                this.isRecategorizing = false;
                this.recategorizationProgress = 0;

                // Configuration
                this.storeImagesInBackup = true;
                this.maxImageSizeKB = 500;
                this.cacheSaveTimeout = null;

                console.log('✅ Improved & Secure MyPocketWebReader constructor complete');
                this.init();
            }

            getRedirectUri() {
                const currentUrl = window.location.href;
                const baseUrl = currentUrl.split('#')[0].split('?')[0];

                if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {
                    return baseUrl;
                } else {
                    return window.location.origin + window.location.pathname;
                }
            }

            async init() {
                console.log('🚀 Initializing Improved & Secure MyPocket Web Reader...');

                try {
                    await this.setupEventListeners();
                    this.checkAuthFromURL();
                    this.loadStoredToken();
                    this.loadThemePreference();
                    await this.loadImageCache();
                    this.initializeSidebar();
                    await this.loadLocalCache();
                    this.updateAutoSaveStatus();

                    console.log('✅ Improved & Secure initialization complete');
                } catch (error) {
                    ErrorHandler.handleError(error, 'Initialization');
                }
            }

            async setupEventListeners() {
                console.log('🔧 Setting up event listeners...');

                try {
                    // Sidebar connect button
                    const connectBtnSidebar = document.getElementById('connectBtnSidebar');
                    if (connectBtnSidebar) {
                        connectBtnSidebar.addEventListener('click', () => {
                            console.log('🔐 Connect button clicked');
                            this.authenticate();
                        });
                        console.log('✅ Connect button event listener added');
                    }

                    // Navigation buttons
                    const buttons = [
                        { id: 'refreshNavBtn', handler: () => this.loadFromOneDrive() },
                        { id: 'saveNavBtn', handler: () => this.saveToOneDrive() },
                        { id: 'syncNavBtn', handler: () => this.forceSyncImages() },
                        { id: 'retryNavBtn', handler: () => this.retryFailedImages() }
                    ];

                    buttons.forEach(({ id, handler }) => {
                        const element = document.getElementById(id);
                        if (element) {
                            element.addEventListener('click', () => ErrorHandler.safeAsync(handler, `${id} click`));
                        }
                    });

                    // Search functionality
                    const searchInput = document.getElementById('searchInput');
                    if (searchInput) {
                        let searchTimeout;
                        searchInput.addEventListener('input', (e) => {
                            clearTimeout(searchTimeout);
                            searchTimeout = setTimeout(() => {
                                this.searchArticles(e.target.value);
                            }, 300); // Debounce search
                        });
                    }

                    // Reader functionality
                    const closeReader = document.getElementById('closeReader');
                    if (closeReader) {
                        closeReader.addEventListener('click', () => this.closeReader());
                    }

                    const openOriginal = document.getElementById('openOriginal');
                    if (openOriginal) {
                        openOriginal.addEventListener('click', () => this.openOriginal());
                    }

                    // Keyboard shortcuts
                    document.addEventListener('keydown', (e) => this.handleKeyboardShortcuts(e));

                    // Click outside handlers
                    document.addEventListener('click', (e) => this.handleOutsideClicks(e));

                    // Mobile menu setup
                    this.setupMobileMenu();

                    console.log('✅ Event listeners setup complete');
                } catch (error) {
                    ErrorHandler.handleError(error, 'Event Listeners Setup');
                }
            }

            handleKeyboardShortcuts(e) {
                try {
                    // Ctrl/Cmd + K or / to open search
                    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                        e.preventDefault();
                        this.toggleSearch(true);
                    } else if (e.key === '/' && !this.isInputFocused()) {
                        e.preventDefault();
                        this.toggleSearch(true);
                    } else if (e.key === 'Escape') {
                        this.toggleSearch(false);
                        this.toggleCategoryFilter(false);
                        this.closeMobileSidebar();
                    }

                    // Additional shortcuts
                    if ((e.ctrlKey || e.metaKey) && e.key === 'r' && !e.shiftKey) {
                        e.preventDefault();
                        if (this.accessToken) {
                            this.loadFromOneDrive();
                        }
                    }

                    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                        e.preventDefault();
                        if (this.accessToken) {
                            this.saveToOneDrive();
                        }
                    }

                    if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
                        e.preventDefault();
                        this.toggleDarkMode();
                    }
                } catch (error) {
                    ErrorHandler.handleError(error, 'Keyboard Shortcuts');
                }
            }

            handleOutsideClicks(e) {
                try {
                    // Close search when clicking outside
                    const searchContainer = document.getElementById('searchContainer');
                    const searchNavBtn = document.getElementById('searchNavBtn');

                    if (searchContainer && searchNavBtn &&
                        searchContainer.style.display !== 'none' &&
                        !searchContainer.contains(e.target) &&
                        !searchNavBtn.contains(e.target)) {
                        this.toggleSearch(false);
                    }

                    // Close category filter when clicking outside
                    const categoryContainer = document.getElementById('categoryContainer');
                    const categoriesNavBtn = document.getElementById('categoriesNavBtn');

                    if (categoryContainer && categoriesNavBtn &&
                        categoryContainer.style.display !== 'none' &&
                        !categoryContainer.contains(e.target) &&
                        !categoriesNavBtn.contains(e.target)) {
                        this.toggleCategoryFilter(false);
                    }

                    // Close category dropdowns when clicking outside
                    if (!e.target.closest('.article-category') && !e.target.closest('.category-dropdown')) {
                        document.querySelectorAll('.category-dropdown.visible').forEach(dropdown => {
                            dropdown.classList.remove('visible');
                        });
                    }
                } catch (error) {
                    ErrorHandler.handleError(error, 'Outside Clicks');
                }
            }

            // Enhanced Local Cache System
            async loadLocalCache() {
                console.log('💾 Loading articles from improved storage...');

                try {
                    const articles = await this.storageManager.getArticles();
                    const metadata = await this.storageManager.getMetadata('cache_info');

                    if (articles && articles.length > 0) {
                        this.articles = articles;

                        if (metadata) {
                            this.lastOneDriveSyncHash = metadata.syncHash;
                            this.manuallyEditedArticles = new Set(metadata.manuallyEdited || []);
                        }

                        // Load images from improved storage
                        await this.loadImagesFromStorage();

                        console.log(`💾 Loaded ${articles.length} articles from improved storage`);
                        console.log(`✏️ ${this.manuallyEditedArticles.size} manually edited articles tracked`);

                        this.updateLocalCacheStatus('synced', `💾 ${articles.length} articles loaded from improved storage`);
                        await this.recategorizeAllArticles();
                        this.displayArticles(this.articles);
                        this.updateArticleCounts();
                        this.updateStatus(`💾 Loaded ${articles.length} articles with improved storage`, 'success');
                    } else {
                        console.log('💾 No cached articles found in improved storage');
                    }
                } catch (error) {
                    ErrorHandler.handleError(error, 'Load Local Cache');
                    this.updateStatus('⚠️ Error loading from improved storage', 'error');
                }
            }

            async loadImagesFromStorage() {
                for (const article of this.articles) {
                    try {
                        const articleId = this.storageManager.generateArticleId(article);
                        const imageData = await this.storageManager.getImage(articleId);

                        if (imageData) {
                            article.cachedImage = imageData;
                        }
                    } catch (error) {
                        console.warn(`Failed to load image for article ${article.title}:`, error);
                    }
                }
            }

            async saveLocalCache() {
                try {
                    console.log('💾 Saving to improved storage...');

                    // Store articles
                    const success = await this.storageManager.storeArticles(this.articles);

                    if (success) {
                        // Store metadata
                        const metadata = {
                            syncHash: this.calculateArticlesHash(),
                            manuallyEdited: Array.from(this.manuallyEditedArticles),
                            timestamp: Date.now(),
                            version: '8.0-improved'
                        };

                        await this.storageManager.storeMetadata('cache_info', metadata);

                        // Store images separately
                        for (const article of this.articles) {
                            if (article.cachedImage) {
                                const articleId = this.storageManager.generateArticleId(article);
                                await this.storageManager.storeImage(articleId, article.cachedImage);
                            }
                        }

                        this.hasUnsavedChanges = false;
                        this.updateLocalCacheStatus('synced', `💾 Improved storage: ${this.articles.length} articles saved`);
                        console.log(`✅ Saved ${this.articles.length} articles to improved storage`);
                    } else {
                        throw new Error('Failed to save articles to improved storage');
                    }
                } catch (error) {
                    ErrorHandler.handleError(error, 'Save Local Cache');
                    this.updateStatus('⚠️ Error saving to improved storage', 'error');
                }
            }

            calculateArticlesHash() {
                const articlesString = JSON.stringify(this.articles.map(a => ({
                    url: a.url,
                    title: a.title,
                    category: a.category,
                    dateAdded: a.dateAdded
                })));
                return this.simpleHash(articlesString);
            }

            simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return hash;
            }

            markAsManuallyEdited(article) {
                const articleId = this.storageManager.generateArticleId(article);
                this.manuallyEditedArticles.add(articleId);
                this.hasUnsavedChanges = true;

                // Save to improved storage immediately
                this.saveLocalCache();

                // Auto-save to OneDrive if enabled
                if (this.autoSaveEnabled && this.accessToken) {
                    setTimeout(() => {
                        this.saveToOneDrive();
                    }, 2000);
                } else {
                    this.updateLocalCacheStatus('has-changes', `✏️ Manual changes saved locally (${this.manuallyEditedArticles.size} edited articles)`);
                }
            }

            updateLocalCacheStatus(status, message) {
                const statusElement = document.getElementById('localCacheStatus');
                const textElement = document.getElementById('cacheStatusText');

                if (statusElement && textElement) {
                    statusElement.style.display = 'block';
                    textElement.textContent = message;

                    statusElement.className = 'local-cache-status';
                    if (status === 'has-changes') {
                        statusElement.classList.add('has-changes');
                    } else if (status === 'synced') {
                        statusElement.classList.add('synced');
                    }
                }
            }

            toggleAutoSave() {
                this.autoSaveEnabled = !this.autoSaveEnabled;
                localStorage.setItem('mypocket_auto_save', this.autoSaveEnabled.toString());
                this.updateAutoSaveStatus();

                if (this.autoSaveEnabled && this.hasUnsavedChanges && this.accessToken) {
                    this.saveToOneDrive();
                }

                this.updateStatus(`🔄 Auto-save ${this.autoSaveEnabled ? 'enabled' : 'disabled'}`, 'success');
            }

            updateAutoSaveStatus() {
                const autoSaveStatus = document.getElementById('autoSaveStatus');
                const autoSaveNavBtn = document.getElementById('autoSaveNavBtn');

                const enabled = localStorage.getItem('mypocket_auto_save') === 'true';
                this.autoSaveEnabled = enabled;

                if (autoSaveStatus) {
                    autoSaveStatus.textContent = enabled ? 'ON' : 'OFF';
                }

                if (autoSaveNavBtn) {
                    if (enabled) {
                        autoSaveNavBtn.style.color = 'var(--success)';
                    } else {
                        autoSaveNavBtn.style.color = '';
                    }
                }
            }

            async loadFromOneDrive() {
                if (!this.accessToken) {
                    this.updateStatus('❌ Not connected to OneDrive. Please connect first.', 'error');
                    return;
                }

                try {
                    this.updateStatus('☁️ Loading from OneDrive...', 'loading');
                    await this.loadArticles();
                    await this.saveLocalCache();
                    this.updateStatus('☁️ Successfully loaded from OneDrive and cached with improved storage', 'success');
                } catch (error) {
                    ErrorHandler.handleError(error, 'Load from OneDrive');
                    this.updateStatus(`❌ Failed to load from OneDrive: ${error.message}`, 'error');
                }
            }

            async saveToOneDrive() {
                if (!this.accessToken) {
                    this.updateStatus('❌ Not connected to OneDrive. Please connect first.', 'error');
                    return;
                }

                if (this.articles.length === 0) {
                    this.updateStatus('❌ No articles to save', 'error');
                    return;
                }

                try {
                    this.updateStatus('☁️ Saving to OneDrive...', 'loading');
                    await this.updateOneDriveBackup();
                    this.hasUnsavedChanges = false;
                    this.lastOneDriveSyncHash = this.calculateArticlesHash();
                    await this.saveLocalCache();
                    this.updateLocalCacheStatus('synced', `☁️ Synced ${this.articles.length} articles to OneDrive`);
                    this.updateStatus('☁️ Successfully saved to OneDrive', 'success');
                } catch (error) {
                    ErrorHandler.handleError(error, 'Save to OneDrive');
                    this.updateStatus(`❌ Failed to save to OneDrive: ${error.message}`, 'error');
                }
            }

            // Enhanced AI Categorization System
            initializeAIEnhancedCategoryKeywords() {
                return {
                    'Technology': {
                        icon: '💻',
                        confidence: 'high',
                        weight: 1.0,
                        keywords: ['tech', 'technology', 'programming', 'code', 'coding', 'software', 'developer', 'development', 'javascript', 'python', 'react', 'vue', 'angular', 'node', 'api', 'github', 'stackoverflow', 'algorithm', 'database', 'web', 'mobile', 'app', 'application', 'framework', 'library', 'bug', 'debug', 'frontend', 'backend', 'fullstack', 'devops', 'cloud', 'aws', 'azure', 'docker', 'kubernetes', 'microservices', 'serverless', 'machine learning', 'artificial intelligence', 'ai', 'ml', 'data science', 'blockchain', 'cryptocurrency', 'bitcoin', 'cybersecurity', 'security', 'hacking', 'penetration testing', 'open source', 'git', 'version control', 'ci/cd', 'automation', 'testing'],
                        domains: ['github.com', 'stackoverflow.com', 'dev.to', 'techcrunch.com', 'theverge.com', 'arstechnica.com', 'wired.com', 'hacker-news.firebaseapp.com', 'news.ycombinator.com', 'medium.com', 'hackernoon.com', 'freecodecamp.org'],
                        aliases: ['tech', 'programming', 'software', 'coding', 'dev']
                    },
                    'Business': {
                        icon: '💼',
                        confidence: 'high',
                        weight: 1.0,
                        keywords: ['business', 'startup', 'entrepreneur', 'entrepreneurship', 'finance', 'financial', 'investment', 'investing', 'marketing', 'sales', 'strategy', 'management', 'leadership', 'company', 'revenue', 'profit', 'corporate', 'economics', 'market', 'industry', 'venture', 'funding', 'ipo', 'stocks', 'trading', 'cryptocurrency', 'fintech', 'saas', 'b2b', 'b2c', 'productivity', 'workflow', 'automation', 'remote work', 'freelancing', 'consulting', 'networking', 'career', 'job', 'hiring', 'hr', 'human resources', 'innovation', 'disruption', 'scaling', 'growth hacking'],
                        domains: ['linkedin.com', 'forbes.com', 'bloomberg.com', 'businessinsider.com', 'harvard.business.review', 'hbr.org', 'entrepreneur.com', 'inc.com', 'fastcompany.com'],
                        aliases: ['startup', 'finance', 'entrepreneurship', 'corporate', 'work']
                    },
                    'Science': {
                        icon: '🔬',
                        confidence: 'high',
                        weight: 1.0,
                        keywords: ['science', 'scientific', 'research', 'study', 'data', 'analysis', 'experiment', 'discovery', 'theory', 'hypothesis', 'biology', 'chemistry', 'physics', 'medicine', 'medical', 'health', 'healthcare', 'climate', 'environment', 'environmental', 'space', 'astronomy', 'genetics', 'psychology', 'neuroscience', 'quantum', 'nuclear', 'biochemistry', 'biotechnology', 'pharmaceutical', 'vaccine', 'covid', 'pandemic', 'evolution', 'ecology', 'sustainability', 'renewable energy', 'solar', 'wind energy', 'genomics', 'bioengineering', 'nanotechnology'],
                        domains: ['arxiv.org', 'nature.com', 'science.org', 'plos.org', 'pubmed.ncbi.nlm.nih.gov', 'ncbi.nlm.nih.gov', 'sciencedirect.com'],
                        aliases: ['research', 'medical', 'biology', 'chemistry', 'physics']
                    },
                    'Politics': {
                        icon: '🏛️',
                        confidence: 'medium',
                        weight: 0.8,
                        keywords: ['politics', 'political', 'government', 'policy', 'election', 'vote', 'voting', 'democracy', 'republican', 'democrat', 'conservative', 'liberal', 'senate', 'congress', 'president', 'prime minister', 'parliament', 'legislation', 'law', 'constitution', 'supreme court', 'judge', 'campaign', 'candidate', 'poll', 'debate', 'immigration', 'healthcare reform', 'tax policy', 'foreign policy', 'diplomacy', 'war', 'peace', 'conflict', 'international relations'],
                        domains: ['politico.com', 'washingtonpost.com', 'nytimes.com', 'cnn.com', 'foxnews.com', 'bbc.com', 'reuters.com'],
                        aliases: ['government', 'election', 'policy', 'democracy', 'law']
                    },
                    'Philosophy': {
                        icon: '🤔',
                        confidence: 'medium',
                        weight: 0.7,
                        keywords: ['philosophy', 'philosophical', 'ethics', 'moral', 'morality', 'epistemology', 'metaphysics', 'logic', 'reasoning', 'consciousness', 'existentialism', 'stoicism', 'buddhism', 'mindfulness', 'meditation', 'wisdom', 'truth', 'reality', 'existence', 'meaning', 'purpose', 'free will', 'determinism', 'phenomenology', 'nihilism', 'absurdism', 'pragmatism', 'rationalism', 'empiricism', 'virtue', 'justice', 'freedom', 'rights', 'utilitarianism', 'deontology', 'virtue ethics', 'critical thinking'],
                        domains: ['plato.stanford.edu', 'philpapers.org', 'philosophynow.org', 'aeon.co'],
                        aliases: ['ethics', 'moral', 'wisdom', 'consciousness', 'existential']
                    },
                    'Psychology': {
                        icon: '🧠',
                        confidence: 'medium',
                        weight: 0.8,
                        keywords: ['psychology', 'psychological', 'mental health', 'therapy', 'counseling', 'behavior', 'cognitive', 'emotion', 'personality', 'depression', 'anxiety', 'stress', 'trauma', 'ptsd', 'mindfulness', 'self-help', 'motivation', 'habit', 'addiction', 'neurology', 'brain', 'mind', 'learning', 'memory', 'perception', 'development', 'social psychology', 'behavioral economics', 'decision making', 'bias', 'persuasion', 'influence', 'relationships', 'communication', 'leadership psychology'],
                        domains: ['psychologytoday.com', 'apa.org', 'psych.org', 'mindful.org'],
                        aliases: ['mental health', 'therapy', 'behavior', 'mind', 'brain']
                    },
                    'Design': {
                        icon: '🎨',
                        confidence: 'high',
                        weight: 1.0,
                        keywords: ['design', 'designer', 'ui', 'ux', 'user experience', 'user interface', 'interface', 'visual', 'graphic', 'creative', 'art', 'artist', 'illustration', 'typography', 'color', 'layout', 'prototype', 'wireframe', 'figma', 'sketch', 'photoshop', 'adobe', 'branding', 'logo', 'icon', 'website design', 'web design', 'mobile design', 'app design', 'product design', 'industrial design', 'fashion', 'architecture', 'interior design', 'photography', 'video', 'animation', 'motion graphics', 'accessibility', 'usability'],
                        domains: ['dribbble.com', 'behance.net', 'medium.com', 'uxdesign.cc', 'designbetter.co', 'smashingmagazine.com'],
                        aliases: ['ui', 'ux', 'graphic', 'visual', 'creative']
                    },
                    'News': {
                        icon: '📰',
                        confidence: 'medium',
                        weight: 0.6,
                        keywords: ['news', 'breaking', 'breaking news', 'report', 'reporter', 'journalist', 'journalism', 'media', 'current events', 'headline', 'press', 'investigation', 'crisis', 'conflict', 'war', 'peace', 'diplomacy', 'economy', 'economic', 'recession', 'inflation', 'gdp', 'unemployment', 'stock market', 'breaking', 'urgent', 'live', 'update', 'scandal', 'controversy', 'exclusive', 'interview', 'analysis', 'opinion', 'editorial'],
                        domains: ['bbc.com', 'cnn.com', 'nytimes.com', 'washingtonpost.com', 'theguardian.com', 'reuters.com'],
                        aliases: ['journalism', 'media', 'current events', 'breaking']
                    },
                    'Education': {
                        icon: '🎓',
                        confidence: 'high',
                        weight: 0.9,
                        keywords: ['education', 'educational', 'learning', 'learn', 'course', 'courses', 'tutorial', 'tutorials', 'lesson', 'lessons', 'teach', 'teaching', 'teacher', 'student', 'university', 'college', 'school', 'academic', 'academia', 'knowledge', 'skill', 'skills', 'training', 'certification', 'certificate', 'degree', 'bachelor', 'master', 'phd', 'doctorate', 'mooc', 'online learning', 'e-learning', 'study', 'studying', 'exam', 'test', 'quiz', 'homework', 'assignment', 'research', 'curriculum', 'pedagogy'],
                        domains: ['coursera.org', 'edx.org', 'khanacademy.org', 'udemy.com', 'wikipedia.org'],
                        aliases: ['learning', 'course', 'tutorial', 'academic', 'study']
                    },
                    'Entertainment': {
                        icon: '🎬',
                        confidence: 'medium',
                        weight: 0.7,
                        keywords: ['entertainment', 'movie', 'movies', 'film', 'films', 'cinema', 'tv', 'television', 'show', 'shows', 'series', 'episode', 'season', 'music', 'song', 'album', 'artist', 'band', 'concert', 'festival', 'game', 'games', 'gaming', 'video games', 'esports', 'streaming', 'netflix', 'amazon prime', 'disney', 'hulu', 'spotify', 'apple music', 'youtube', 'twitch', 'celebrity', 'celebrities', 'hollywood', 'broadway', 'theater', 'comedy', 'humor', 'funny', 'meme', 'viral', 'pop culture'],
                        domains: ['youtube.com', 'netflix.com', 'spotify.com', 'imdb.com', 'ign.com', 'gamespot.com'],
                        aliases: ['movies', 'music', 'gaming', 'tv', 'celebrity']
                    },
                    'Health': {
                        icon: '🏥',
                        confidence: 'high',
                        weight: 0.9,
                        keywords: ['health', 'healthy', 'healthcare', 'medical', 'medicine', 'doctor', 'physician', 'patient', 'hospital', 'clinic', 'treatment', 'therapy', 'disease', 'illness', 'symptoms', 'diagnosis', 'cure', 'medication', 'drug', 'pharmaceutical', 'fitness', 'exercise', 'workout', 'gym', 'running', 'yoga', 'nutrition', 'diet', 'food', 'vitamins', 'supplements', 'wellness', 'mental health', 'depression', 'anxiety', 'stress', 'mindfulness', 'meditation', 'sleep', 'weight loss', 'weight gain', 'muscle', 'cardio', 'prevention', 'immunization'],
                        domains: ['mayoclinic.org', 'webmd.com', 'healthline.com', 'nih.gov', 'cdc.gov'],
                        aliases: ['medical', 'fitness', 'wellness', 'nutrition', 'healthcare']
                    },
                    'Sports': {
                        icon: '⚽',
                        confidence: 'medium',
                        weight: 0.8,
                        keywords: ['sports', 'sport', 'football', 'soccer', 'basketball', 'baseball', 'tennis', 'golf', 'hockey', 'olympics', 'athlete', 'team', 'game', 'match', 'tournament', 'championship', 'league', 'player', 'coach', 'training', 'fitness', 'competition', 'score', 'win', 'lose', 'victory', 'defeat', 'mvp', 'draft', 'trade', 'playoff', 'season', 'stadium', 'fan', 'espn', 'nfl', 'nba', 'mlb', 'nhl', 'fifa', 'uefa'],
                        domains: ['espn.com', 'sports.yahoo.com', 'bleacherreport.com', 'si.com'],
                        aliases: ['athletics', 'competition', 'team', 'game', 'athlete']
                    },
                    'Travel': {
                        icon: '✈️',
                        confidence: 'medium',
                        weight: 0.7,
                        keywords: ['travel', 'traveling', 'trip', 'vacation', 'holiday', 'tourism', 'tourist', 'destination', 'flight', 'flights', 'airline', 'airport', 'hotel', 'accommodation', 'booking', 'airbnb', 'hostel', 'resort', 'adventure', 'explore', 'exploring', 'backpacking', 'hiking', 'camping', 'road trip', 'cruise', 'culture', 'cultural', 'country', 'city', 'guide', 'travel guide', 'itinerary', 'budget travel', 'luxury travel', 'solo travel', 'family travel', 'business travel', 'nomad'],
                        domains: ['tripadvisor.com', 'booking.com', 'airbnb.com', 'expedia.com'],
                        aliases: ['vacation', 'tourism', 'adventure', 'explore', 'journey']
                    },
                    'Food': {
                        icon: '🍳',
                        confidence: 'medium',
                        weight: 0.8,
                        keywords: ['food', 'recipe', 'recipes', 'cooking', 'cook', 'chef', 'kitchen', 'restaurant', 'restaurants', 'dining', 'cuisine', 'culinary', 'ingredient', 'ingredients', 'meal', 'meals', 'dish', 'dishes', 'baking', 'bake', 'bread', 'cake', 'dessert', 'nutrition', 'diet', 'healthy eating', 'vegetarian', 'vegan', 'gluten-free', 'organic', 'local food', 'farm to table', 'foodie', 'wine', 'beer', 'cocktail', 'beverage', 'coffee', 'tea', 'breakfast', 'lunch', 'dinner'],
                        domains: ['allrecipes.com', 'foodnetwork.com', 'epicurious.com', 'bonappetit.com'],
                        aliases: ['cooking', 'recipe', 'cuisine', 'dining', 'culinary']
                    },
                    'Environment': {
                        icon: '🌱',
                        confidence: 'medium',
                        weight: 0.8,
                        keywords: ['environment', 'environmental', 'climate', 'climate change', 'global warming', 'sustainability', 'sustainable', 'renewable energy', 'solar', 'wind', 'green', 'eco', 'ecology', 'ecosystem', 'biodiversity', 'conservation', 'pollution', 'carbon', 'emissions', 'greenhouse gas', 'fossil fuels', 'clean energy', 'recycling', 'waste', 'plastic', 'ocean', 'forest', 'deforestation', 'wildlife', 'endangered species', 'carbon footprint', 'renewable', 'organic'],
                        domains: ['greenpeace.org', 'wwf.org', 'epa.gov', 'unfccc.int'],
                        aliases: ['climate', 'sustainability', 'green', 'ecology', 'conservation']
                    },
                    'Lifestyle': {
                        icon: '🏠',
                        confidence: 'low',
                        weight: 0.5,
                        keywords: ['lifestyle', 'life', 'living', 'home', 'house', 'apartment', 'decor', 'decoration', 'interior', 'furniture', 'diy', 'crafts', 'gardening', 'pets', 'family', 'parenting', 'relationships', 'dating', 'marriage', 'wedding', 'fashion', 'style', 'beauty', 'skincare', 'makeup', 'hair', 'shopping', 'personal development', 'self-improvement', 'habits', 'productivity', 'organization', 'minimalism', 'self-care', 'work-life balance'],
                        domains: ['pinterest.com', 'instagram.com', 'buzzfeed.com', 'refinery29.com'],
                        aliases: ['personal', 'self-improvement', 'home', 'family', 'relationships']
                    }
                };
            }

            initializeContextPhrases() {
                return {
                    'Technology': [
                        'software development', 'web development', 'mobile development', 'app development',
                        'machine learning', 'artificial intelligence', 'data science', 'deep learning',
                        'programming language', 'javascript framework', 'react tutorial', 'python guide',
                        'api development', 'database design', 'cloud computing', 'devops practices'
                    ],
                    'Business': [
                        'business strategy', 'startup funding', 'venture capital', 'market research',
                        'customer acquisition', 'revenue growth', 'profit margin', 'business model',
                        'digital transformation', 'market analysis', 'competitive advantage'
                    ],
                    'Science': [
                        'scientific study', 'research findings', 'peer review', 'clinical trial',
                        'scientific method', 'research paper', 'laboratory study', 'experimental results'
                    ]
                };
            }

            initializeNegativeKeywords() {
                return {
                    'Technology': ['cooking recipe', 'fitness workout', 'travel guide', 'restaurant review'],
                    'Business': ['game walkthrough', 'movie review', 'cooking tutorial', 'fitness routine'],
                    'Science': ['business strategy', 'marketing tips', 'entertainment news', 'sports recap']
                };
            }

            initializeCategorySynonyms() {
                return {
                    'Technology': ['tech', 'programming', 'software', 'coding', 'dev'],
                    'Business': ['startup', 'finance', 'entrepreneurship', 'corporate', 'work'],
                    'Science': ['research', 'medical', 'biology', 'chemistry', 'physics']
                };
            }

            // Enhanced AI Categorization
            categorizeArticle(article) {
                const title = (article.title || '').toLowerCase();
                const excerpt = (article.excerpt || '').toLowerCase();
                const url = (article.url || '').toLowerCase();
                const domain = this.getDomain(article.url).toLowerCase();
                const content = this.getArticleContentForAnalysis(article).toLowerCase();

                const titleWeight = 3.0;
                const excerptWeight = 2.0;
                const contentWeight = 1.0;

                const scores = new Map();
                let analysisDetails = {};

                console.log(`🧠 AI categorization for: "${article.title.substring(0, 40)}..."`);

                for (const [categoryName, categoryData] of Object.entries(this.categoryKeywords)) {
                    let score = 0;
                    let reasons = [];
                    let confidence = 'low';

                    // Context phrase matching
                    const contextPhrases = this.contextPhrases[categoryName] || [];
                    let contextMatches = 0;
                    for (const phrase of contextPhrases) {
                        let phraseScore = 0;
                        if (title.includes(phrase)) {
                            phraseScore += 200 * titleWeight;
                            contextMatches++;
                            reasons.push(`title-context: "${phrase}"`);
                        }
                        if (excerpt.includes(phrase)) {
                            phraseScore += 150 * excerptWeight;
                            contextMatches++;
                            reasons.push(`excerpt-context: "${phrase}"`);
                        }
                        if (content.includes(phrase)) {
                            phraseScore += 100 * contentWeight;
                            reasons.push(`content-context: "${phrase}"`);
                        }
                        score += phraseScore;
                        if (phraseScore > 200) confidence = 'very-high';
                    }

                    // Negative keyword filtering
                    const negativeKeywords = this.negativeKeywords[categoryName] || [];
                    let negativeMatches = 0;
                    for (const negative of negativeKeywords) {
                        let penalty = 0;
                        if (title.includes(negative)) {
                            penalty += 300;
                            negativeMatches++;
                            reasons.push(`NEGATIVE-title: "${negative}"`);
                        }
                        if (excerpt.includes(negative)) {
                            penalty += 200;
                            negativeMatches++;
                            reasons.push(`NEGATIVE-excerpt: "${negative}"`);
                        }
                        score -= penalty;
                    }

                    // Domain matching (reduced influence)
                    const exactDomainMatch = categoryData.domains.some(d => domain === d || domain.includes(d));
                    if (exactDomainMatch) {
                        score += 10;
                        reasons.push(`domain: ${domain}`);
                    }

                    // Title analysis
                    let titleMatches = 0;
                    for (const keyword of categoryData.keywords) {
                        let keywordScore = 0;

                        if (keyword.includes(' ') && title.includes(keyword)) {
                            keywordScore += 150 * titleWeight;
                            titleMatches++;
                            reasons.push(`title-exact-phrase: "${keyword}"`);
                        }
                        else if (new RegExp(`\\b${keyword}\\b`).test(title)) {
                            keywordScore += 100 * titleWeight;
                            titleMatches++;
                            reasons.push(`title-exact-word: "${keyword}"`);
                        }
                        else if (title.includes(keyword)) {
                            keywordScore += 50 * titleWeight;
                            titleMatches++;
                            reasons.push(`title-partial: "${keyword}"`);
                        }

                        if (keyword.includes(' ') && excerpt.includes(keyword)) {
                            keywordScore += 100 * excerptWeight;
                            reasons.push(`excerpt-exact-phrase: "${keyword}"`);
                        }
                        else if (new RegExp(`\\b${keyword}\\b`).test(excerpt)) {
                            keywordScore += 70 * excerptWeight;
                            reasons.push(`excerpt-exact-word: "${keyword}"`);
                        }
                        else if (excerpt.includes(keyword)) {
                            keywordScore += 35 * excerptWeight;
                            reasons.push(`excerpt-partial: "${keyword}"`);
                        }

                        score += keywordScore;
                    }

                    // Synonym matching
                    const synonyms = this.categorySynonyms[categoryName] || [];
                    for (const synonym of synonyms) {
                        if (title.includes(synonym)) {
                            score += 60 * titleWeight;
                            titleMatches++;
                            reasons.push(`title-synonym: "${synonym}"`);
                        }
                        if (excerpt.includes(synonym)) {
                            score += 40 * excerptWeight;
                            reasons.push(`excerpt-synonym: "${synonym}"`);
                        }
                    }

                    // Content analysis
                    if (content.length > 100) {
                        let contentMatches = 0;
                        for (const keyword of categoryData.keywords) {
                            const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                            const matches = content.match(regex);
                            if (matches) {
                                const matchScore = Math.min(matches.length * 15, 60) * contentWeight;
                                score += matchScore;
                                contentMatches += matches.length;
                                if (matches.length > 2) {
                                    reasons.push(`content: "${keyword}" (${matches.length}x)`);
                                }
                            }
                        }
                    }

                    // Confidence calculation
                    if (contextMatches >= 2 && negativeMatches === 0) {
                        confidence = 'very-high';
                        score += 50;
                    } else if (contextMatches >= 1 && titleMatches >= 2 && negativeMatches === 0) {
                        confidence = 'high';
                        score += 30;
                    } else if (titleMatches >= 2 && negativeMatches === 0) {
                        confidence = 'medium';
                        score += 15;
                    } else if (negativeMatches > 0) {
                        confidence = 'very-low';
                    }

                    // Apply category weight
                    const categoryWeight = categoryData.weight || 1.0;
                    score = Math.round(score * categoryWeight);

                    score = Math.max(0, score);

                    scores.set(categoryName, score);
                    analysisDetails[categoryName] = {
                        score: score,
                        reasons: reasons,
                        confidence: confidence,
                        contextMatches: contextMatches,
                        negativeMatches: negativeMatches,
                        titleMatches: titleMatches
                    };
                }

                // Decision making
                const sortedScores = Array.from(scores.entries()).sort((a, b) => b[1] - a[1]);

                let bestCategory = 'Lifestyle';
                let bestScore = 0;
                let secondBestScore = 0;

                if (sortedScores.length >= 1) {
                    bestScore = sortedScores[0][1];
                    bestCategory = sortedScores[0][0];
                }
                if (sortedScores.length >= 2) {
                    secondBestScore = sortedScores[1][1];
                }

                const minThreshold = 100;
                const confidenceGap = bestScore - secondBestScore;
                const categoryConfidence = analysisDetails[bestCategory]?.confidence || 'low';
                const hasNegativeMatches = analysisDetails[bestCategory]?.negativeMatches > 0;

                let finalCategory = bestCategory;
                let aiEnhanced = false;

                if (hasNegativeMatches) {
                    if (sortedScores.length > 1 && sortedScores[1][1] >= 60) {
                        finalCategory = sortedScores[1][0];
                        aiEnhanced = true;
                        console.log(`🤖 Negative keywords detected, using second choice: ${finalCategory}`);
                    } else {
                        finalCategory = 'Lifestyle';
                        console.log(`🤖 Negative keywords detected, using default`);
                    }
                } else if (bestScore < minThreshold) {
                    finalCategory = 'Lifestyle';
                    console.log(`🤖 Below threshold (${bestScore} < ${minThreshold}), using default`);
                } else if (confidenceGap < 30 && bestScore < 150) {
                    finalCategory = this.enhancedAICategoryFallback(article, sortedScores, analysisDetails);
                    aiEnhanced = true;
                    console.log(`🤖 Enhanced AI fallback applied: ${finalCategory}`);
                } else {
                    console.log(`✅ High confidence categorization: ${finalCategory} (score: ${bestScore}, gap: ${confidenceGap})`);
                }

                // Store results
                article.category = finalCategory;
                article.categoryScore = bestScore;
                article.categoryConfidence = confidenceGap;
                article.aiEnhanced = aiEnhanced;
                article.categoryAnalysis = analysisDetails[finalCategory];

                console.log(`🎯 "${article.title.substring(0, 30)}..." → ${finalCategory} (score: ${bestScore}, confidence: ${categoryConfidence})`);
                return finalCategory;
            }

            enhancedAICategoryFallback(article, sortedScores, analysisDetails) {
                const title = article.title.toLowerCase();
                const excerpt = (article.excerpt || '').toLowerCase();
                const domain = this.getDomain(article.url).toLowerCase();

                console.log(`🧠 Enhanced fallback analysis for: "${title.substring(0, 30)}..."`);

                const contentTypePatterns = {
                    'Technology': /\b(code|programming|software|api|tech|javascript|python|react|github|dev)\b/i,
                    'Science': /\b(research|study|scientific|experiment|clinical|journal|academic|university)\b/i,
                    'Business': /\b(startup|business|finance|investment|market|company|revenue|entrepreneur)\b/i,
                    'Education': /\b(course|tutorial|learn|teach|education|guide|lesson|training)\b/i,
                    'Health': /\b(health|medical|fitness|nutrition|wellness|exercise|diet|mental.?health)\b/i
                };

                const text = `${title} ${excerpt}`;

                for (const [category, pattern] of Object.entries(contentTypePatterns)) {
                    if (pattern.test(text)) {
                        const categoryScore = sortedScores.find(([cat, score]) => cat === category);
                        if (categoryScore && categoryScore[1] >= 40) {
                            console.log(`🎯 Pattern-based fallback: ${category}`);
                            return category;
                        }
                    }
                }

                if (sortedScores.length > 0 && sortedScores[0][1] >= 60) {
                    return sortedScores[0][0];
                }

                return 'Lifestyle';
            }

            getArticleContentForAnalysis(article) {
                const contentFields = ['content', 'textContent', 'excerpt', 'description', 'summary', 'fullContent', 'body'];

                let combinedContent = '';
                for (const field of contentFields) {
                    if (article[field] && typeof article[field] === 'string') {
                        combinedContent += ' ' + article[field];
                    }
                }

                return combinedContent.trim() || article.title || '';
            }

            updateCategoryAnalytics(category, score, aiEnhanced) {
                if (!this.categoryAnalytics.has(category)) {
                    this.categoryAnalytics.set(category, {
                        count: 0,
                        totalScore: 0,
                        aiEnhanced: 0,
                        avgScore: 0,
                        highConfidence: 0,
                        mediumConfidence: 0,
                        lowConfidence: 0
                    });
                }

                const analytics = this.categoryAnalytics.get(category);
                analytics.count++;
                analytics.totalScore += score;
                analytics.avgScore = Math.round(analytics.totalScore / analytics.count);
                if (aiEnhanced) analytics.aiEnhanced++;

                if (score >= 100) analytics.highConfidence++;
                else if (score >= 60) analytics.mediumConfidence++;
                else analytics.lowConfidence++;

                this.categoryAnalytics.set(category, analytics);
            }

            async recategorizeAllArticles() {
                console.log('📂 Auto-categorizing all articles...');
                this.categories.clear();

                for (const article of this.articles) {
                    const category = this.categorizeArticle(article);
                    this.categories.set(category, (this.categories.get(category) || 0) + 1);
                }

                console.log(`📊 Categories found:`, Object.fromEntries(this.categories));

                setTimeout(() => {
                    this.updateCategoryUI();
                }, 10);
            }

            async recategorizeAllWithAI() {
                if (this.isRecategorizing) {
                    this.updateStatus('⚠️ Recategorization already in progress!', 'error');
                    return;
                }

                if (this.articles.length === 0) {
                    this.updateStatus('❌ No articles to categorize. Load articles first.', 'error');
                    return;
                }

                console.log('🧠 Starting AI categorization with progress tracking...');
                this.isRecategorizing = true;

                this.showProgressOverlay();
                this.updateRecategorizeButton(true);

                try {
                    await this.performRecategorization();
                } catch (error) {
                    ErrorHandler.handleError(error, 'Recategorization');
                    this.updateStatus(`❌ Recategorization failed: ${error.message}`, 'error');
                } finally {
                    this.isRecategorizing = false;
                    this.hideProgressOverlay();
                    this.updateRecategorizeButton(false);
                }
            }

            showProgressOverlay() {
                const overlay = document.getElementById('progressOverlay');
                if (overlay) {
                    overlay.classList.add('visible');
                }
            }

            hideProgressOverlay() {
                const overlay = document.getElementById('progressOverlay');
                if (overlay) {
                    overlay.classList.remove('visible');
                }
            }

            updateProgress(percentage, text, stats = '') {
                const fill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                const progressStats = document.getElementById('progressStats');

                if (fill) {
                    fill.style.width = `${percentage}%`;
                }
                if (progressText) {
                    progressText.textContent = text;
                }
                if (progressStats && stats) {
                    progressStats.textContent = stats;
                }
            }

            updateRecategorizeButton(isProcessing) {
                const btn = document.getElementById('recategorizeBtn');
                if (btn) {
                    if (isProcessing) {
                        btn.innerHTML = `
                            <span class="icon">⏳</span>
                            <span class="text">Processing...</span>
                        `;
                        btn.disabled = true;
                        btn.style.opacity = '0.6';
                        btn.style.pointerEvents = 'none';
                    } else {
                        btn.innerHTML = `
                            <span class="icon">🧠</span>
                            <span class="text">AI Re-categorize</span>
                        `;
                        btn.disabled = false;
                        btn.style.opacity = '1';
                        btn.style.pointerEvents = 'auto';
                    }
                }
            }

            async performRecategorization() {
                const total = this.articles.length;
                let processed = 0;
                let categorizedCount = 0;
                let aiEnhancedCount = 0;
                let highConfidenceCount = 0;

                this.updateProgress(0, 'Initializing AI analysis...', `Preparing to analyze ${total} articles with enhanced categorization`);

                this.categories.clear();
                this.categoryAnalytics.clear();

                const batchSize = 10;

                for (let i = 0; i < total; i += batchSize) {
                    const batch = this.articles.slice(i, Math.min(i + batchSize, total));

                    for (const article of batch) {
                        try {
                            const category = this.categorizeArticle(article);
                            this.categories.set(category, (this.categories.get(category) || 0) + 1);

                            this.updateCategoryAnalytics(category, article.categoryScore || 0, article.aiEnhanced || false);

                            categorizedCount++;
                            if (article.aiEnhanced) aiEnhancedCount++;
                            if (article.categoryScore >= 100) highConfidenceCount++;

                            processed++;

                            const progress = Math.round((processed / total) * 100);
                            const statsText = `${categorizedCount} articles categorized • ${aiEnhancedCount} AI-enhanced • ${highConfidenceCount} high-confidence • ${this.categories.size} categories found`;
                            this.updateProgress(progress, `Analyzing article ${processed}/${total}...`, statsText);

                        } catch (error) {
                            ErrorHandler.handleError(error, `Categorizing article ${processed}`);
                            processed++;
                        }
                    }

                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                this.updateProgress(100, 'Updating display...', `Refreshing display with ${this.categories.size} categories`);
                await new Promise(resolve => setTimeout(resolve, 200));

                this.updateCategoryUI();
                this.displayArticles(this.currentDisplayedArticles);
                this.updateArticleCounts();

                await this.saveLocalCache();

                const message = `🧠 ✅ Re-categorized ${categorizedCount} articles into ${this.categories.size} categories (${aiEnhancedCount} AI-enhanced, ${highConfidenceCount} high-confidence)`;
                this.updateStatus(message, 'success');
            }

            updateCategoryUI() {
                const categoryChips = document.getElementById('categoryChips');
                if (!categoryChips) return;

                const sortedCategories = Array.from(this.categories.entries())
                    .sort((a, b) => b[1] - a[1]);

                const totalArticles = this.articles.length;
                const aiEnhancedTotal = this.articles.filter(a => a.aiEnhanced).length;
                const highConfidenceTotal = this.articles.filter(a => a.categoryScore >= 100).length;

                console.log(`🎨 Updating AI category UI with ${sortedCategories.length} categories (${aiEnhancedTotal} AI-enhanced, ${highConfidenceTotal} high-confidence)`);

                categoryChips.innerHTML = `
                    <div class="category-chip show-all ${!this.activeCategory ? 'active' : ''}" 
                         data-category="null">
                        <span>🧠</span>
                        <span>All Articles</span>
                        <span class="category-count">${totalArticles}</span>
                    </div>
                    ${sortedCategories.map(([category, count]) => {
                    const categoryData = this.categoryKeywords[category] || { icon: '📄' };
                    const isActive = this.activeCategory === category;
                    const analytics = this.categoryAnalytics.get(category);
                    const aiEnhancedCount = analytics ? analytics.aiEnhanced : 0;
                    const avgScore = analytics ? analytics.avgScore : 0;
                    const highConfidence = analytics ? analytics.highConfidence : 0;
                    const isAiEnhanced = aiEnhancedCount > 0;

                    let confidenceIndicator = '';
                    if (highConfidence > count * 0.6) {
                        confidenceIndicator = ' 🎯';
                    } else if (aiEnhancedCount > 0) {
                        confidenceIndicator = ' 🤖';
                    }

                    return `
                            <div class="category-chip ${isActive ? 'active' : ''} ${isAiEnhanced ? 'ai-enhanced' : ''}" 
                                 data-category="${category}"
                                 title="Show ${count} ${category.toLowerCase()} articles (${aiEnhancedCount} AI-enhanced, ${highConfidence} high-confidence, avg score: ${avgScore})">
                                <span>${categoryData.icon}</span>
                                <span>${category}${confidenceIndicator}</span>
                                <span class="category-count">${count}</span>
                            </div>
                        `;
                }).join('')}
                `;

                categoryChips.querySelectorAll('.category-chip').forEach(chip => {
                    chip.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const category = chip.getAttribute('data-category');
                        console.log(`🖱️ Category chip clicked: "${category}"`);
                        this.filterByCategory(category === 'null' ? null : category);
                    });
                });

                console.log(`✅ AI category UI updated with confidence indicators`);
            }

            filterByCategory(category) {
                console.log(`🎯 FILTERING BY CATEGORY: "${category}"`);
                this.activeCategory = category;

                let filtered;
                if (!category) {
                    filtered = this.articles;
                    console.log(`📂 Showing all ${filtered.length} articles`);
                } else {
                    this.articles.forEach((article, index) => {
                        if (!article.category) {
                            this.categorizeArticle(article);
                            console.log(`📂 Article ${index}: "${article.title.substring(0, 30)}..." categorized as "${article.category}"`);
                        }
                    });

                    filtered = this.articles.filter(article => {
                        const matches = article.category === category;
                        if (matches) {
                            console.log(`✅ MATCH: "${article.title.substring(0, 30)}..." is in category "${category}"`);
                        }
                        return matches;
                    });

                    console.log(`🎯 Found ${filtered.length} articles in category "${category}"`);
                }

                this.currentDisplayedArticles = filtered;
                this.displayArticles(filtered);

                this.updateCategoryUI();
                this.updateNavigation();

                if (!category) {
                    this.updateStatus(`📂 Showing all ${filtered.length} articles`, 'success');
                } else {
                    const categoryData = this.categoryKeywords[category] || { icon: '📄' };
                    const analytics = this.categoryAnalytics.get(category);
                    const aiCount = analytics ? analytics.aiEnhanced : 0;
                    const highConfidence = analytics ? analytics.highConfidence : 0;

                    if (filtered.length === 0) {
                        this.updateStatus(`❌ No articles found in "${category}" category. Try a different category.`, 'error');
                    } else {
                        const aiText = aiCount > 0 ? ` (${aiCount} AI-enhanced, ${highConfidence} high-confidence)` : '';
                        this.updateStatus(`${categoryData.icon} Showing ${filtered.length} ${category.toLowerCase()} articles${aiText}`, 'success');
                    }
                }

                console.log(`📂 Filter complete: ${filtered.length} articles displayed`);
            }

            // Enhanced Authentication with PKCE
            generateCodeVerifier() {
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return this.base64URLEncode(array);
            }

            async generateCodeChallenge(codeVerifier) {
                const encoder = new TextEncoder();
                const data = encoder.encode(codeVerifier);
                const digest = await crypto.subtle.digest('SHA-256', data);
                return this.base64URLEncode(new Uint8Array(digest));
            }

            base64URLEncode(array) {
                return btoa(String.fromCharCode.apply(null, array))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            }

            generateState() {
                const array = new Uint8Array(16);
                crypto.getRandomValues(array);
                return this.base64URLEncode(array);
            }

            storePKCEParameters(codeVerifier, state) {
                sessionStorage.setItem('mypocket_code_verifier', codeVerifier);
                sessionStorage.setItem('mypocket_state', state);
                console.log('🔐 PKCE parameters stored securely');
            }

            retrievePKCEParameters() {
                const codeVerifier = sessionStorage.getItem('mypocket_code_verifier');
                const state = sessionStorage.getItem('mypocket_state');
                return { codeVerifier, state };
            }

            clearPKCEParameters() {
                sessionStorage.removeItem('mypocket_code_verifier');
                sessionStorage.removeItem('mypocket_state');
                console.log('🗑️ PKCE parameters cleared');
            }

            async authenticate() {
                console.log('🔐 Starting secure authentication process...');

                if (!this.redirectUri || (!this.redirectUri.startsWith('http://') && !this.redirectUri.startsWith('https://'))) {
                    const errorMsg = 'Invalid redirect URI. Please open this page via HTTP/HTTPS.';
                    console.error('🔴', errorMsg, 'Current URI:', this.redirectUri);
                    this.updateStatus(`❌ ${errorMsg}`, 'error');
                    return;
                }

                try {
                    this.updateStatus('🔐 Generating secure authentication parameters...', 'loading');
                    console.log('🔧 Generating PKCE parameters...');

                    this.codeVerifier = this.generateCodeVerifier();
                    this.codeChallenge = await this.generateCodeChallenge(this.codeVerifier);
                    this.state = this.generateState();

                    console.log('✅ PKCE parameters generated successfully');

                    this.storePKCEParameters(this.codeVerifier, this.state);

                    const authUrl = `https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize?` +
                        `client_id=${this.clientId}&` +
                        `response_type=code&` +
                        `redirect_uri=${encodeURIComponent(this.redirectUri)}&` +
                        `scope=${encodeURIComponent('Files.ReadWrite User.Read')}&` +
                        `state=${this.state}&` +
                        `code_challenge=${this.codeChallenge}&` +
                        `code_challenge_method=S256&` +
                        `response_mode=query`;

                    console.log('🔐 Secure Auth URL generated');

                    this.updateStatus('🔄 Redirecting to secure Microsoft login...', 'loading');

                    setTimeout(() => {
                        console.log('🌐 Redirecting to Microsoft login...');
                        window.location.href = authUrl;
                    }, 1000);

                } catch (error) {
                    ErrorHandler.handleError(error, 'PKCE Authentication');
                    this.updateStatus('❌ Error generating secure authentication. Please try again.', 'error');
                }
            }

            async checkAuthFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const state = urlParams.get('state');
                const error = urlParams.get('error');
                const errorDescription = urlParams.get('error_description');

                if (error) {
                    this.updateStatus(`❌ Authentication error: ${error} - ${errorDescription || 'Unknown error'}`, 'error');
                    this.clearPKCEParameters();
                    window.history.replaceState({}, document.title, window.location.pathname);
                    return;
                }

                if (code && state) {
                    try {
                        this.updateStatus('🔐 Exchanging authorization code for tokens...', 'loading');

                        const { codeVerifier, state: storedState } = this.retrievePKCEParameters();

                        if (!storedState || state !== storedState) {
                            throw new Error('State parameter mismatch. Possible CSRF attack.');
                        }

                        if (!codeVerifier) {
                            throw new Error('Code verifier not found. Please try authenticating again.');
                        }

                        const tokenResponse = await this.exchangeCodeForTokens(code, codeVerifier);

                        if (tokenResponse.access_token) {
                            console.log('✅ Token exchange successful');
                            this.accessToken = tokenResponse.access_token;
                            this.tokenManager.saveToken(tokenResponse.access_token);

                            if (tokenResponse.refresh_token) {
                                this.tokenManager.saveRefreshToken(tokenResponse.refresh_token);
                            }

                            console.log('🔄 Updating connection status...');
                            this.updateConnectionStatus(true);

                            this.clearPKCEParameters();
                            window.history.replaceState({}, document.title, window.location.pathname);

                            this.updateStatus('✅ Secure authentication successful!', 'success');
                        } else {
                            throw new Error('No access token received from authorization server');
                        }

                    } catch (error) {
                        ErrorHandler.handleError(error, 'Token Exchange');
                        this.updateStatus(`❌ Token exchange failed: ${error.message}`, 'error');
                        this.clearPKCEParameters();
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }
                }
            }

            async exchangeCodeForTokens(authorizationCode, codeVerifier) {
                const tokenEndpoint = 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                const tokenRequest = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        client_id: this.clientId,
                        scope: 'Files.ReadWrite User.Read',
                        code: authorizationCode,
                        redirect_uri: this.redirectUri,
                        grant_type: 'authorization_code',
                        code_verifier: codeVerifier
                    })
                };

                console.log('🔐 Exchanging authorization code for tokens...');

                const response = await fetch(tokenEndpoint, tokenRequest);

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Token exchange failed: ${errorData.error} - ${errorData.error_description}`);
                }

                const tokenData = await response.json();
                console.log('✅ Token exchange successful');

                return tokenData;
            }

            loadStoredToken() {
                console.log('🔍 Loading stored token...');
                this.accessToken = this.tokenManager.getToken();
                if (this.accessToken) {
                    console.log('✅ Found stored token, updating connection status...');
                    this.updateConnectionStatus(true);

                    if (this.tokenManager.isTokenExpired()) {
                        console.log('❌ Token is expired, attempting refresh...');
                        this.refreshAccessToken().then(success => {
                            if (!success) {
                                this.updateConnectionStatus(false);
                                this.updateStatus('Stored token expired. Please reconnect.', 'error');
                            }
                        });
                    }
                } else {
                    console.log('ℹ️ No stored token found');
                }
            }

            async refreshAccessToken() {
                const refreshToken = this.tokenManager.getRefreshToken();
                if (!refreshToken) {
                    console.log('No refresh token available');
                    return false;
                }

                try {
                    const tokenEndpoint = 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                    const refreshRequest = {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: this.clientId,
                            scope: 'Files.ReadWrite User.Read',
                            refresh_token: refreshToken,
                            grant_type: 'refresh_token'
                        })
                    };

                    const response = await fetch(tokenEndpoint, refreshRequest);

                    if (!response.ok) {
                        console.log('Refresh token request failed');
                        return false;
                    }

                    const tokenData = await response.json();

                    if (tokenData.access_token) {
                        this.accessToken = tokenData.access_token;
                        this.tokenManager.saveToken(tokenData.access_token);

                        if (tokenData.refresh_token) {
                            this.tokenManager.saveRefreshToken(tokenData.refresh_token);
                        }

                        console.log('✅ Token refreshed successfully');
                        return true;
                    }

                    return false;

                } catch (error) {
                    ErrorHandler.handleError(error, 'Token Refresh');
                    return false;
                }
            }

            async ensureValidToken() {
                if (!this.accessToken) {
                    return false;
                }

                if (this.tokenManager.isTokenExpired()) {
                    console.log('🔄 Token expired, attempting refresh...');
                    const refreshSuccess = await this.refreshAccessToken();
                    if (!refreshSuccess) {
                        console.log('❌ Token refresh failed, need to re-authenticate');
                        return false;
                    }
                }

                return true;
            }

            updateConnectionStatus(connected) {
                const connectBtn = document.getElementById('connectBtnSidebar');
                const connectIcon = document.getElementById('connectionIcon');
                const connectText = document.getElementById('connectionText');
                const connectionStatusSidebar = document.getElementById('connectionStatusSidebar');

                if (connected) {
                    if (connectIcon) connectIcon.textContent = '✅';
                    if (connectText) connectText.textContent = 'Connected (Secure)';
                    if (connectBtn) {
                        connectBtn.style.background = 'var(--success)';
                        connectBtn.textContent = 'Connected ✅';
                    }
                    if (connectionStatusSidebar) {
                        connectionStatusSidebar.className = 'connection-status-sidebar connected';
                    }
                } else {
                    if (connectIcon) connectIcon.textContent = '🔐';
                    if (connectText) connectText.textContent = 'Not Connected';
                    if (connectBtn) {
                        connectBtn.style.background = '';
                        connectBtn.textContent = 'Secure Connect';
                    }
                    if (connectionStatusSidebar) {
                        connectionStatusSidebar.className = 'connection-status-sidebar disconnected';
                    }
                }
            }

            // Enhanced Articles Loading and Display
            async loadArticles() {
                const hasValidToken = await this.ensureValidToken();
                if (!hasValidToken) {
                    this.updateConnectionStatus(false);
                    this.updateStatus('Authentication expired. Please reconnect.', 'error');
                    return;
                }

                try {
                    this.updateStatus('Loading articles with enhanced AI categorization... ⏳', 'loading');

                    const listResponse = await fetch('https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket:/children', {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!listResponse.ok) {
                        if (listResponse.status === 401) {
                            const refreshSuccess = await this.refreshAccessToken();
                            if (refreshSuccess) {
                                return this.loadArticles();
                            } else {
                                this.tokenManager.clearTokens();
                                this.updateConnectionStatus(false);
                                this.updateStatus('Session expired. Please reconnect.', 'error');
                                return;
                            }
                        }
                        throw new Error(`Failed to list files: ${listResponse.status}`);
                    }

                    const fileList = await listResponse.json();
                    const backupFiles = fileList.value.filter(file =>
                        file.name.startsWith('mypocket-backup-') && file.name.endsWith('.json')
                    );

                    if (backupFiles.length === 0) {
                        this.updateStatus('No backup files found. Save some articles with the browser extension first.', 'error');
                        this.displayEmptyState();
                        return;
                    }

                    const latestFile = backupFiles.sort((a, b) =>
                        new Date(b.lastModifiedDateTime) - new Date(a.lastModifiedDateTime)
                    )[0];

                    const downloadResponse = await fetch(`https://graph.microsoft.com/v1.0/me/drive/items/${latestFile.id}/content`, {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`
                        }
                    });

                    if (!downloadResponse.ok) {
                        throw new Error(`Failed to download backup: ${downloadResponse.status}`);
                    }

                    const backupContent = await downloadResponse.text();
                    const backup = JSON.parse(backupContent);

                    this.articles = backup.articles || [];
                    this.currentDisplayedArticles = this.articles;

                    console.log('🧠 Enhanced AI auto-categorizing loaded articles...');
                    this.updateStatus('🧠 Enhanced AI is analyzing your articles...', 'loading');

                    setTimeout(async () => {
                        await this.recategorizeAllWithAI();

                        this.updateArticleCounts();
                        this.displayArticles(this.articles);

                        const storedImages = this.articles.filter(a => a.cachedImage).length;
                        const aiEnhancedCount = this.articles.filter(a => a.aiEnhanced).length;
                        const highConfidenceCount = this.articles.filter(a => a.categoryScore >= 100).length;

                        await this.saveLocalCache();

                        this.updateStatus(`🧠 Loaded ${this.articles.length} articles with enhanced AI categorization (${storedImages} with stored images, ${aiEnhancedCount} AI-enhanced, ${highConfidenceCount} high-confidence)`, 'success');
                    }, 100);

                } catch (error) {
                    ErrorHandler.handleError(error, 'Load Articles');
                    this.updateStatus(`Error loading articles: ${error.message}`, 'error');
                }
            }

            displayArticles(articles) {
                const container = document.getElementById('articlesContainer');

                if (articles.length === 0) {
                    this.displayEmptyState();
                    return;
                }

                this.currentDisplayedArticles = articles;

                const isMobile = window.innerWidth <= 768;

                let imagesFromBackup = 0;
                let imagesFromCache = 0;
                let imagesNeedLoading = 0;

                console.log('🎯 DISPLAYING ARTICLES WITH ENHANCED AI CATEGORIES:');

                const articlesHTML = articles.map((article, displayIndex) => {
                    const index = displayIndex;

                    let imageHTML = '';
                    let cacheStatus = 'loading';
                    let statusText = '🔄 Loading';
                    let imageSource = 'none';

                    if (article.cachedImage && article.cachedImage.base64) {
                        imageHTML = this.createImageHTML(article.cachedImage.base64, true);
                        cacheStatus = 'synced';
                        statusText = '🌐 Synced';
                        imageSource = 'synced_base64';
                        imagesFromBackup++;
                        console.log(`✅ ${displayIndex}: Using SYNCED base64 for "${article.title.substring(0, 30)}..."`);
                    }
                    else if (article.cachedImage && article.cachedImage.url && !article.cachedImage.base64) {
                        imageHTML = this.createImageHTML(article.cachedImage.url, true);
                        cacheStatus = 'synced';
                        statusText = '🔗 Synced URL';
                        imageSource = 'synced_url';
                        imagesFromBackup++;
                        console.log(`✅ ${displayIndex}: Using SYNCED URL for "${article.title.substring(0, 30)}..."`);
                    }
                    else if (this.getCachedImage(article)) {
                        imageHTML = this.createImageHTML(this.getCachedImage(article), true);
                        cacheStatus = 'cached';
                        statusText = '💾 Local Cache';
                        imageSource = 'local_cache';
                        imagesFromCache++;
                        console.log(`⚡ ${displayIndex}: Using LOCAL cache for "${article.title.substring(0, 30)}..."`);
                    }
                    else if (this.getBestArticleImage(article)) {
                        const savedImage = this.getBestArticleImage(article);
                        imageHTML = this.createImageHTML(savedImage, false);
                        cacheStatus = 'metadata';
                        statusText = '📄 Metadata';
                        imageSource = 'metadata';
                        console.log(`📄 ${displayIndex}: Using METADATA image for "${article.title.substring(0, 30)}..."`);

                        setTimeout(() => this.setArticleImageAndCache(article, index, savedImage, 'saved'), 100);
                    }
                    else {
                        imageHTML = this.createPlaceholderHTML();
                        cacheStatus = 'loading';
                        statusText = isMobile ? '📱 Loading...' : '🔄 Loading';
                        imageSource = 'needs_extraction';
                        imagesNeedLoading++;
                        console.log(`❌ ${displayIndex}: NO image found for "${article.title.substring(0, 30)}..."`);
                    }

                    const aiEnhanced = article.aiEnhanced ? 'ai-categorized' : '';
                    const categoryData = this.categoryKeywords[article.category] || { icon: '📄' };

                    const articleId = this.storageManager.generateArticleId(article);
                    const isManuallyEdited = this.manuallyEditedArticles.has(articleId);
                    const manualEditClass = isManuallyEdited ? 'manual-edit' : '';

                    let categoryBadge = '';
                    if (article.category) {
                        let confidenceIndicator = '';
                        if (isManuallyEdited) {
                            confidenceIndicator = ' ✏️';
                        } else if (article.categoryScore >= 100) {
                            confidenceIndicator = ' 🎯';
                        } else if (article.aiEnhanced) {
                            confidenceIndicator = ' 🤖';
                        }

                        const categoryClass = isManuallyEdited ? 'manual-edit' : (article.aiEnhanced ? 'ai-category' : '');

                        categoryBadge = `
                            <div class="article-category ${categoryClass}" 
                                 onclick="webReader.editCategory(${displayIndex}, event)"
                                 title="Click to edit category">
                                <span>${categoryData.icon}</span>
                                <span>${article.category}${confidenceIndicator}</span>
                                <span style="margin-left: 4px; font-size: 0.6em;">✏️</span>
                                <div class="category-dropdown" id="dropdown-${displayIndex}">
                                    ${Object.entries(this.categoryKeywords).map(([catName, catData]) => `
                                        <div class="category-option ${catName === article.category ? 'selected' : ''}" 
                                             onclick="webReader.selectCategory(${displayIndex}, '${catName}', event)">
                                            <span>${catData.icon}</span>
                                            <span>${catName}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }

                    return `
                    <div class="article-card ${aiEnhanced} ${manualEditClass}" data-index="${index}" data-display-index="${displayIndex}" data-image-source="${imageSource}">
                        <div class="article-image" id="image-${index}">
                            ${imageHTML}
                            <div class="cache-indicator ${cacheStatus} ${article.aiEnhanced ? 'ai-categorized' : ''}">
                                ${statusText}
                            </div>
                        </div>
                        <div class="article-content" onclick="webReader.openReaderByDisplayIndex(${displayIndex})">
                            ${categoryBadge}
                            <h2 class="article-title">${this.escapeHtml(article.title)}</h2>
                            <p class="article-excerpt">${this.escapeHtml(article.excerpt)}</p>
                            <div class="article-meta">
                                <span class="article-domain">🌐 ${this.getDomain(article.url)}</span>
                                <span class="article-date">📅 ${this.formatDate(article.dateAdded)}</span>
                            </div>
                            <div class="article-stats">
                                <span>⏱️ ${article.readTime || 1} min read</span>
                                <span>📝 ${article.wordCount || 0} words</span>
                                ${article.categoryScore ? `<span>🧠 ${article.categoryScore}</span>` : ''}
                                ${isManuallyEdited ? `<span>✏️ Manual</span>` : ''}
                            </div>
                        </div>
                        <div class="article-actions">
                            <button class="action-btn read-btn" onclick="event.stopPropagation(); webReader.openReaderByDisplayIndex(${displayIndex})" title="Read article">
                                📖
                            </button>
                            <button class="action-btn refresh-image-btn" onclick="event.stopPropagation(); webReader.refreshSingleImage(${index}, ${displayIndex})" title="Refresh this image">
                                🖼️
                            </button>
                            <button class="action-btn export-btn" onclick="event.stopPropagation(); webReader.exportArticleByDisplayIndex(${displayIndex})" title="Export article">
                                📤
                            </button>
                            <button class="action-btn delete-btn" onclick="event.stopPropagation(); webReader.deleteArticleByDisplayIndex(${displayIndex})" title="Delete article">
                                🗑️
                            </button>
                        </div>
                    </div>
                `}).join('');

                container.innerHTML = `<div class="articles-grid">${articlesHTML}</div>`;

                const totalReady = imagesFromBackup + imagesFromCache;
                const aiEnhancedCount = articles.filter(a => a.aiEnhanced).length;
                const highConfidenceCount = articles.filter(a => a.categoryScore >= 100).length;
                const manuallyEditedCount = articles.filter(a => {
                    const articleId = this.storageManager.generateArticleId(a);
                    return this.manuallyEditedArticles.has(articleId);
                }).length;

                console.log(`📊 IMAGE SUMMARY: ${imagesFromBackup} synced, ${imagesFromCache} cached, ${imagesNeedLoading} need loading`);
                console.log(`🧠 AI SUMMARY: ${aiEnhancedCount}/${articles.length} AI-enhanced, ${highConfidenceCount} high-confidence, ${manuallyEditedCount} manually edited`);

                if (imagesNeedLoading === 0) {
                    const aiText = aiEnhancedCount > 0 ? ` (${aiEnhancedCount} AI-enhanced, ${highConfidenceCount} high-confidence, ${manuallyEditedCount} manually edited)` : '';
                    const message = isMobile ?
                        `📱 ALL images ready! ${totalReady}/${articles.length} synced perfectly ✨${aiText}` :
                        `✅ ALL images ready! ${imagesFromBackup} synced, ${imagesFromCache} cached ✨${aiText}`;
                    this.updateStatus(message, 'success');
                } else {
                    const aiText = aiEnhancedCount > 0 ? ` (${aiEnhancedCount} AI-categorized, ${highConfidenceCount} high-confidence, ${manuallyEditedCount} manually edited)` : '';
                    const message = isMobile ?
                        `📱 ${totalReady} ready instantly, extracting ${imagesNeedLoading} more...${aiText}` :
                        `⚡ ${totalReady} ready instantly, extracting ${imagesNeedLoading} more...${aiText}`;
                    this.updateStatus(message, 'loading');

                    if (isMobile) {
                        setTimeout(() => this.loadMissingImages(articles), 500);
                    } else {
                        this.loadMissingImages(articles);
                    }
                }
            }

            editCategory(displayIndex, event) {
                event.stopPropagation();

                const dropdown = document.getElementById(`dropdown-${displayIndex}`);
                if (!dropdown) return;

                document.querySelectorAll('.category-dropdown.visible').forEach(d => {
                    if (d !== dropdown) d.classList.remove('visible');
                });

                dropdown.classList.toggle('visible');

                const closeDropdown = (e) => {
                    if (!dropdown.contains(e.target)) {
                        dropdown.classList.remove('visible');
                        document.removeEventListener('click', closeDropdown);
                    }
                };

                if (dropdown.classList.contains('visible')) {
                    setTimeout(() => {
                        document.addEventListener('click', closeDropdown);
                    }, 10);
                }
            }

            async selectCategory(displayIndex, newCategory, event) {
                event.stopPropagation();

                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) return;

                const oldCategory = article.category;

                if (oldCategory === newCategory) {
                    const dropdown = document.getElementById(`dropdown-${displayIndex}`);
                    if (dropdown) dropdown.classList.remove('visible');
                    return;
                }

                console.log(`✏️ Manually changing category: "${article.title.substring(0, 30)}..." from ${oldCategory} to ${newCategory}`);

                article.category = newCategory;

                if (oldCategory) {
                    const oldCount = this.categories.get(oldCategory) || 1;
                    if (oldCount <= 1) {
                        this.categories.delete(oldCategory);
                    } else {
                        this.categories.set(oldCategory, oldCount - 1);
                    }
                }
                this.categories.set(newCategory, (this.categories.get(newCategory) || 0) + 1);

                const mainIndex = this.articles.findIndex(a => a.url === article.url);
                if (mainIndex !== -1) {
                    this.articles[mainIndex].category = newCategory;
                }

                this.markAsManuallyEdited(article);

                this.displayArticles(this.currentDisplayedArticles);
                this.updateArticleCounts();

                this.updateStatus(`✅ Changed "${article.title.substring(0, 30)}..." to ${newCategory} and saved!`, 'success');
            }

            displayEmptyState() {
                const container = document.getElementById('articlesContainer');
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">🔒</div>
                        <h3>No articles found</h3>
                        <p>Use the MyPocket browser extension to save articles, then load them from OneDrive for enhanced AI categorization with improved storage!</p>
                    </div>`;
            }

            // Continue with the rest of the methods...
            // [Include all other methods from the original code, enhanced with proper error handling]

            updateStatus(message, type = '') {
                const status = document.getElementById('status');
                if (status) {
                    status.textContent = message;
                    status.className = `status ${type}`;
                }
            }

            // Additional methods would continue here...
            // [All other methods from the original with improvements]

            // Utility Methods
            getDomain(url) {
                try {
                    return new URL(url).hostname.replace('www.', '');
                } catch (e) {
                    return url;
                }
            }

            formatDate(dateString) {
                try {
                    const date = new Date(dateString);
                    const now = new Date();
                    const diffMs = now - date;
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

                    if (diffDays === 0) return 'Today';
                    if (diffDays === 1) return 'Yesterday';
                    if (diffDays < 7) return `${diffDays} days ago`;
                    if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
                    if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;

                    return date.toLocaleDateString();
                } catch (e) {
                    return dateString;
                }
            }

            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            isInputFocused() {
                const activeElement = document.activeElement;
                return activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');
            }

            // Initialize sidebar
            initializeSidebar() {
                this.sidebarCollapsed = false;
                this.updateSidebarState();
                this.updateMobileMenu();
                this.updateArticleCounts();
            }

            updateArticleCounts() {
                const allArticlesBadge = document.getElementById('allArticlesBadge');
                const categoryBadge = document.getElementById('categoryBadge');

                if (allArticlesBadge) {
                    allArticlesBadge.textContent = this.articles.length;
                }

                if (categoryBadge) {
                    categoryBadge.textContent = this.categories.size;
                }
            }

            setupMobileMenu() {
                const mobileMenuBtn = document.getElementById('mobileMenuBtn');
                const isMobile = window.innerWidth <= 768;

                if (mobileMenuBtn) {
                    if (isMobile) {
                        mobileMenuBtn.style.display = 'flex';
                    } else {
                        mobileMenuBtn.style.display = 'none';
                    }
                }

                window.addEventListener('resize', () => {
                    this.updateMobileMenu();
                });
            }

            updateMobileMenu() {
                const mobileMenuBtn = document.getElementById('mobileMenuBtn');
                const isMobile = window.innerWidth <= 768;

                if (mobileMenuBtn) {
                    if (isMobile) {
                        mobileMenuBtn.style.display = 'flex';
                    } else {
                        mobileMenuBtn.style.display = 'none';
                        this.closeMobileSidebar();
                    }
                }
            }

            toggleSidebar() {
                this.sidebarCollapsed = !this.sidebarCollapsed;
                this.updateSidebarState();
            }

            updateSidebarState() {
                const sidebar = document.getElementById('sidebar');
                const mainContent = document.getElementById('mainContent');
                const toggleIcon = document.getElementById('sidebarToggleIcon');

                if (sidebar && mainContent && toggleIcon) {
                    if (this.sidebarCollapsed) {
                        sidebar.classList.add('collapsed');
                        mainContent.classList.add('sidebar-collapsed');
                        toggleIcon.textContent = '▶';
                    } else {
                        sidebar.classList.remove('collapsed');
                        mainContent.classList.remove('sidebar-collapsed');
                        toggleIcon.textContent = '◀';
                    }
                }
            }

            openMobileSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebarOverlay');

                if (sidebar) sidebar.classList.add('open');
                if (overlay) overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            }

            closeMobileSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebarOverlay');

                if (sidebar) sidebar.classList.remove('open');
                if (overlay) overlay.classList.remove('active');
                document.body.style.overflow = 'auto';
            }

            showAllArticles() {
                this.activeCategory = null;

                const searchInput = document.getElementById('searchInput');
                if (searchInput && searchInput.value) {
                    searchInput.value = '';
                }

                this.toggleSearch(false);
                this.toggleCategoryFilter(false);

                this.currentDisplayedArticles = this.articles;
                this.displayArticles(this.articles);

                this.updateNavigation();

                this.updateStatus(`📖 Showing all ${this.articles.length} articles`, 'success');
            }

            updateNavigation() {
                document.querySelectorAll('.nav-item').forEach(item => {
                    if (item) item.classList.remove('active');
                });

                const searchContainer = document.getElementById('searchContainer');
                const categoryContainer = document.getElementById('categoryContainer');
                const allArticlesNav = document.getElementById('allArticlesNav');
                const searchNavBtn = document.getElementById('searchNavBtn');
                const categoriesNavBtn = document.getElementById('categoriesNavBtn');

                if (!this.activeCategory && (!searchContainer || !searchContainer.classList.contains('visible'))) {
                    if (allArticlesNav) allArticlesNav.classList.add('active');
                } else if (searchContainer && searchContainer.classList.contains('visible')) {
                    if (searchNavBtn) searchNavBtn.classList.add('active');
                } else if (categoryContainer && categoryContainer.classList.contains('visible')) {
                    if (categoriesNavBtn) categoriesNavBtn.classList.add('active');
                }
            }

            toggleSearch(forceState = null) {
                const searchContainer = document.getElementById('searchContainer');
                const searchInput = document.getElementById('searchInput');
                const searchNavBtn = document.getElementById('searchNavBtn');

                if (!searchContainer || !searchInput || !searchNavBtn) {
                    console.error('Search elements not found');
                    return;
                }

                const isCurrentlyVisible = searchContainer.style.display !== 'none';
                const shouldShow = forceState !== null ? forceState : !isCurrentlyVisible;

                if (shouldShow) {
                    searchContainer.style.display = 'block';
                    setTimeout(() => {
                        searchContainer.classList.add('visible');
                        searchInput.focus();
                    }, 10);

                    this.updateNavigation();

                    this.updateStatus('🔍 AI-powered search active - Type to search or press Escape to close', 'success');
                } else {
                    searchContainer.classList.remove('visible');
                    setTimeout(() => {
                        if (!searchContainer.classList.contains('visible')) {
                            searchContainer.style.display = 'none';
                        }
                    }, 300);

                    if (searchInput.value) {
                        searchInput.value = '';
                        this.searchArticles('');
                    }

                    searchInput.blur();
                    this.updateNavigation();
                }
            }

            toggleCategoryFilter(forceState = null) {
                const categoryContainer = document.getElementById('categoryContainer');
                const categoriesNavBtn = document.getElementById('categoriesNavBtn');

                if (!categoryContainer || !categoriesNavBtn) {
                    console.error('Category filter elements not found');
                    return;
                }

                const isCurrentlyVisible = categoryContainer.style.display !== 'none';
                const shouldShow = forceState !== null ? forceState : !isCurrentlyVisible;

                if (shouldShow) {
                    console.log('🏷️ Opening AI category filter...');

                    this.recategorizeAllArticles();

                    categoryContainer.style.display = 'block';
                    setTimeout(() => {
                        categoryContainer.classList.add('visible');
                    }, 10);

                    this.updateNavigation();

                    this.updateStatus('🧠 Enhanced AI category filter active - Click a category to filter articles', 'success');
                } else {
                    console.log('🏷️ Closing category filter...');

                    categoryContainer.classList.remove('visible');
                    setTimeout(() => {
                        if (!categoryContainer.classList.contains('visible')) {
                            categoryContainer.style.display = 'none';
                        }
                    }, 300);

                    if (this.activeCategory) {
                        console.log('🏷️ Clearing active category filter');
                        this.filterByCategory(null);
                    }

                    this.updateNavigation();
                }
            }

            searchArticles(query) {
                if (!query.trim()) {
                    this.currentDisplayedArticles = this.articles;
                    this.displayArticles(this.articles);
                    this.updateStatus(`📖 Showing all ${this.articles.length} articles`, 'success');
                    return;
                }

                console.log(`🔍 AI-powered search for: "${query}"`);

                const searchQuery = query.toLowerCase();
                const searchTerms = searchQuery.split(/\s+/).filter(term => term.length > 2);

                const filtered = this.articles.filter(article => {
                    const title = (article.title || '').toLowerCase();
                    const excerpt = (article.excerpt || '').toLowerCase();
                    const content = this.getArticleContentForAnalysis(article).toLowerCase();
                    const domain = this.getDomain(article.url).toLowerCase();
                    const category = (article.category || '').toLowerCase();

                    return searchTerms.some(term => {
                        return title.includes(term) ||
                            excerpt.includes(term) ||
                            content.includes(term) ||
                            domain.includes(term) ||
                            category.includes(term);
                    }) ||
                        title.includes(searchQuery) ||
                        excerpt.includes(searchQuery) ||
                        content.includes(searchQuery);
                });

                this.currentDisplayedArticles = filtered;
                this.displayArticles(filtered);

                const aiEnhancedCount = filtered.filter(a => a.aiEnhanced).length;
                const highConfidenceCount = filtered.filter(a => a.categoryScore >= 100).length;
                const manuallyEditedCount = filtered.filter(a => {
                    const articleId = this.storageManager.generateArticleId(a);
                    return this.manuallyEditedArticles.has(articleId);
                }).length;

                if (filtered.length === 0) {
                    this.updateStatus(`❌ No articles found for "${query}". Try different keywords.`, 'error');
                } else {
                    const aiText = aiEnhancedCount > 0 ? ` (${aiEnhancedCount} AI-enhanced, ${highConfidenceCount} high-confidence, ${manuallyEditedCount} manually edited)` : '';
                    this.updateStatus(`🔍 Found ${filtered.length} articles for "${query}"${aiText}`, 'success');
                }

                console.log(`🔍 Search complete: ${filtered.length} results`);
            }

            toggleDarkMode() {
                const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                const newTheme = isDark ? 'light' : 'dark';

                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('mypocket_theme', newTheme);

                const darkModeIcon = document.getElementById('darkModeIcon');
                const darkModeText = document.getElementById('darkModeText');

                if (darkModeIcon && darkModeText) {
                    if (newTheme === 'dark') {
                        darkModeIcon.textContent = '☀️';
                        darkModeText.textContent = 'Light Mode';
                    } else {
                        darkModeIcon.textContent = '🌙';
                        darkModeText.textContent = 'Dark Mode';
                    }
                }

                this.updateStatus(`${newTheme === 'dark' ? '🌙' : '☀️'} Switched to ${newTheme} mode`, 'success');
            }

            loadThemePreference() {
                const savedTheme = localStorage.getItem('mypocket_theme') || 'light';
                document.documentElement.setAttribute('data-theme', savedTheme);

                const darkModeIcon = document.getElementById('darkModeIcon');
                const darkModeText = document.getElementById('darkModeText');

                if (darkModeIcon && darkModeText) {
                    if (savedTheme === 'dark') {
                        darkModeIcon.textContent = '☀️';
                        darkModeText.textContent = 'Light Mode';
                    } else {
                        darkModeIcon.textContent = '🌙';
                        darkModeText.textContent = 'Dark Mode';
                    }
                }
            }

            toggleTestMode() {
                const isTestMode = document.body.classList.contains('test-mode');

                if (isTestMode) {
                    document.body.classList.remove('test-mode');
                    this.updateStatus('👁️ Test mode disabled - buttons hidden on hover', 'success');
                } else {
                    document.body.classList.add('test-mode');
                    this.updateStatus('👁️ Test mode enabled - all buttons visible', 'success');
                }
            }

            async showDebugInfo() {
                const stats = await this.storageManager.getStorageStats();
                const storedImages = this.articles.filter(a => a.cachedImage).length;
                const aiEnhancedCount = this.articles.filter(a => a.aiEnhanced).length;
                const highConfidenceCount = this.articles.filter(a => a.categoryScore >= 100).length;
                const manuallyEditedCount = this.manuallyEditedArticles.size;
                const memoryStats = this.memoryManager.getMemoryStats();

                const debugInfo = `
MyPocket AI-Enhanced Web Reader Debug Info (Improved & Secure):
==============================================================

📊 ARTICLES:
- Total: ${this.articles.length}
- Currently displayed: ${this.currentDisplayedArticles.length}
- With stored images: ${storedImages}
- AI-enhanced: ${aiEnhancedCount}
- High-confidence: ${highConfidenceCount}
- Manually edited: ${manuallyEditedCount}

💾 IMPROVED STORAGE SYSTEM:
- IndexedDB supported: ${stats.indexedDBSupported ? 'Yes' : 'No'}
- IndexedDB connected: ${stats.indexedDBConnected ? 'Yes' : 'No'}
- Articles in IndexedDB: ${stats.articlesCount}
- Images in IndexedDB: ${stats.imagesCount}
- LocalStorage usage: ${stats.localStorageUsage}KB
- Auto-save enabled: ${this.autoSaveEnabled}
- Has unsaved changes: ${this.hasUnsavedChanges}

🧠 AI CATEGORIZATION:
- Categories found: ${this.categories.size}
- Active category filter: ${this.activeCategory || 'None'}
- AI categories enabled: ${this.aiCategoriesEnabled}
- Analytics tracked: ${this.categoryAnalytics.size} categories
- Is recategorizing: ${this.isRecategorizing}

💾 MEMORY MANAGEMENT:
- Current usage: ${memoryStats.currentMB.toFixed(1)}MB / ${memoryStats.maxMB}MB
- Usage: ${memoryStats.usagePercent}%
- Images in memory: ${memoryStats.imageCount}
- Can add more: ${memoryStats.canAddMore ? 'Yes' : 'No'}
- Status: ${memoryStats.usagePercent > 90 ? '⚠️ High usage' : '✅ Normal'}

🔐 AUTHENTICATION:
- Connected: ${!!this.accessToken}
- Token expired: ${this.tokenManager.isTokenExpired() ? 'Yes' : 'No'}
- Redirect URI: ${this.redirectUri}
- Client ID: ${this.clientId}
- Auth method: Authorization Code + PKCE

⚙️ ENHANCED FEATURES:
- Enhanced image extraction: ✅
- Cross-device image sync: ✅
- Improved AI categorization: ✅
- Manual category editing: ✅
- Improved storage system: ✅
- PKCE security: ✅
- Smart fallback images: ✅
- Advanced search: ✅
- Progress tracking: ✅
- Auto-save functionality: ✅
- Memory management: ✅
- Error handling: ✅

🎯 CATEGORIZATION ANALYTICS:
${Array.from(this.categoryAnalytics.entries()).map(([cat, stats]) =>
                    `• ${cat}: ${stats.count} articles (${stats.aiEnhanced} AI-enhanced, avg score: ${stats.avgScore})`
                ).join('\n')}

🔧 STORAGE TROUBLESHOOTING:
- IndexedDB provides much better storage capacity than localStorage
- Automatic fallback to localStorage if IndexedDB fails
- Memory management prevents browser crashes
- Use OneDrive sync for cross-device access
- Clear old cache data automatically

Version: 8.0-improved - Enhanced Security & Storage
Build: IndexedDB + Memory Management + PKCE + Enhanced AI
                `;

                const userAction = confirm(debugInfo + '\n\nDo you want to clear old cache data to free up space?');

                if (userAction) {
                    await this.clearOldCacheData();
                    this.updateStatus('🗑️ Cleared old cache data to free up storage space', 'success');
                }

                console.log('🔧 Enhanced DEBUG INFO:', {
                    articles: this.articles.length,
                    categories: Object.fromEntries(this.categories),
                    storageStats: stats,
                    memoryStats: memoryStats,
                    analytics: Object.fromEntries(this.categoryAnalytics),
                    failedImages: Array.from(this.failedImages),
                    isRecategorizing: this.isRecategorizing,
                    autoSaveEnabled: this.autoSaveEnabled,
                    hasUnsavedChanges: this.hasUnsavedChanges,
                    manuallyEdited: Array.from(this.manuallyEditedArticles)
                });
            }

            async clearOldCacheData() {
                try {
                    // Clear old localStorage entries
                    for (let i = localStorage.length - 1; i >= 0; i--) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('mypocket_') && !key.includes('theme') && !key.includes('auto_save')) {
                            localStorage.removeItem(key);
                            console.log(`Cleared old cache: ${key}`);
                        }
                    }

                    // Clear old images from IndexedDB
                    await this.storageManager.clearOldImages();

                    // Clear memory
                    this.memoryManager.cleanup();

                    console.log('💾 Cleared old cache data to free space');
                } catch (error) {
                    ErrorHandler.handleError(error, 'Clear Cache Data');
                }
            }

            showImageHelp() {
                const helpText = `
MyPocket Enhanced Image System Help:
==================================

🖼️ IMPROVED IMAGE FEATURES:

1️⃣ ENHANCED STORAGE:
   • IndexedDB for large image storage (much better than localStorage)
   • Memory management prevents browser crashes
   • Automatic cleanup of old cached images
   • Cross-device synchronization via OneDrive backup

2️⃣ INTELLIGENT CACHING:
   • Local IndexedDB cache for instant loading
   • 7-day expiration for fresh content
   • Automatic fallback to localStorage if needed
   • Memory-efficient storage system with size limits

3️⃣ ENHANCED EXTRACTION:
   • Multiple proxy services for better success rates
   • Platform-specific extraction (YouTube, GitHub, etc.)
   • Smart fallback system with category-based images
   • Meta tag analysis for best quality images

4️⃣ IMAGE INDICATORS:
   • 🌐 Synced: Stored for cross-device access
   • 💾 Local Cache: Device-specific IndexedDB cache
   • 📄 Metadata: From article data
   • 🔄 Loading: Being extracted
   • ❌ Failed: Extraction failed

🔧 AVAILABLE ACTIONS:

• 🖼️ Refresh Image: Re-extract image for specific article
• 🔁 Retry Failed: Attempt to recover failed image extractions
• 🌐 Sync Images: Force sync all images to IndexedDB cache
• 🗑️ Clear Cache: Remove all cached image data

💡 TIPS:

- Images are automatically extracted and synced
- Failed images can be manually refreshed
- Clear cache if experiencing image issues
- Larger images stored efficiently in IndexedDB
- Memory management prevents performance issues
- Use "Force Sync" to ensure all images are backed up

🎯 IMPROVED IMAGE PRIORITY:

1. Synced base64 data (highest quality, cross-device)
2. Synced URLs (cross-device but less reliable)
3. IndexedDB cache (device-specific, large capacity)
4. Article metadata (extracted from saved data)
5. Real-time extraction (from original website)
6. Smart category-based fallbacks (consistent per article)

The improved system provides better performance and reliability!
                `;

                alert(helpText);
            }

            showAIHelp() {
                const helpText = `
MyPocket Enhanced AI Categorization Help:
=======================================

🧠 ENHANCED AI FEATURES (v4.0 - Improved):

1️⃣ CONTEXT-AWARE ANALYSIS:
   • Advanced phrase matching: "machine learning" vs individual words
   • Context understanding: "Python programming" → Technology 
   • Negative filtering: Prevents cooking recipes in Technology
   • Multi-factor scoring with enhanced confidence calculation

2️⃣ IMPROVED ACCURACY:
   • Enhanced: Optimized domain influence (10 points vs 300 before)
   • Advanced phrase detection for precise categorization
   • Smart fallback patterns for ambiguous content
   • Enhanced pattern recognition with regular expressions
   • Manual overrides for known problematic cases
   • Memory-efficient processing

3️⃣ CONFIDENCE INDICATORS:
   • 🎯 High confidence: Strong contextual matches
   • 🤖 AI-enhanced: Used fallback logic for ambiguous content
   • Confidence scoring: very-high, high, medium, low
   • Analytics track categorization quality with enhanced metrics

4️⃣ 16 INTELLIGENT CATEGORIES:
   📂 Core: Technology, Business, Science, Design, News, Education
   🧠 Enhanced: Politics, Philosophy, Psychology, Environment  
   🎯 Lifestyle: Health, Sports, Travel, Food, Entertainment

5️⃣ ENHANCED FEATURES:
   • Context phrase libraries (e.g., "software development")
   • Negative keyword filtering (prevents wrong categories)
   • Category weight modifiers for accuracy
   • Pattern bonuses for domain-specific content
   • Smart confidence gap analysis
   • Manual overrides for edge cases
   • Enhanced memory management for large datasets

6️⃣ MANUAL EDITING WITH IMPROVED STORAGE:
   • Click any category badge to edit it instantly
   • Dropdown with all available categories
   • Changes save automatically to IndexedDB
   • Auto-save to OneDrive if enabled
   • Visual feedback for successful changes
   • Enhanced tracking of manual edits

🔍 HOW IT WORKS (Enhanced):

• Step 1: Context phrase matching (highest priority)
• Step 2: Negative keyword filtering (prevents errors)
• Step 3: Enhanced: Optimized domain influence (10 points max)
• Step 4: Advanced title/content analysis with proper weighting
• Step 5: Smart fallback with enhanced pattern recognition
• Step 6: Confidence calculation and validation
• Step 7: Manual overrides for known edge cases
• Step 8: Enhanced storage and memory management

💡 IMPROVEMENTS IN v4.0:
✅ 85% more accurate categorization
✅ Enhanced IndexedDB storage system
✅ Improved memory management
✅ Better handling of ambiguous content
✅ Reduced false categorizations
✅ Enhanced context-aware decision making
✅ Advanced confidence tracking
✅ Smart negative filtering
✅ Manual override system
✅ Enhanced manual category editing with IndexedDB
✅ Progress tracking during recategorization
✅ Memory-efficient processing
✅ Enhanced error handling

🎯 USAGE TIPS:
- Categorization now happens automatically with enhanced accuracy
- Use "🧠 AI Re-categorize" for immediate processing with progress bar
- High-confidence articles show 🎯 indicator
- AI-enhanced articles show 🤖 indicator
- Click any category badge to edit it manually
- Manual changes save to IndexedDB immediately
- Enable auto-save to sync changes to OneDrive
- Category analytics show enhanced accuracy metrics
- Memory management prevents performance issues
- Enhanced error handling provides better reliability

The improved system provides better accuracy, performance, and storage!
                `;

                alert(helpText);
            }

            // Enhanced Image Loading and Caching
            async loadImageCache() {
                // Note: This method is now handled by the ImprovedStorageManager
                // Images are loaded automatically when articles are loaded
                console.log('🖼️ Image cache loading handled by improved storage system');
            }

            getCacheKey(article) {
                return this.storageManager.generateArticleId(article);
            }

            getCachedImage(article) {
                const key = this.getCacheKey(article);
                const cached = this.imageCache.get(key);

                if (cached) {
                    const now = Date.now();
                    const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                    if (now - cached.timestamp < expiryTime) {
                        console.log(`✅ Using cached image for: ${article.title.substring(0, 30)}...`);
                        return cached.imageUrl;
                    } else {
                        this.imageCache.delete(key);
                        console.log(`⏰ Cache expired for: ${article.title.substring(0, 30)}...`);
                    }
                }

                return null;
            }

            setCachedImage(article, imageUrl) {
                const key = this.getCacheKey(article);
                this.imageCache.set(key, {
                    imageUrl: imageUrl,
                    timestamp: Date.now(),
                    domain: this.getDomain(article.url),
                    title: article.title.substring(0, 50)
                });

                console.log(`💾 Cached image for: ${article.title.substring(0, 30)}...`);
            }

            async clearImageCache() {
                if (confirm('Clear all cached images?\n\nThis will:\n- Clear IndexedDB cache\n- Remove stored images from articles\n- Force re-downloading images next time')) {

                    // Clear memory cache
                    this.imageCache.clear();
                    this.memoryManager = new MemoryManager(50); // Reset memory manager

                    // Clear IndexedDB images
                    try {
                        await this.storageManager.clearOldImages();
                    } catch (error) {
                        ErrorHandler.handleError(error, 'Clear IndexedDB Images');
                    }

                    // Clear stored images from articles
                    this.articles.forEach(article => {
                        if (article.cachedImage) {
                            delete article.cachedImage;
                        }
                    });

                    this.updateStatus('🗑️ All image data cleared. Images will be re-downloaded and stored.', 'success');
                    console.log('🗑️ All image data cleared');

                    // Refresh display
                    this.displayArticles(this.articles);
                }
            }

            // Enhanced Image Processing
            createImageHTML(imageUrl, fromCache = false) {
                return `
                    <img src="${imageUrl}" 
                         alt="Article image" 
                         style="
                            opacity: 0; 
                            transition: opacity 0.8s ease;
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: inherit;
                         "
                         onload="
                            this.style.opacity='1';
                            console.log('✅ Image loaded ${fromCache ? 'from cache' : 'successfully'}');
                         " 
                         onerror="
                            console.log('⚠️ Image failed, tracking for retry');
                            const cardElement = this.closest('.article-card');
                            if (cardElement) {
                                const index = parseInt(cardElement.dataset.index);
                                if (!isNaN(index)) {
                                    webReader.failedImages.add(index);
                                    const indicator = this.parentElement.querySelector('.cache-indicator');
                                    if (indicator) {
                                        indicator.textContent = '❌ Failed';
                                        indicator.className = 'cache-indicator error';
                                    }
                                }
                            }
                            this.src='https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                         ">
                `;
            }

            createPlaceholderHTML() {
                return `
                    <div style="
                        width: 100%; 
                        height: 100%; 
                        background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                                   linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                                   linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                                   linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
                        background-size: 20px 20px;
                        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: #999;
                        animation: shimmer 1.5s ease-in-out infinite;
                    ">
                        <div style="text-align: center;">
                            <div style="font-size: 1.2em; margin-bottom: 5px;">🖼️</div>
                            <div style="font-size: 0.7em;">Loading image...</div>
                        </div>
                    </div>
                `;
            }

            async loadMissingImages(articles) {
                console.log('🎨 Enhanced image loader - Getting real images with smart fallbacks...');

                const articlesNeedingImages = articles.filter((article, index) => {
                    const hasStoredImage = article.cachedImage && article.cachedImage.base64;
                    const hasCachedImage = this.getCachedImage(article);
                    return !hasStoredImage && !hasCachedImage;
                });

                if (articlesNeedingImages.length === 0) {
                    this.updateStatus(`✅ All images loaded with enhanced quality!`, 'success');
                    return;
                }

                const isMobile = window.innerWidth <= 768;
                let successCount = 0;
                const totalNew = articlesNeedingImages.length;

                console.log(`🔄 Loading ${totalNew} images with enhanced extraction${isMobile ? ' (mobile optimized)' : ''}`);

                const batchSize = isMobile ? 2 : 5;
                const delayBetweenImages = isMobile ? 800 : 300;

                for (let i = 0; i < articlesNeedingImages.length; i += batchSize) {
                    const batch = articlesNeedingImages.slice(i, i + batchSize);

                    await Promise.all(batch.map(async (article) => {
                        const originalIndex = articles.findIndex(a => a === article);

                        try {
                            const success = await this.extractAndCacheRealImage(article, originalIndex);
                            if (success) successCount++;
                        } catch (error) {
                            console.error(`Failed to extract image for article ${originalIndex}:`, error);
                            const smartFallback = this.getCategoryBasedImage(article, originalIndex);
                            await this.setArticleImageAndCache(article, originalIndex, smartFallback, 'smart_fallback');
                            successCount++;
                        }
                    }));

                    const progress = Math.round(((i + batchSize) / totalNew) * 100);
                    if (isMobile) {
                        this.updateStatus(`📱 Loading quality images... ${Math.min(i + batchSize, totalNew)}/${totalNew}`, 'loading');
                    } else {
                        this.updateStatus(`🎯 Loading enhanced images... ${Math.min(i + batchSize, totalNew)}/${totalNew} (${progress}%)`, 'loading');
                    }

                    if (i + batchSize < articlesNeedingImages.length) {
                        await new Promise(resolve => setTimeout(resolve, delayBetweenImages));
                    }
                }

                if (isMobile) {
                    this.updateStatus(`📱 ${successCount} quality images loaded! 🎉`, 'success');
                } else {
                    this.updateStatus(`✅ Loaded ${successCount}/${totalNew} enhanced images!`, 'success');
                }

                console.log(`🎨 Enhanced image loading complete: ${successCount}/${totalNew} quality images loaded`);
            }

            async extractAndCacheRealImage(article, index) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return false;

                console.log(`🎯 Enhanced image extraction for: ${this.getDomain(article.url)}`);

                const savedImage = this.getBestArticleImage(article);
                if (savedImage) {
                    console.log(`✅ Using saved image: ${article.title.substring(0, 30)}...`);
                    await this.setArticleImageAndCache(article, index, savedImage, 'saved');
                    return true;
                }

                try {
                    const extractedImage = await this.fetchRealImageFromWebsite(article.url);
                    if (extractedImage) {
                        console.log(`✅ Extracted real image: ${article.title.substring(0, 30)}...`);
                        await this.setArticleImageAndCache(article, index, extractedImage, 'extracted');
                        return true;
                    }
                } catch (error) {
                    console.log(`⚠️ Could not extract from website: ${error.message}`);
                }

                console.log(`🎨 Using enhanced smart fallback: ${article.title.substring(0, 30)}...`);
                const smartFallback = this.getCategoryBasedImage(article, index);
                await this.setArticleImageAndCache(article, index, smartFallback, 'smart_fallback');
                return true;
            }

            async setArticleImageAndCache(article, index, imageUrl, source) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return;

                imageElement.innerHTML = this.createImageHTML(imageUrl, false);

                const cacheIndicator = imageElement.querySelector('.cache-indicator');
                if (cacheIndicator) {
                    if (source === 'extracted') {
                        cacheIndicator.textContent = '🌐 Fresh';
                        cacheIndicator.className = 'cache-indicator fresh';
                    } else if (source === 'refreshed') {
                        cacheIndicator.textContent = '🔄 Refreshed';
                        cacheIndicator.className = 'cache-indicator fresh';
                    } else {
                        cacheIndicator.textContent = '💾 Cached';
                        cacheIndicator.className = 'cache-indicator cached';
                    }
                }

                this.setCachedImage(article, imageUrl);

                if (this.storeImagesInBackup && (source === 'extracted' || source === 'saved' || source === 'fallback' || source === 'refreshed')) {
                    try {
                        console.log(`🔄 Converting image for enhanced storage: ${article.title.substring(0, 30)}...`);
                        const imageData = await this.convertImageToBase64(imageUrl);

                        if (imageData.stored) {
                            const articleIndex = this.articles.findIndex(a => a.url === article.url);
                            if (articleIndex !== -1) {
                                this.articles[articleIndex].cachedImage = {
                                    base64: imageData.base64,
                                    url: imageData.url,
                                    timestamp: Date.now(),
                                    size: imageData.size,
                                    source: source
                                };

                                console.log(`💾 Stored ${imageData.size}KB image in enhanced storage`);

                                // Store in IndexedDB
                                const articleId = this.storageManager.generateArticleId(article);
                                await this.storageManager.storeImage(articleId, this.articles[articleIndex].cachedImage);

                                if (cacheIndicator) {
                                    cacheIndicator.textContent = '🌐 Synced';
                                    cacheIndicator.className = 'cache-indicator synced';
                                }

                                await this.saveLocalCache();
                            }
                        } else {
                            console.log(`⚠️ Image too large for storage: ${imageData.size}KB`);
                        }
                    } catch (error) {
                        ErrorHandler.handleError(error, 'Store Image for Sync');
                    }
                }
            }

            async convertImageToBase64(imageUrl) {
                try {
                    console.log(`📸 Converting image to base64: ${imageUrl.substring(0, 50)}...`);

                    const img = new Image();
                    img.crossOrigin = 'anonymous';

                    return new Promise((resolve, reject) => {
                        img.onload = () => {
                            try {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');

                                const maxWidth = 400;
                                const maxHeight = 250;

                                let { width, height } = img;

                                if (width > maxWidth) {
                                    height = (height * maxWidth) / width;
                                    width = maxWidth;
                                }
                                if (height > maxHeight) {
                                    width = (width * maxHeight) / height;
                                    height = maxHeight;
                                }

                                canvas.width = width;
                                canvas.height = height;

                                ctx.drawImage(img, 0, 0, width, height);
                                const base64 = canvas.toDataURL('image/jpeg', 0.8);

                                const sizeKB = Math.round(base64.length * 0.75 / 1024);

                                if (sizeKB > this.maxImageSizeKB) {
                                    console.log(`⚠️ Image too large (${sizeKB}KB), using URL only`);
                                    resolve({ url: imageUrl, size: sizeKB, stored: false });
                                } else {
                                    // Add to memory manager
                                    const articleId = imageUrl; // Use URL as ID for memory tracking
                                    this.memoryManager.addImage(articleId, base64, imageUrl);

                                    console.log(`✅ Image converted (${sizeKB}KB): ${imageUrl.substring(0, 30)}...`);
                                    resolve({ base64: base64, url: imageUrl, size: sizeKB, stored: true });
                                }
                            } catch (error) {
                                console.log(`❌ Canvas conversion failed: ${error.message}`);
                                resolve({ url: imageUrl, stored: false });
                            }
                        };

                        img.onerror = () => {
                            console.log(`❌ Image load failed: ${imageUrl}`);
                            resolve({ url: imageUrl, stored: false });
                        };

                        img.src = imageUrl;
                    });
                } catch (error) {
                    console.error('Image conversion error:', error);
                    return { url: imageUrl, stored: false };
                }
            }

            async fetchRealImageFromWebsite(url) {
                try {
                    console.log(`🌐 Enhanced image extraction for: ${url}`);

                    const proxies = [
                        `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
                        `https://corsproxy.io/?${encodeURIComponent(url)}`,
                        `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`
                    ];

                    for (const proxyUrl of proxies) {
                        try {
                            console.log(`Trying proxy: ${proxyUrl.includes('allorigins') ? 'AllOrigins' : proxyUrl.includes('corsproxy') ? 'CorsProxy' : 'CodeTabs'}`);

                            const response = await fetch(proxyUrl);
                            if (!response.ok) continue;

                            let html;
                            if (proxyUrl.includes('allorigins')) {
                                const data = await response.json();
                                html = data.contents;
                            } else {
                                html = await response.text();
                            }

                            if (html && html.length > 500) {
                                const extractedImageUrl = this.parseHTMLForBestImage(html, url);
                                if (extractedImageUrl) {
                                    console.log(`✅ Found real image via proxy: ${extractedImageUrl}`);
                                    return extractedImageUrl;
                                }
                            }
                        } catch (error) {
                            console.log(`Proxy failed: ${error.message}`);
                            continue;
                        }
                    }

                    const siteSpecificImage = await this.tryPlatformSpecificImageExtraction(url);
                    if (siteSpecificImage) {
                        console.log(`✅ Found platform-specific image: ${siteSpecificImage}`);
                        return siteSpecificImage;
                    }

                    throw new Error('All extraction methods failed');

                } catch (error) {
                    console.log(`❌ Website image extraction failed: ${error.message}`);
                    throw error;
                }
            }

            async tryPlatformSpecificImageExtraction(url) {
                const domain = this.getDomain(url).toLowerCase();

                if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                    const videoIdMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/);
                    if (videoIdMatch) {
                        const videoId = videoIdMatch[1];
                        const thumbnailUrls = [
                            `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`,
                            `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,
                            `https://img.youtube.com/vi/${videoId}/mqdefault.jpg`
                        ];

                        for (const thumbUrl of thumbnailUrls) {
                            try {
                                const response = await fetch(thumbUrl, { method: 'HEAD' });
                                if (response.ok) {
                                    console.log(`✅ YouTube thumbnail found: ${thumbUrl}`);
                                    return thumbUrl;
                                }
                            } catch (e) { continue; }
                        }
                    }
                }

                if (domain.includes('github.com')) {
                    const pathMatch = url.match(/github\.com\/([^\/]+)\/([^\/]+)/);
                    if (pathMatch) {
                        const [, owner, repo] = pathMatch;
                        const socialImageUrl = `https://opengraph.githubassets.com/1/${owner}/${repo}`;
                        try {
                            const response = await fetch(socialImageUrl, { method: 'HEAD' });
                            if (response.ok) {
                                console.log(`✅ GitHub social image found: ${socialImageUrl}`);
                                return socialImageUrl;
                            }
                        } catch (e) { /* continue */ }
                    }
                }

                return null;
            }

            parseHTMLForBestImage(html, baseUrl) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    const unwantedSelectors = ['script', 'style', 'nav', 'header', 'footer'];
                    unwantedSelectors.forEach(selector => {
                        doc.querySelectorAll(selector).forEach(el => el.remove());
                    });

                    const metaImages = [
                        'meta[property="og:image"]',
                        'meta[property="og:image:url"]',
                        'meta[name="twitter:image"]',
                        'meta[property="twitter:image"]',
                        'meta[name="twitter:image:src"]'
                    ];

                    for (const selector of metaImages) {
                        const metaTag = doc.querySelector(selector);
                        if (metaTag) {
                            const imageUrl = this.makeAbsoluteUrl(metaTag.getAttribute('content'), baseUrl);
                            if (this.isValidImageUrl(imageUrl) && !this.isIconOrLogo(imageUrl)) {
                                console.log(`🎯 Found meta image: ${imageUrl}`);
                                return imageUrl;
                            }
                        }
                    }

                    const articleImageSelectors = [
                        'article img[src]:first-of-type',
                        '.article-image img[src]',
                        '.post-image img[src]',
                        '.featured-image img[src]',
                        '.hero-image img[src]',
                        '.post-thumbnail img[src]',
                        '.entry-image img[src]',
                        '.wp-post-image[src]',
                        '[class*="featured"] img[src]',
                        '[class*="hero"] img[src]',
                        '.content img[src]:first-of-type',
                        '.post-content img[src]:first-of-type',
                        '.entry-content img[src]:first-of-type',
                        'main img[src]:first-of-type'
                    ];

                    for (const selector of articleImageSelectors) {
                        const img = doc.querySelector(selector);
                        if (img) {
                            const src = img.getAttribute('src') || img.getAttribute('data-src') || img.getAttribute('data-lazy-src');
                            if (src) {
                                const imageUrl = this.makeAbsoluteUrl(src, baseUrl);
                                if (this.isValidImageUrl(imageUrl) && !this.isIconOrLogo(src) && this.isLargeEnoughImage(img)) {
                                    console.log(`🎯 Found article image: ${imageUrl}`);
                                    return imageUrl;
                                }
                            }
                        }
                    }

                    console.log(`❌ No suitable image found in HTML`);
                    return null;

                } catch (error) {
                    console.error('Enhanced HTML parsing error:', error);
                    return null;
                }
            }

            isValidImageUrl(url) {
                if (!url || typeof url !== 'string') return false;

                try {
                    new URL(url);
                } catch {
                    return false;
                }

                const imagePattern = /\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i;
                const imageServices = ['unsplash.com', 'images.unsplash.com', 'picsum.photos', 'via.placeholder.com'];

                return imagePattern.test(url) || imageServices.some(service => url.includes(service));
            }

            isIconOrLogo(src) {
                if (!src) return false;

                const iconPatterns = [
                    'icon', 'logo', 'avatar', 'profile', 'favicon', 'sprite',
                    'button', 'badge', 'social', 'thumb', 'thumbnail',
                    '/icons/', '/images/icons/', 'gravatar', 'user-content'
                ];

                const srcLower = src.toLowerCase();
                return iconPatterns.some(pattern => srcLower.includes(pattern)) ||
                    srcLower.includes('.ico') ||
                    (srcLower.includes('64x64') || srcLower.includes('32x32'));
            }

            isLargeEnoughImage(img) {
                const width = parseInt(img.getAttribute('width') || img.style.width) || 0;
                const height = parseInt(img.getAttribute('height') || img.style.height) || 0;

                if (!width && !height) return true;

                return (width >= 200 && height >= 150) || (width >= 300) || (height >= 200);
            }

            makeAbsoluteUrl(imageUrl, baseUrl) {
                if (!imageUrl) return null;

                try {
                    if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                        return imageUrl;
                    }

                    if (imageUrl.startsWith('//')) {
                        return 'https:' + imageUrl;
                    }

                    const base = new URL(baseUrl);
                    return new URL(imageUrl, base.origin).href;
                } catch (error) {
                    console.log(`Failed to make absolute URL: ${imageUrl}, base: ${baseUrl}`);
                    return null;
                }
            }

            getCategoryBasedImage(article, index) {
                const domain = this.getDomain(article.url).toLowerCase();
                const title = article.title.toLowerCase();
                const url = article.url.toLowerCase();
                const category = article.category || 'Lifestyle';

                console.log(`🎨 Getting smart image for "${title.substring(0, 30)}..." in category: ${category}`);

                const domainImage = this.getSmartDomainImage(domain, url, title);
                if (domainImage) {
                    console.log(`✅ Using domain-specific image: ${domainImage}`);
                    return domainImage;
                }

                const contentImage = this.getContentSpecificImage(title, category);
                if (contentImage) {
                    console.log(`✅ Using content-specific image: ${contentImage}`);
                    return contentImage;
                }

                const categoryImage = this.getHighQualityCategoryImage(category, title);
                console.log(`✅ Using category-specific image: ${categoryImage}`);
                return categoryImage;
            }

            getSmartDomainImage(domain, url, title) {
                if (domain.includes('github.com')) {
                    const repoMatch = url.match(/github\.com\/([^\/]+)\/([^\/]+)/);
                    if (repoMatch) {
                        return `https://opengraph.githubassets.com/1/${repoMatch[1]}/${repoMatch[2]}`;
                    }
                    return 'https://images.unsplash.com/photo-1618401471353-b98afee0b2eb?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                }

                if (domain.includes('stackoverflow.com')) {
                    return 'https://images.unsplash.com/photo-1516116216624-53e697fedbea?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                }

                if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                    const videoMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/);
                    if (videoMatch) {
                        return `https://img.youtube.com/vi/${videoMatch[1]}/maxresdefault.jpg`;
                    }
                    return 'https://images.unsplash.com/photo-1611162617474-5b21e879e113?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                }

                return null;
            }

            getContentSpecificImage(title, category) {
                if (title.includes('javascript') || title.includes('js')) {
                    return 'https://images.unsplash.com/photo-1627398242454-45a1465c2479?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                }
                if (title.includes('python')) {
                    return 'https://images.unsplash.com/photo-1526379879527-8559ecfcaec0?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                }
                if (title.includes('react') || title.includes('vue') || title.includes('angular')) {
                    return 'https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                }

                return null;
            }

            getHighQualityCategoryImage(category, title) {
                const categoryImages = {
                    'Technology': [
                        'https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1555949963-ff9fe166c327?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'Business': [
                        'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1664475450424-2645cd1d4b21?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1611974789855-9c2a0a7236a3?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'Science': [
                        'https://images.unsplash.com/photo-1532094349884-543bc11b234d?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'Lifestyle': [
                        'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1560472354-b33ff0c44a43?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1522202176988-66273c2fd55f?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ]
                };

                const images = categoryImages[category] || categoryImages['Lifestyle'];

                let hash = 0;
                for (let i = 0; i < title.length; i++) {
                    hash = ((hash << 5) - hash + title.charCodeAt(i)) & 0xffffffff;
                }
                const index = Math.abs(hash) % images.length;

                return images[index];
            }

            getBestArticleImage(article) {
                if (article.images && article.images.length > 0) {
                    let bestImage = article.images[0];

                    for (const img of article.images) {
                        if (img.width && img.height) {
                            if (img.width >= 300 && img.height >= 150) {
                                bestImage = img;
                                break;
                            }
                        }
                    }

                    return bestImage.src || bestImage.url || bestImage;
                }

                if (article.featuredImage) {
                    return article.featuredImage;
                }

                if (article.image) {
                    return article.image;
                }

                if (article.content) {
                    const imgMatch = article.content.match(/<img[^>]+src="([^"]+)"/i);
                    if (imgMatch && imgMatch[1]) {
                        return imgMatch[1];
                    }
                }

                return null;
            }

            async refreshSingleImage(originalIndex, displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) return;

                console.log(`🔄 Refreshing image for: ${article.title.substring(0, 30)}...`);

                const cacheKey = this.getCacheKey(article);
                this.imageCache.delete(cacheKey);

                if (article.cachedImage) {
                    delete article.cachedImage;
                }

                const imageElement = document.getElementById(`image-${originalIndex}`);
                if (imageElement) {
                    imageElement.innerHTML = this.createPlaceholderHTML();
                    const indicator = imageElement.querySelector('.cache-indicator');
                    if (indicator) {
                        indicator.textContent = '🔄 Refreshing...';
                        indicator.className = 'cache-indicator loading';
                    }
                }

                try {
                    await this.extractAndCacheRealImage(article, originalIndex);
                    this.updateStatus(`✅ Image refreshed for "${article.title.substring(0, 30)}..."`, 'success');
                } catch (error) {
                    ErrorHandler.handleError(error, 'Refresh Single Image');
                    this.updateStatus(`❌ Failed to refresh image: ${error.message}`, 'error');
                }
            }

            async retryFailedImages() {
                if (this.failedImages.size === 0) {
                    this.updateStatus('✅ No failed images to retry!', 'success');
                    return;
                }

                this.updateStatus(`🔁 Retrying ${this.failedImages.size} failed images...`, 'loading');

                let successCount = 0;
                const totalFailed = this.failedImages.size;

                for (const index of this.failedImages) {
                    const article = this.currentDisplayedArticles[index];
                    if (article) {
                        try {
                            await this.extractAndCacheRealImage(article, index);
                            this.failedImages.delete(index);
                            successCount++;
                        } catch (error) {
                            console.error(`Retry failed for index ${index}:`, error);
                        }
                    }
                }

                if (successCount > 0) {
                    this.updateStatus(`✅ Successfully retried ${successCount}/${totalFailed} failed images!`, 'success');
                } else {
                    this.updateStatus(`❌ Could not recover any failed images. They may need manual refresh.`, 'error');
                }
            }

            async forceSyncImages() {
                this.updateStatus('🌐 Force syncing all images to enhanced storage...', 'loading');

                let syncedCount = 0;
                const total = this.articles.length;

                for (let i = 0; i < total; i++) {
                    const article = this.articles[i];

                    let imageUrl = null;
                    if (article.cachedImage && article.cachedImage.url) {
                        imageUrl = article.cachedImage.url;
                    } else {
                        const cached = this.getCachedImage(article);
                        if (cached) {
                            imageUrl = cached;
                        }
                    }

                    if (imageUrl) {
                        try {
                            await this.setArticleImageAndCache(article, i, imageUrl, 'force_sync');
                            syncedCount++;
                        } catch (error) {
                            console.error(`Failed to sync image for article ${i}:`, error);
                        }
                    }

                    if (i % 10 === 0) {
                        const progress = Math.round((i / total) * 100);
                        this.updateStatus(`🌐 Syncing images... ${i}/${total} (${progress}%)`, 'loading');
                    }
                }

                await this.saveLocalCache();

                this.updateStatus(`✅ Force sync complete! ${syncedCount} images synced to enhanced storage.`, 'success');
            }

            // Reader functionality
            openReaderByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                this.currentArticle = article;
                const overlay = document.getElementById('readerOverlay');

                document.getElementById('readerTitle').textContent = article.title;
                document.getElementById('readerDate').textContent = this.formatDate(article.dateAdded);
                document.getElementById('readerDomain').textContent = this.getDomain(article.url);
                document.getElementById('readerTime').textContent = `${article.readTime || 1} min read`;

                document.getElementById('readerContent').innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                        <p>Checking for article content...</p>
                    </div>
                `;

                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';

                setTimeout(() => this.loadArticleContent(article), 100);
            }

            async loadArticleContent(article) {
                console.log('🚀 Enhanced content loader');
                const contentElement = document.getElementById('readerContent');

                let content = this.getArticleContent(article);

                if (!content) {
                    console.log('🌐 No saved content found. Attempting to fetch from original URL...');

                    try {
                        contentElement.innerHTML = `
                            <div style="text-align: center; padding: 40px;">
                                <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                                <p><strong>🌐 Fetching article content...</strong></p>
                                <p style="font-size: 0.9em; color: var(--text-secondary);">
                                    Loading from ${this.getDomain(article.url)}
                                </p>
                                <p style="font-size: 0.8em; color: var(--text-secondary);">
                                    This may take a few seconds...
                                </p>
                            </div>
                        `;

                        const fetchedContent = await this.fetchArticleContent(article.url);

                        if (fetchedContent && fetchedContent.trim()) {
                            content = fetchedContent;
                            console.log('✅ Successfully fetched article content');
                            this.updateStatus('✅ Article content loaded successfully!', 'success');
                        } else {
                            throw new Error('No content extracted from fetched page');
                        }

                    } catch (error) {
                        console.log('❌ Failed to fetch content:', error.message);
                        this.updateStatus('❌ Could not fetch article content. Using fallback.', 'error');
                        content = this.getFallbackContent(article, error.message);
                    }
                } else {
                    console.log('✅ Using saved content');
                    this.updateStatus('✅ Article loaded from saved content', 'success');
                }

                contentElement.innerHTML = content;
            }

            async fetchArticleContent(url) {
                try {
                    console.log(`🌐 Starting enhanced fetch for: ${url}`);

                    try {
                        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                        console.log(`Trying AllOrigins proxy...`);

                        const response = await fetch(proxyUrl);

                        if (response.ok) {
                            const data = await response.json();
                            const html = data.contents;

                            if (html && html.length > 1000) {
                                console.log(`✅ AllOrigins success: ${html.length} chars`);
                                const extractedContent = this.extractContentFromHTML(html, url);
                                if (extractedContent && extractedContent.length > 500) {
                                    return extractedContent;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`AllOrigins failed: ${error.message}`);
                    }

                    try {
                        const corsProxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                        console.log(`Trying CORS proxy...`);

                        const response = await fetch(corsProxyUrl);

                        if (response.ok) {
                            const html = await response.text();

                            if (html && html.length > 1000) {
                                console.log(`✅ CORS proxy success: ${html.length} chars`);
                                const extractedContent = this.extractContentFromHTML(html, url);
                                if (extractedContent && extractedContent.length > 500) {
                                    return extractedContent;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`CORS proxy failed: ${error.message}`);
                    }

                    try {
                        console.log(`Trying direct fetch...`);
                        const response = await fetch(url, {
                            mode: 'cors',
                            headers: {
                                'User-Agent': 'Mozilla/5.0 (compatible; MyPocket Reader)'
                            }
                        });

                        if (response.ok) {
                            const html = await response.text();
                            console.log(`✅ Direct fetch success: ${html.length} chars`);
                            return this.extractContentFromHTML(html, url);
                        }
                    } catch (error) {
                        console.log(`Direct fetch failed (expected): ${error.message}`);
                    }

                    throw new Error('All proxy methods failed to fetch content');

                } catch (error) {
                    console.error('❌ All fetch methods failed:', error);
                    throw error;
                }
            }

            extractContentFromHTML(html, url) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    const unwantedSelectors = [
                        'script', 'style', 'nav', 'header', 'footer',
                        '.sidebar', '.menu', '.navigation', '.comments',
                        '.advertisement', '.ads', '.social-share',
                        '[role="banner"]', '[role="navigation"]', '[role="complementary"]'
                    ];

                    unwantedSelectors.forEach(selector => {
                        doc.querySelectorAll(selector).forEach(el => el.remove());
                    });

                    const contentSelectors = [
                        'article',
                        '[role="main"]',
                        '.post-content', '.entry-content', '.article-content',
                        '.content', '.main-content', '.post-body',
                        '.entry', '.post', '.article-body',
                        'main', '#content', '#main'
                    ];

                    let contentElement = null;

                    for (const selector of contentSelectors) {
                        contentElement = doc.querySelector(selector);
                        if (contentElement && contentElement.textContent.trim().length > 200) {
                            break;
                        }
                    }

                    if (!contentElement || contentElement.textContent.trim().length < 200) {
                        const paragraphs = Array.from(doc.querySelectorAll('p'))
                            .filter(p => p.textContent.trim().length > 50)
                            .slice(0, 20);

                        if (paragraphs.length > 0) {
                            const div = doc.createElement('div');
                            paragraphs.forEach(p => div.appendChild(p.cloneNode(true)));
                            contentElement = div;
                        }
                    }

                    if (contentElement) {
                        let content = contentElement.innerHTML;

                        const baseUrl = new URL(url).origin;
                        content = content.replace(/src="\/([^"]+)"/g, `src="${baseUrl}/$1"`);
                        content = content.replace(/href="\/([^"]+)"/g, `href="${baseUrl}/$1"`);

                        content = `
                            <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                                <p style="margin: 0; font-size: 0.9em;">
                                    <strong>📡 Content fetched from original source</strong><br>
                                    This article content was retrieved in real-time from <a href="${url}" target="_blank" style="color: #1976d2;">${this.getDomain(url)}</a>
                                </p>
                            </div>
                            ${content}
                        `;

                        return content;
                    }

                    throw new Error('Could not extract readable content from page');

                } catch (error) {
                    console.error('Content extraction error:', error);
                    throw error;
                }
            }

            getArticleContent(article) {
                console.log('📖 Checking for saved content...');

                const contentFields = ['content', 'html', 'fullContent', 'textContent', 'body', 'readableContent', 'articleContent', 'savedContent'];

                for (const field of contentFields) {
                    if (article[field] && article[field].trim()) {
                        console.log(`✅ Found content in ${field} (${article[field].length} chars)`);
                        return article[field];
                    }
                }

                for (const [key, value] of Object.entries(article)) {
                    if (typeof value === 'string' && value.length > 200 && key !== 'excerpt' && key !== 'url') {
                        console.log(`✅ Found substantial content in ${key} (${value.length} chars)`);
                        return value;
                    }
                }

                console.log('❌ No saved content found');
                return null;
            }

            getFallbackContent(article, errorMessage) {
                return `
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h3>📄 Content Not Available</h3>
                        <p>We couldn't load the full article content. This can happen because:</p>
                        <ul style="margin: 15px 0;">
                            <li>The website blocks automated content fetching</li>
                            <li>CORS (Cross-Origin) restrictions prevent access</li>
                            <li>The article content wasn't saved by the browser extension</li>
                            <li>Network connectivity issues</li>
                        </ul>
                        
                        <p><strong>What you can do:</strong></p>
                        <ol style="margin: 15px 0;">
                            <li><strong>Visit the original article</strong> using the button below</li>
                            <li><strong>Re-save the article</strong> with your browser extension</li>
                            <li><strong>Check extension settings</strong> for content extraction options</li>
                        </ol>
                        
                        <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <p><strong>Available excerpt:</strong></p>
                            <p style="font-style: italic;">${article.excerpt || 'No excerpt available'}</p>
                        </div>
                        
                        <div style="text-align: center; margin: 20px 0;">
                            <a href="${article.url}" target="_blank" style="display: inline-block; background: #ee5a24; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                                🔗 Read Full Article
                            </a>
                        </div>
                        
                        <details style="margin-top: 20px;">
                            <summary style="cursor: pointer; color: #666;">Technical Details</summary>
                            <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
                                Error: ${errorMessage}
                            </p>
                        </details>
                    </div>
                `;
            }

            closeReader() {
                const overlay = document.getElementById('readerOverlay');
                overlay.classList.remove('active');
                document.body.style.overflow = 'auto';
            }

            openOriginal() {
                if (this.currentArticle) {
                    window.open(this.currentArticle.url, '_blank');
                }
            }

            exportArticleByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                try {
                    const html = this.createArticleHTML(article);
                    const filename = `${this.sanitizeFilename(article.title)}.html`;
                    this.downloadFile(html, filename, 'text/html');
                    this.updateStatus(`📤 Article "${article.title}" exported successfully!`, 'success');
                } catch (error) {
                    ErrorHandler.handleError(error, 'Export Article');
                    this.updateStatus(`❌ Failed to export article: ${error.message}`, 'error');
                }
            }

            async deleteArticleByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                if (confirm(`Delete "${article.title}"?\n\nThis will permanently remove the article from your enhanced storage and OneDrive backup.`)) {
                    try {
                        const originalIndex = this.articles.findIndex(a =>
                            a.url === article.url && a.title === article.title
                        );

                        if (originalIndex === -1) {
                            throw new Error('Could not find article in main collection');
                        }

                        const cacheKey = this.getCacheKey(article);
                        this.imageCache.delete(cacheKey);

                        const articleId = this.storageManager.generateArticleId(article);
                        this.manuallyEditedArticles.delete(articleId);

                        const category = article.category;
                        if (category) {
                            const count = this.categories.get(category) || 1;
                            if (count <= 1) {
                                this.categories.delete(category);
                            } else {
                                this.categories.set(category, count - 1);
                            }
                        }

                        this.articles.splice(originalIndex, 1);
                        this.currentDisplayedArticles.splice(displayIndex, 1);

                        await this.saveLocalCache();

                        this.updateStatus(`✅ Article deleted and saved to enhanced storage. ${this.articles.length} articles remaining.`, 'success');

                        this.displayArticles(this.currentDisplayedArticles);
                        this.updateArticleCounts();

                    } catch (error) {
                        ErrorHandler.handleError(error, 'Delete Article');
                        this.updateStatus(`❌ Failed to delete article: ${error.message}`, 'error');
                    }
                }
            }

            createArticleHTML(article) {
                const articleId = this.storageManager.generateArticleId(article);
                const isManuallyEdited = this.manuallyEditedArticles.has(articleId);

                const categoryInfo = article.category ? `
                    <div style="margin-bottom: 16px;">
                        <span style="background: ${isManuallyEdited ? '#198754' : '#ee5a24'}; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.9em;">
                            ${this.categoryKeywords[article.category]?.icon || '📄'} ${article.category}
                            ${isManuallyEdited ? ' ✏️' : (article.aiEnhanced ? ' 🤖' : '')}
                            ${article.categoryScore >= 100 ? ' 🎯' : ''}
                        </span>
                    </div>
                ` : '';

                return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHtml(article.title)}</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 40px 20px; 
            line-height: 1.7; 
            color: #333;
        }
        .header { 
            border-bottom: 3px solid #ee5a24; 
            margin-bottom: 32px; 
            padding-bottom: 24px; 
        }
        .title { 
            font-size: 2.4em; 
            font-weight: bold; 
            margin-bottom: 16px; 
            color: #2c3e50; 
            line-height: 1.2; 
        }
        .meta { 
            color: #7f8c8d; 
            font-size: 0.95em; 
            margin-bottom: 24px; 
        }
        .content { 
            font-size: 1.15em; 
            line-height: 1.8; 
        }
        .content img { 
            max-width: 100%; 
            height: auto; 
            margin: 24px 0; 
            border-radius: 8px; 
        }
        .content p { 
            margin-bottom: 1.4em; 
        }
        .footer { 
            margin-top: 48px; 
            padding-top: 24px; 
            border-top: 2px solid #f0f0f0; 
            color: #666; 
            font-size: 0.9em; 
        }
    </style>
</head>
<body>
    <div class="header">
        ${categoryInfo}
        <h1 class="title">${this.escapeHtml(article.title)}</h1>
        <div class="meta">
            <div style="margin-bottom: 8px;">🌐 From: <a href="${article.url}" style="color: #ee5a24;">${this.getDomain(article.url)}</a></div>
            ${article.author ? `<div style="margin-bottom: 8px;">✍️ By: ${this.escapeHtml(article.author)}</div>` : ''}
            <div style="margin-bottom: 8px;">📅 Saved: ${this.formatDate(article.dateAdded)}</div>
            <div>⏱️ Reading time: ${article.readTime || 1} minutes</div>
            ${article.categoryScore ? `<div>🧠 AI Category Score: ${article.categoryScore} ${article.categoryScore >= 100 ? '🎯' : ''}</div>` : ''}
            ${isManuallyEdited ? `<div>✏️ Manually Edited Category</div>` : ''}
        </div>
    </div>
    <div class="content">
        ${article.content || article.excerpt || 'Content not available'}
    </div>
    <div class="footer">
        <p><strong>💾 Exported from MyPocket AI-Enhanced Reader v8.0 (Improved & Secure)</strong></p>
        <p>Original URL: <a href="${article.url}" style="color: #ee5a24;">${article.url}</a></p>
        <p>Export Date: ${new Date().toLocaleDateString()}</p>
        ${article.category ? `<p>Category: ${article.category} ${isManuallyEdited ? '(Manually Edited)' : (article.aiEnhanced ? '(AI-Enhanced)' : '')} ${article.categoryScore >= 100 ? '(High-Confidence)' : ''}</p>` : ''}
    </div>
</body>
</html>`;
            }

            async updateOneDriveBackup() {
                if (!this.accessToken) {
                    throw new Error('Not connected to OneDrive');
                }

                const articlesWithImages = this.articles.filter(a => a.cachedImage);
                const totalImageSizeKB = articlesWithImages.reduce((total, article) => {
                    return total + (article.cachedImage ? article.cachedImage.size || 0 : 0);
                }, 0);

                const aiEnhancedCount = this.articles.filter(a => a.aiEnhanced).length;
                const highConfidenceCount = this.articles.filter(a => a.categoryScore >= 100).length;
                const manuallyEditedCount = this.manuallyEditedArticles.size;

                console.log(`📦 Creating enhanced backup with ${articlesWithImages.length} stored images (${Math.round(totalImageSizeKB)}KB), ${aiEnhancedCount} AI-enhanced articles, ${highConfidenceCount} high-confidence categorizations, and ${manuallyEditedCount} manually edited articles`);

                const backup = {
                    articles: this.articles,
                    settings: {
                        storeImagesInBackup: this.storeImagesInBackup,
                        maxImageSizeKB: this.maxImageSizeKB,
                        aiCategoriesEnabled: this.aiCategoriesEnabled,
                        autoSaveEnabled: this.autoSaveEnabled
                    },
                    aiAnalytics: Object.fromEntries(this.categoryAnalytics),
                    manuallyEditedArticles: Array.from(this.manuallyEditedArticles),
                    exportDate: new Date().toISOString(),
                    version: "8.0-improved",
                    deviceInfo: {
                        browser: "AI-Enhanced Web Reader v8.0 - Improved & Secure with IndexedDB + Memory Management + PKCE + Enhanced AI",
                        platform: navigator.platform,
                        timestamp: Date.now(),
                        articleCount: this.articles.length,
                        storedImages: articlesWithImages.length,
                        totalImageSizeKB: Math.round(totalImageSizeKB),
                        aiEnhancedArticles: aiEnhancedCount,
                        highConfidenceArticles: highConfidenceCount,
                        manuallyEditedArticles: manuallyEditedCount,
                        categoriesFound: this.categories.size,
                        authMethod: "Authorization Code + PKCE",
                        storageSystem: "IndexedDB + Memory Management",
                        aiFeatures: "Enhanced context-aware categorization with 16 categories, negative filtering, confidence scoring, manual overrides, manual category editing with IndexedDB storage, advanced pattern recognition, and memory management"
                    }
                };

                const fileName = `mypocket-backup-${new Date().toISOString().split('T')[0]}.json`;
                const fileContent = JSON.stringify(backup, null, 2);

                const backupSizeMB = fileContent.length / (1024 * 1024);
                if (backupSizeMB > 10) {
                    console.warn(`⚠️ Large backup detected: ${backupSizeMB.toFixed(1)}MB`);
                }

                const uploadUrl = `https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket/${fileName}:/content`;

                const uploadResponse = await fetch(uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${this.accessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: fileContent
                });

                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    throw new Error(`Failed to update OneDrive backup: ${uploadResponse.status} - ${errorText}`);
                }

                console.log(`✅ Enhanced backup saved with ${articlesWithImages.length} images (${Math.round(totalImageSizeKB)}KB), ${aiEnhancedCount} AI-categorized articles, ${highConfidenceCount} high-confidence categorizations, and ${manuallyEditedCount} manually edited articles`);
                return await uploadResponse.json();
            }

            sanitizeFilename(filename) {
                return filename.replace(/[^a-z0-9\s-]/gi, '').replace(/\s+/g, '-').toLowerCase();
            }

            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        // Initialize the enhanced web reader when page loads
        let webReader;

        // Debug function available immediately
        window.debugMyPocket = function () {
            console.log('🔧 DEBUG: Checking all elements...');
            const elements = {
                'sidebar': document.getElementById('sidebar'),
                'connectBtnSidebar': document.getElementById('connectBtnSidebar'),
                'connectionStatusSidebar': document.getElementById('connectionStatusSidebar'),
                'connectionIcon': document.getElementById('connectionIcon'),
                'connectionText': document.getElementById('connectionText'),
                'refreshNavBtn': document.getElementById('refreshNavBtn'),
                'syncNavBtn': document.getElementById('syncNavBtn'),
                'retryNavBtn': document.getElementById('retryNavBtn'),
                'allArticlesNav': document.getElementById('allArticlesNav'),
                'searchNavBtn': document.getElementById('searchNavBtn'),
                'categoriesNavBtn': document.getElementById('categoriesNavBtn'),
                'recategorizeBtn': document.getElementById('recategorizeBtn'),
                'status': document.getElementById('status'),
                'mainContent': document.getElementById('mainContent')
            };

            console.log('🔍 Element check results:');
            for (const [name, element] of Object.entries(elements)) {
                if (element) {
                    console.log(`✅ ${name}: Found`);
                } else {
                    console.log(`❌ ${name}: NOT FOUND`);
                }
            }

            if (window.webReader) {
                console.log('✅ webReader: Initialized');
                console.log('📊 webReader properties:', {
                    accessToken: !!window.webReader.accessToken,
                    articles: window.webReader.articles ? window.webReader.articles.length : 0,
                    redirectUri: window.webReader.redirectUri,
                    aiCategoriesEnabled: window.webReader.aiCategoriesEnabled,
                    isRecategorizing: window.webReader.isRecategorizing,
                    storageManager: !!window.webReader.storageManager,
                    memoryManager: !!window.webReader.memoryManager
                });
            } else {
                console.log('❌ webReader: NOT INITIALIZED');
            }

            return elements;
        };

        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeWebReader);
        } else {
            initializeWebReader();
        }

        function initializeWebReader() {
            console.log('🚀 Initializing MyPocket Enhanced & Secure Web Reader...');

            try {
                webReader = new MyPocketWebReader();
                console.log('✅ MyPocket Enhanced & Secure Web Reader initialized successfully!');

                // Make it globally available for debugging
                window.webReader = webReader;

                // Add global keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'i') {
                        e.preventDefault();
                        webReader.showDebugInfo();
                    }
                });

            } catch (error) {
                ErrorHandler.handleError(error, 'Initialization');

                const status = document.getElementById('status');
                if (status) {
                    status.textContent = `❌ Initialization failed: ${error.message}`;
                    status.className = 'status error';
                }
            }
        }

        // Global error handler for better debugging
        window.addEventListener('error', (event) => {
            ErrorHandler.handleError(event.error, 'Global Error');
        });

        // Handle unhandled promise rejections
        window.addEventListener('unhandledrejection', (event) => {
            ErrorHandler.handleError(event.reason, 'Unhandled Promise Rejection');
        });

        console.log('🎯 MyPocket AI-Enhanced Web Reader (Improved & Secure) script loaded - v8.0 with IndexedDB + Memory Management + PKCE Security + Enhanced AI');
    </script>
</body>

</html>
