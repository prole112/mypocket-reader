<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyPocket - AI Web Reader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #ee5a24;
            --secondary-color: #667eea;
            --background: #f8f9fa;
            --surface: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --border: #e9ecef;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.15);
            --sidebar-width: 280px;
        }

        /* Enhanced Dark mode with better contrast */
        [data-theme="dark"] {
            --primary-color: #ff6b35;
            --secondary-color: #7b88f7;
            --background: #0d1117;
            --surface: #161b22;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --border: #30363d;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.6);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.8);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--background);
            margin: 0;
            display: flex;
            min-height: 100vh;
        }

        /* FIXED: Proper Vertical Sidebar Navigation */
        .sidebar {
            width: var(--sidebar-width);
            background: var(--surface);
            border-right: 1px solid var(--border);
            box-shadow: var(--shadow);
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            color: white;
            flex-shrink: 0;
        }

        .sidebar-logo {
            font-size: 1.4em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .connection-status {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
        }

        .sidebar-nav {
            padding: 20px 0;
            flex: 1;
            overflow-y: auto;
        }

        .nav-section {
            margin-bottom: 30px;
        }

        .nav-section-title {
            font-size: 0.75em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin: 0 20px 12px;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            color: var(--text-primary);
            text-decoration: none;
            transition: all 0.2s ease;
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 14px;
            border-left: 3px solid transparent;
        }

        .nav-item:hover {
            background: var(--background);
            border-left-color: var(--primary-color);
        }

        .nav-item.active {
            background: var(--background);
            border-left-color: var(--primary-color);
            color: var(--primary-color);
            font-weight: 500;
        }

        .nav-item .icon {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }

        .nav-item .label {
            flex: 1;
        }

        .nav-item .badge {
            background: var(--primary-color);
            color: white;
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 8px;
            min-width: 16px;
            text-align: center;
        }

        /* FIXED: Main Content Area with proper margin */
        .main-content {
            flex: 1;
            margin-left: var(--sidebar-width);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            width: 100%;
        }

        /* Header */
        .header {
            background: var(--surface);
            color: var(--text-primary);
            padding: 20px 0;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 90;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-title {
            font-size: 1.5em;
            font-weight: 600;
            color: var(--text-primary);
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .mobile-menu-btn {
            display: none;
            background: none;
            border: none;
            font-size: 18px;
            color: var(--text-primary);
            cursor: pointer;
            padding: 8px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
            transform: translateY(-1px);
        }

        /* Search Toggle Animation */
        .search-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 90;
            padding: 30px 0;
        }

        .search-container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .search-container.hidden {
            opacity: 0;
            transform: translateY(-10px);
        }

        /* Category Filter Styles */
        .category-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 89;
            padding: 20px 0;
        }

        .category-container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .category-container.hidden {
            opacity: 0;
            transform: translateY(-10px);
        }

        .category-filter {
            max-width: 800px;
            margin: 0 auto;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .category-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.2em;
        }

        .category-close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .category-close-btn:hover {
            background: var(--border);
            color: var(--text-primary);
            transform: scale(1.1);
        }

        .category-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .category-chip {
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
        }

        .category-chip:hover {
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: white;
            transform: translateY(-2px);
        }

        .category-chip.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        .category-chip.show-all {
            background: var(--secondary-color);
            border-color: var(--secondary-color);
            color: white;
            font-weight: 600;
        }

        .category-chip.show-all:hover {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .category-count {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .category-chip:not(.active) .category-count {
            background: var(--border);
            color: var(--text-secondary);
        }

        .search-box {
            position: relative;
            max-width: 600px;
            margin: 0 auto;
        }

        .search-input {
            width: 100%;
            padding: 15px 50px 15px 20px;
            border: 2px solid var(--border);
            border-radius: 25px;
            font-size: 16px;
            background: var(--background);
            transition: border-color 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .search-close-btn {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .search-close-btn:hover {
            background: var(--border);
            color: var(--text-primary);
            transform: translateY(-50%) scale(1.1);
        }

        /* Status */
        .status {
            padding: 20px 0;
            text-align: center;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .status.loading {
            color: var(--secondary-color);
        }

        .status.error {
            color: #e74c3c;
        }

        .status.success {
            color: #27ae60;
        }

        /* Articles Grid - SMALLER TILES */
        .articles-section {
            padding: 40px 0;
            min-height: 60vh;
            flex: 1;
        }

        .articles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 18px;
            margin-top: 20px;
        }

        /* ORGANIC SHAPED TILES - SMALLER VERSION */
        .article-card {
            background: var(--surface);
            border-radius: 32px 24px 32px 24px;
            overflow: visible;
            box-shadow: var(--shadow);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border: 1px solid var(--border);
            position: relative;
            display: flex;
            flex-direction: column;
            transform-origin: center center;
        }

        /* Varying organic shapes for visual interest */
        .article-card:nth-child(3n+1) {
            border-radius: 28px 36px 28px 36px;
        }

        .article-card:nth-child(3n+2) {
            border-radius: 35px 25px 35px 25px;
        }

        .article-card:nth-child(3n+3) {
            border-radius: 30px 30px 40px 20px;
        }

        .article-card:nth-child(4n+1) {
            border-radius: 40px 20px 30px 30px;
        }

        .article-card:nth-child(5n+1) {
            border-radius: 25px 35px 25px 35px;
        }

        .article-card:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-8px) scale(1.02) rotate(1deg);
            border-color: var(--primary-color);
        }

        .article-card:nth-child(even):hover {
            transform: translateY(-8px) scale(1.02) rotate(-1deg);
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
        }

        /* Organic shaped image area */
        .article-image {
            width: 100%;
            height: 100px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: white;
            position: relative;
            overflow: hidden;
            border-radius: inherit;
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 16px;
        }

        .article-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.4s ease, opacity 0.3s ease;
        }

        .article-image:hover img {
            transform: scale(1.08);
        }

        /* Compact content area with organic feel */
        .article-content {
            padding: 15px;
            flex: 1;
            cursor: pointer;
            border-radius: 0 0 inherit inherit;
        }

        .article-title {
            font-size: 1em;
            font-weight: 600;
            margin-bottom: 6px;
            line-height: 1.3;
            color: var(--text-primary);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-excerpt {
            color: var(--text-secondary);
            font-size: 0.8em;
            line-height: 1.4;
            margin-bottom: 10px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
            color: var(--text-secondary);
            font-size: 0.75em;
            margin-bottom: 6px;
        }

        .article-domain {
            font-weight: 500;
        }

        .article-date {
            opacity: 0.8;
        }

        .article-stats {
            display: flex;
            gap: 10px;
            font-size: 0.7em;
            color: var(--text-secondary);
        }

        /* Floating organic action buttons */
        .article-actions {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 6px;
            opacity: 0 !important;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid var(--border);
            border-radius: 50%;
            padding: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            min-width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn:hover {
            transform: translateY(-4px) scale(1.15);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
            border-radius: 40% 60% 70% 30%;
        }

        .read-btn:hover {
            background: #e3f2fd;
            border-color: #2196f3;
            border-radius: 60% 40% 30% 70%;
        }

        .export-btn:hover {
            background: #e8f5e8;
            border-color: #4caf50;
            border-radius: 30% 70% 60% 40%;
        }

        .refresh-image-btn:hover {
            background: #fff3e0;
            border-color: #ff9800;
            border-radius: 40% 60% 40% 60%;
        }

        .delete-btn {
            color: #f44336;
        }

        .delete-btn:hover {
            background: #ffebee;
            border-color: #f44336;
            color: #d32f2f;
            border-radius: 70% 30% 40% 60%;
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
        }

        body.test-mode .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
            background: rgba(255, 255, 0, 0.1);
            border: 2px dashed #ff9800;
            border-radius: 20px;
            padding: 5px;
        }

        .article-actions:hover {
            opacity: 1 !important;
            visibility: visible !important;
        }

        /* Reader View */
        .reader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            overflow-y: auto;
        }

        .reader-overlay.active {
            display: block;
        }

        .reader-container {
            max-width: 800px;
            margin: 40px auto;
            background: var(--surface);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.3);
        }

        .reader-header {
            padding: 30px;
            border-bottom: 1px solid var(--border);
            background: var(--background);
        }

        .reader-title {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 15px;
            line-height: 1.3;
        }

        .reader-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .reader-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .reader-content {
            padding: 40px;
            font-size: 1.1em;
            line-height: 1.8;
            max-width: none;
        }

        .reader-content h1,
        .reader-content h2,
        .reader-content h3 {
            margin: 30px 0 15px;
            color: var(--text-primary);
        }

        .reader-content p {
            margin-bottom: 20px;
        }

        .reader-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
        }

        .reader-content blockquote {
            border-left: 4px solid var(--primary-color);
            margin: 20px 0;
            padding: 15px 20px;
            background: var(--background);
            font-style: italic;
        }

        .close-reader {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-reader:hover {
            border-radius: 30% 70% 70% 30%;
            transform: scale(1.1);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Cache indicator */
        .cache-indicator {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            z-index: 5;
        }

        .cache-indicator.cached {
            background: rgba(39, 174, 96, 0.8);
        }

        .cache-indicator.fresh {
            background: rgba(52, 152, 219, 0.8);
        }

        .cache-indicator.synced {
            background: rgba(76, 175, 80, 0.8);
            color: white;
        }

        .cache-indicator.fallback {
            background: rgba(255, 152, 0, 0.8);
            color: white;
        }

        .cache-indicator.metadata {
            background: rgba(103, 58, 183, 0.8);
            color: white;
        }

        .cache-indicator.error {
            background: rgba(244, 67, 54, 0.8);
            color: white;
        }

        /* Enhanced Mobile Responsive Design */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                z-index: 200;
            }

            .sidebar.mobile-open {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
            }

            .mobile-menu-btn {
                display: block !important;
            }

            .container {
                padding: 0 12px;
            }

            .header {
                padding: 15px 0;
            }

            .header-title {
                font-size: 1.3em;
            }

            .btn {
                padding: 8px 16px;
                font-size: 13px;
                border-radius: 20px;
            }

            .search-container {
                padding: 20px 0;
            }

            .search-input {
                font-size: 16px !important;
                padding: 12px 45px 12px 16px;
                border-radius: 20px;
            }

            .search-close-btn {
                right: 12px;
                width: 28px;
                height: 28px;
                font-size: 16px;
            }

            .category-container {
                padding: 15px 0;
            }

            .category-header h3 {
                font-size: 1.1em;
            }

            .category-chips {
                gap: 8px;
            }

            .category-chip {
                padding: 6px 12px;
                font-size: 0.8em;
                border-radius: 16px;
            }

            .category-count {
                font-size: 0.7em;
                padding: 1px 4px;
            }

            .status {
                padding: 15px 0;
                font-size: 14px;
                line-height: 1.4;
            }

            .articles-section {
                padding: 20px 0;
            }

            .articles-grid {
                display: block;
                margin-top: 15px;
            }

            .article-card {
                display: block !important;
                width: 100% !important;
                margin-bottom: 20px !important;
                border-radius: 20px !important;
                overflow: hidden;
                background: var(--surface);
                border: 1px solid var(--border);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                transform: none !important;
                animation: none !important;
            }

            .article-card:hover {
                transform: none !important;
                box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
            }

            .article-image {
                width: 100% !important;
                height: 140px !important;
                border-radius: 20px 20px 0 0 !important;
                position: relative;
            }

            .article-content {
                padding: 20px !important;
                cursor: pointer;
            }

            .article-title {
                font-size: 1.25em !important;
                font-weight: 600;
                margin-bottom: 10px !important;
                line-height: 1.4 !important;
                color: var(--text-primary);
                display: block !important;
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-excerpt {
                font-size: 1em !important;
                line-height: 1.5 !important;
                margin-bottom: 15px !important;
                color: var(--text-secondary);
                display: block !important;
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-meta {
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-wrap: wrap;
                gap: 8px;
                color: var(--text-secondary);
                font-size: 0.9em !important;
                margin-bottom: 10px;
            }

            .article-stats {
                display: flex;
                gap: 15px;
                font-size: 0.85em !important;
                color: var(--text-secondary);
                margin-bottom: 10px;
            }

            .article-actions {
                position: static !important;
                opacity: 1 !important;
                visibility: visible !important;
                display: flex !important;
                justify-content: center;
                gap: 12px;
                padding: 15px 20px;
                background: var(--background);
                border-radius: 0;
                margin: 0;
                border-top: 1px solid var(--border);
            }

            .action-btn {
                min-width: 45px !important;
                height: 45px !important;
                font-size: 18px !important;
                border-radius: 50% !important;
                padding: 0;
                background: var(--surface);
                border: 2px solid var(--border);
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .action-btn:hover,
            .action-btn:active {
                border-radius: 50% !important;
                transform: scale(1.05);
                background: var(--primary-color);
                color: white;
                border-color: var(--primary-color);
            }

            .reader-overlay {
                padding: 0;
            }

            .reader-container {
                margin: 0 !important;
                border-radius: 0 !important;
                height: 100vh;
                max-width: none;
                display: flex;
                flex-direction: column;
            }

            .reader-header {
                padding: 20px;
                border-radius: 0;
                flex-shrink: 0;
            }

            .reader-title {
                font-size: 1.4em !important;
                line-height: 1.3;
                margin-bottom: 15px;
            }

            .reader-meta {
                font-size: 0.9em;
                gap: 15px;
            }

            .reader-content {
                padding: 20px;
                font-size: 1.1em !important;
                line-height: 1.7 !important;
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            .close-reader {
                top: 15px;
                right: 15px;
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .search-input {
                font-size: 16px !important;
                padding: 14px 50px 14px 18px;
            }

            .empty-state {
                padding: 40px 20px;
            }

            .empty-state-icon {
                font-size: 3em;
                margin-bottom: 15px;
            }

            .empty-state h3 {
                font-size: 1.3em;
                margin-bottom: 8px;
            }

            .empty-state p {
                font-size: 1em;
                line-height: 1.5;
            }
        }

        @media (max-width: 480px) {
            .article-title {
                font-size: 1.15em !important;
            }

            .article-excerpt {
                font-size: 0.95em !important;
            }

            .article-content {
                padding: 16px !important;
            }

            .header-actions {
                gap: 6px;
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        /* Dark mode styles */
        [data-theme="dark"] .sidebar {
            background: var(--surface);
            border-right-color: var(--border);
        }

        [data-theme="dark"] .sidebar-header {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
        }

        [data-theme="dark"] .nav-item {
            color: var(--text-primary);
        }

        [data-theme="dark"] .nav-item:hover {
            background: var(--background);
        }

        [data-theme="dark"] .nav-item.active {
            background: var(--background);
            color: var(--primary-color);
        }

        [data-theme="dark"] .article-card {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .article-card:hover {
            border-color: #484f58;
            transform: translateY(-2px) scale(1.02);
        }

        [data-theme="dark"] .search-input {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .search-input:focus {
            border-color: var(--primary-color);
            background: var(--surface);
        }

        [data-theme="dark"] .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.8;
        }

        [data-theme="dark"] .search-close-btn:hover {
            background: #21262d;
            color: var(--text-primary);
        }

        [data-theme="dark"] .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border-color: var(--border);
        }

        [data-theme="dark"] .btn-secondary:hover {
            background: #21262d;
            border-color: #484f58;
            color: var(--text-primary);
        }

        [data-theme="dark"] .action-btn {
            background: rgba(22, 27, 34, 0.95);
            border-color: var(--border);
            color: var(--text-primary);
            backdrop-filter: blur(10px);
        }

        [data-theme="dark"] .action-btn:hover {
            background: rgba(33, 38, 45, 0.95);
            border-color: #484f58;
        }

        [data-theme="dark"] .read-btn:hover {
            background: rgba(13, 110, 253, 0.2);
            border-color: #0d6efd;
            color: #58a6ff;
        }

        [data-theme="dark"] .export-btn:hover {
            background: rgba(25, 135, 84, 0.2);
            border-color: #198754;
            color: #3fb950;
        }

        [data-theme="dark"] .refresh-image-btn:hover {
            background: rgba(255, 152, 0, 0.2);
            border-color: #ff9800;
            color: #ffb74d;
        }

        [data-theme="dark"] .delete-btn:hover {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #f85149;
        }

        [data-theme="dark"] .reader-container {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .reader-header {
            background: var(--background);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .reader-content {
            color: var(--text-primary);
        }

        [data-theme="dark"] .reader-content h1,
        [data-theme="dark"] .reader-content h2,
        [data-theme="dark"] .reader-content h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .reader-content blockquote {
            background: var(--background);
            border-left-color: var(--primary-color);
        }

        [data-theme="dark"] .close-reader {
            background: var(--primary-color);
        }

        [data-theme="dark"] .empty-state {
            color: var(--text-secondary);
        }

        [data-theme="dark"] .empty-state h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .connection-status.connected {
            background: rgba(25, 135, 84, 0.2);
            border-color: #198754;
            color: #3fb950;
        }

        [data-theme="dark"] .connection-status.disconnected {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #f85149;
        }

        [data-theme="dark"] .cache-indicator.synced {
            background: rgba(76, 175, 80, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.fallback {
            background: rgba(255, 152, 0, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.metadata {
            background: rgba(103, 58, 183, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.error {
            background: rgba(244, 67, 54, 0.9);
            color: white;
        }

        [data-theme="dark"] .category-container {
            background: var(--surface);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .category-header h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .category-close-btn:hover {
            background: #21262d;
            color: var(--text-primary);
        }

        [data-theme="dark"] .category-chip {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .category-chip:hover {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        [data-theme="dark"] .category-chip.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        [data-theme="dark"] .category-chip:not(.active) .category-count {
            background: var(--border);
            color: var(--text-secondary);
        }

        /* Firefox Mobile Specific Fixes */
        @-moz-document url-prefix() {
            @media (max-width: 768px) {
                .article-card {
                    will-change: auto;
                }

                .articles-grid {
                    transform: translateZ(0);
                }

                .search-input {
                    -moz-appearance: none;
                }

                .btn {
                    -moz-appearance: none;
                }
            }
        }

        /* Background pattern animation for generated placeholders */
        @keyframes floatPattern {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        /* Shimmer animation for loading placeholders */
        @keyframes shimmer {
            0% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.6;
            }
        }

        .article-card:nth-child(7n+1) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 0s;
        }

        .article-card:nth-child(7n+2) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 0.5s;
        }

        .article-card:nth-child(7n+3) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 1s;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-6px);
            }
        }

        /* Organic gradient backgrounds for images */
        .article-image:nth-child(odd) {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .article-image:nth-child(3n+1) {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .article-image:nth-child(3n+2) {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .article-image:nth-child(3n+3) {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }

        .article-image:nth-child(5n+1) {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        /* Hidden by default */
        .hidden {
            display: none !important;
        }

        /* Mobile overlay backdrop */
        .mobile-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 150;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .mobile-overlay.active {
            opacity: 1;
            visibility: visible;
        }
    </style>
</head>

<body>
    <!-- FIXED: Proper Vertical Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-logo">
                üìö MyPocket AI Reader
            </div>
            <div class="connection-status" id="connectionStatus">
                <span>üîê</span>
                <span>Secure Connect Required</span>
            </div>
        </div>
        
        <nav class="sidebar-nav">
            <div class="nav-section">
                <div class="nav-section-title">Library</div>
                <button class="nav-item active" id="allArticlesBtn" onclick="webReader.showAllArticles()">
                    <span class="icon">üìö</span>
                    <span class="label">All Articles</span>
                    <span class="badge" id="allArticleCount">0</span>
                </button>
                <button class="nav-item" id="unreadBtn" onclick="webReader.showUnread()">
                    <span class="icon">üìñ</span>
                    <span class="label">Unread</span>
                    <span class="badge" id="unreadCount">0</span>
                </button>
                <button class="nav-item" id="favoritesBtn" onclick="webReader.showFavorites()">
                    <span class="icon">‚≠ê</span>
                    <span class="label">Favorites</span>
                    <span class="badge" id="favoritesCount">0</span>
                </button>
                <button class="nav-item" id="archiveBtn" onclick="webReader.showArchive()">
                    <span class="icon">üì¶</span>
                    <span class="label">Archive</span>
                    <span class="badge" id="archiveCount">0</span>
                </button>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Smart Categories</div>
                <button class="nav-item" id="categoriesBtn" onclick="webReader.toggleCategoryFilter()">
                    <span class="icon">üè∑Ô∏è</span>
                    <span class="label">All Categories</span>
                    <span class="badge" id="categoryCount">0</span>
                </button>
                <div id="dynamicCategoryNav"></div>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Actions</div>
                <button class="nav-item" id="connectBtn" onclick="webReader.authenticate()">
                    <span class="icon">‚òÅÔ∏è</span>
                    <span class="label">Connect to OneDrive</span>
                </button>
                <button class="nav-item" id="refreshBtn" onclick="webReader.loadArticles()" style="display: none;">
                    <span class="icon">üîÑ</span>
                    <span class="label">Refresh Articles</span>
                </button>
                <button class="nav-item" id="syncBtn" onclick="webReader.forceSyncImages()" style="display: none;">
                    <span class="icon">üîÑ</span>
                    <span class="label">Sync Images</span>
                </button>
                <button class="nav-item" id="retryFailedBtn" onclick="webReader.retryFailedImages()" style="display: none;">
                    <span class="icon">üîÑ</span>
                    <span class="label">Retry Failed</span>
                </button>
                <button class="nav-item" onclick="webReader.clearImageCache()">
                    <span class="icon">üóëÔ∏è</span>
                    <span class="label">Clear Cache</span>
                </button>
                <button class="nav-item" onclick="webReader.showImageHelp()">
                    <span class="icon">‚ùì</span>
                    <span class="label">Image Help</span>
                </button>
                <button class="nav-item" onclick="webReader.showDebugInfo()">
                    <span class="icon">üîß</span>
                    <span class="label">Debug Info</span>
                </button>
                <button class="nav-item" onclick="webReader.toggleTestMode()">
                    <span class="icon">üëÅÔ∏è</span>
                    <span class="label">Show Buttons</span>
                </button>
                <button class="nav-item" onclick="webReader.toggleDarkMode()">
                    <span class="icon">üåô</span>
                    <span class="label">Dark Mode</span>
                </button>
            </div>
        </nav>
    </div>

    <!-- Mobile overlay backdrop -->
    <div class="mobile-overlay" id="mobileOverlay" onclick="webReader.toggleMobileMenu()"></div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Header -->
        <header class="header">
            <div class="container">
                <div class="header-content">
                    <div>
                        <button class="mobile-menu-btn" onclick="webReader.toggleMobileMenu()">‚ò∞</button>
                        <span class="header-title" id="pageTitle">All Articles</span>
                    </div>
                    <div class="header-actions">
                        <button id="searchToggleBtn" class="btn btn-secondary" onclick="webReader.toggleSearch()">
                            <span>üîç</span> Search
                        </button>
                        <button id="categoriesHeaderBtn" class="btn btn-secondary" onclick="webReader.toggleCategoryFilter()">
                            <span>üè∑Ô∏è</span> Categories
                        </button>
                        <button id="darkModeBtn" class="btn btn-secondary" onclick="webReader.toggleDarkMode()">
                            <span>üåô</span> Dark Mode
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Search (Initially Hidden) -->
        <section class="search-container" id="searchContainer" style="display: none;">
            <div class="container">
                <div class="search-box">
                    <input type="text" id="searchInput" class="search-input" placeholder="Search your saved articles..."
                        autocomplete="off">
                    <button class="search-close-btn" onclick="webReader.toggleSearch()" title="Close search">‚úï</button>
                </div>
            </div>
        </section>

        <!-- Enhanced AI Category Filter (Initially Hidden) -->
        <section class="category-container" id="categoryContainer" style="display: none;">
            <div class="container">
                <div class="category-filter">
                    <div class="category-header">
                        <h3>üìÇ AI-Powered Category Filter</h3>
                        <button class="category-close-btn" onclick="webReader.toggleCategoryFilter()"
                            title="Close categories">‚úï</button>
                    </div>
                    <div class="category-chips" id="categoryChips">
                        <!-- AI-generated categories will be populated here -->
                    </div>
                </div>
            </div>
        </section>

        <!-- Status -->
        <div class="status" id="status">
            Connect to OneDrive to view your saved articles with intelligent AI categorization
        </div>

        <!-- Articles -->
        <section class="articles-section">
            <div class="container">
                <div id="articlesContainer">
                    <div class="empty-state">
                        <div class="empty-state-icon">ü§ñ</div>
                        <h3>Welcome to MyPocket AI Reader</h3>
                        <p>Connect to OneDrive to access your saved articles with intelligent AI categorization and cross-device image sync!</p>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <!-- Reader Overlay -->
    <div class="reader-overlay" id="readerOverlay">
        <div class="reader-container">
            <button class="close-reader" id="closeReader">‚úï</button>
            <div class="reader-header">
                <h1 class="reader-title" id="readerTitle">Article Title</h1>
                <div class="reader-meta" id="readerMeta">
                    <span>üìÖ <span id="readerDate">Date</span></span>
                    <span>üåê <span id="readerDomain">Domain</span></span>
                    <span>‚è±Ô∏è <span id="readerTime">5 min read</span></span>
                </div>
                <div class="reader-actions">
                    <button class="btn btn-secondary" id="openOriginal">
                        üîó Open Original
                    </button>
                </div>
            </div>
            <div class="reader-content" id="readerContent">
                Article content will appear here...
            </div>
        </div>
    </div>

    <script>
        class MyPocketWebReader {
            constructor() {
                // FIXED: Use your actual Azure AD client ID
                this.clientId = '436e8796-8c40-47c3-9ad5-b8882f3ef7f7';
                this.redirectUri = this.getRedirectUri();
                console.log('üîµ Redirect URI:', this.redirectUri);

                this.accessToken = null;
                this.articles = [];
                this.currentArticle = null;
                this.currentDisplayedArticles = [];
                this.failedImages = new Set();

                // Enhanced AI-powered categorization system
                this.categories = new Map();
                this.activeCategory = null;
                this.dynamicCategories = new Map();
                this.categoryKeywords = this.initializeCategoryKeywords();
                this.stopWords = this.initializeStopWords();
                
                // AI categorization settings - MUCH MORE AGGRESSIVE
                this.enableDynamicCategories = true;
                this.minCategoryConfidence = 15; // MASSIVELY LOWERED for much better matching
                this.maxCategories = 25; // INCREASED to allow more categories

                // Image cache system
                this.imageCache = new Map();
                this.cacheKey = 'mypocket_image_cache';
                this.cacheExpiryDays = 7;

                // Cross-device image storage
                this.storeImagesInBackup = true;
                this.maxImageSizeKB = 500;
                this.cacheSaveTimeout = null;

                // PKCE-specific properties
                this.codeVerifier = null;
                this.codeChallenge = null;
                this.state = null;

                this.init();
            }

            getRedirectUri() {
                const currentUrl = window.location.href;
                const baseUrl = currentUrl.split('#')[0].split('?')[0];

                if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {
                    return baseUrl;
                } else {
                    return window.location.origin + window.location.pathname;
                }
            }

            // ===== ENHANCED AI CATEGORIZATION SYSTEM =====

            initializeStopWords() {
                return new Set([
                    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
                    'how', 'what', 'why', 'when', 'where', 'who', 'which', 'this', 'that', 'these', 'those',
                    'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did',
                    'will', 'would', 'could', 'should', 'may', 'might', 'can', 'must', 'shall', 'here', 'there',
                    'up', 'down', 'out', 'off', 'over', 'under', 'again', 'further', 'then', 'once', 'now',
                    'very', 'too', 'just', 'only', 'own', 'same', 'so', 'than', 'too', 'any', 'some', 'all',
                    'each', 'more', 'most', 'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than',
                    'into', 'from', 'they', 'them', 'their', 'we', 'us', 'our', 'you', 'your', 'he', 'him',
                    'his', 'she', 'her', 'it', 'its', 'me', 'my', 'i', 'get', 'got', 'make', 'made', 'take',
                    'took', 'see', 'saw', 'go', 'went', 'come', 'came', 'know', 'knew', 'think', 'thought',
                    'say', 'said', 'tell', 'told', 'ask', 'asked', 'give', 'gave', 'find', 'found', 'work',
                    'worked', 'call', 'called', 'try', 'tried', 'need', 'needed', 'feel', 'felt', 'become',
                    'became', 'leave', 'left', 'put', 'putting', 'mean', 'meant', 'keep', 'kept', 'let',
                    'begin', 'began', 'seem', 'seemed', 'help', 'helped', 'talk', 'talked', 'turn', 'turned',
                    'start', 'started', 'show', 'showed', 'hear', 'heard', 'play', 'played', 'run', 'ran',
                    'move', 'moved', 'live', 'lived', 'believe', 'believed', 'bring', 'brought', 'happen',
                    'happened', 'write', 'wrote', 'provide', 'provided', 'sit', 'sat', 'stand', 'stood',
                    'lose', 'lost', 'pay', 'paid', 'meet', 'met', 'include', 'included', 'continue', 'continued',
                    'set', 'follow', 'followed', 'around', 'between', 'during', 'before', 'after', 'above',
                    'below', 'against', 'through', 'while', 'without', 'within', 'along', 'among', 'across',
                    'behind', 'beyond', 'since', 'until', 'unless', 'although', 'because', 'however',
                    'therefore', 'moreover', 'furthermore', 'nevertheless', 'meanwhile', 'otherwise',
                    'article', 'articles', 'post', 'posts', 'blog', 'blogs', 'page', 'pages', 'website',
                    'site', 'link', 'links', 'read', 'reading', 'content', 'text', 'information', 'info'
                ]);
            }

            // MASSIVELY EXPANDED: Enhanced category keywords with MUCH better matching + new categories
            initializeCategoryKeywords() {
                return {
                    'Technology': {
                        icon: 'üíª',
                        priority: 'high',
                        keywords: [
                            'programming', 'code', 'coding', 'development', 'developer', 'software', 'algorithm',
                            'javascript', 'python', 'java', 'react', 'nodejs', 'api', 'database', 'sql',
                            'frontend', 'backend', 'fullstack', 'framework', 'library', 'github', 'git',
                            'open source', 'debugging', 'testing', 'deployment', 'devops', 'cloud',
                            'artificial intelligence', 'machine learning', 'ai', 'ml', 'blockchain',
                            'cryptocurrency', 'bitcoin', 'ethereum', 'nft', 'metaverse', 'vr', 'ar',
                            'virtual reality', 'augmented reality', 'iot', 'internet of things',
                            'mobile', 'android', 'ios', 'web development', 'responsive', 'pwa',
                            'app development', 'xamarin', 'flutter', 'react native', 'tech', 'digital',
                            'computer', 'software', 'hardware', 'cybersecurity', 'data', 'analytics',
                            'startup', 'innovation', 'automation', 'robotics', 'saas', 'platform'
                        ],
                        domains: ['github.com', 'stackoverflow.com', 'dev.to', 'techcrunch.com', 'theverge.com', 
                                'arstechnica.com', 'wired.com', 'hacker-news.firebaseio.com', 'news.ycombinator.com',
                                'medium.com/tag/technology', 'freecodecamp.org', 'codepen.io']
                    },
                    'Politics': {
                        icon: 'üèõÔ∏è',
                        priority: 'high',
                        keywords: [
                            'politics', 'political', 'government', 'governance', 'election', 'voting', 'democracy', 
                            'republican', 'democratic', 'congress', 'senate', 'house', 'president', 'prime minister', 
                            'minister', 'policy', 'legislation', 'law', 'bill', 'campaign', 'candidate', 'politician',
                            'parliament', 'capitol', 'white house', 'administration', 'cabinet', 'supreme court',
                            'judicial', 'executive', 'legislative', 'impeachment', 'scandal', 'corruption',
                            'debate', 'rally', 'protest', 'activism', 'conservative', 'liberal', 'progressive',
                            'libertarian', 'socialist', 'communist', 'fascist', 'authoritarian', 'totalitarian',
                            'diplomatic', 'diplomacy', 'international relations', 'foreign policy', 'treaty',
                            'sanctions', 'embargo', 'summit', 'nato', 'un', 'united nations', 'eu', 'brexit',
                            'trump', 'biden', 'harris', 'pelosi', 'mcconnell', 'senate', 'congress'
                        ],
                        domains: ['politico.com', 'washingtonpost.com/politics', 'cnn.com/politics', 
                                'foxnews.com/politics', 'bbc.com/news/politics', 'reuters.com/politics',
                                'apnews.com/politics', 'npr.org/politics', 'thehill.com', 'rollcall.com']
                    },
                    'Philosophy': {
                        icon: 'ü§î',
                        priority: 'medium',
                        keywords: [
                            'philosophy', 'philosophical', 'philosopher', 'ethics', 'moral', 'morality', 'ethics',
                            'metaphysics', 'epistemology', 'logic', 'reasoning', 'argument', 'thesis', 'theory',
                            'kant', 'aristotle', 'plato', 'socrates', 'nietzsche', 'descartes', 'hume', 'locke',
                            'existentialism', 'stoicism', 'nihilism', 'pragmatism', 'rationalism', 'empiricism',
                            'consciousness', 'free will', 'determinism', 'meaning', 'purpose', 'existence',
                            'truth', 'reality', 'knowledge', 'wisdom', 'virtue', 'justice', 'beauty',
                            'aesthetic', 'ontology', 'phenomenology', 'hermeneutics', 'dialectics',
                            'philosophy of mind', 'philosophy of science', 'political philosophy', 'moral philosophy'
                        ],
                        domains: ['plato.stanford.edu', 'philpapers.org', 'philosophy.com', 'iep.utm.edu']
                    },
                    'Psychology': {
                        icon: 'üß†',
                        priority: 'high',
                        keywords: [
                            'psychology', 'psychological', 'psychologist', 'mental health', 'therapy', 'counseling',
                            'cognitive', 'behavioral', 'emotion', 'behavior', 'personality', 'development',
                            'depression', 'anxiety', 'stress', 'trauma', 'ptsd', 'addiction', 'recovery',
                            'mindfulness', 'meditation', 'wellbeing', 'self-care', 'motivation', 'productivity',
                            'neuroscience', 'brain', 'memory', 'learning', 'intelligence', 'consciousness',
                            'psychotherapy', 'psychiatry', 'social psychology', 'developmental psychology',
                            'cognitive psychology', 'behavioral psychology', 'positive psychology', 'research'
                        ],
                        domains: ['psychologytoday.com', 'apa.org', 'ncbi.nlm.nih.gov/pmc', 'psych.org']
                    },
                    'History': {
                        icon: 'üìú',
                        priority: 'medium',
                        keywords: [
                            'history', 'historical', 'historian', 'ancient', 'medieval', 'renaissance', 'revolution',
                            'war', 'battle', 'empire', 'civilization', 'culture', 'tradition', 'heritage',
                            'archaeology', 'artifact', 'museum', 'timeline', 'chronology', 'period', 'era',
                            'world war', 'civil war', 'napoleon', 'roman', 'greek', 'egyptian', 'victorian',
                            'industrial revolution', 'enlightenment', 'reformation', 'colonialism', 'slavery',
                            'independence', 'constitution', 'founding fathers', 'exploration', 'discovery'
                        ],
                        domains: ['history.com', 'nationalgeographic.com/history', 'smithsonianmag.com']
                    },
                    'Business': {
                        icon: 'üíº',
                        priority: 'high',
                        keywords: [
                            'business', 'startup', 'entrepreneur', 'entrepreneurship', 'finance', 'investment',
                            'venture capital', 'vc', 'funding', 'ipo', 'stock market', 'trading', 'economics',
                            'marketing', 'sales', 'strategy', 'management', 'leadership', 'ceo', 'founder',
                            'company', 'corporation', 'revenue', 'profit', 'growth', 'market share',
                            'branding', 'advertising', 'digital marketing', 'seo', 'sem', 'social media marketing',
                            'customer acquisition', 'retention', 'conversion', 'analytics', 'metrics',
                            'productivity', 'workflow', 'automation', 'efficiency', 'remote work',
                            'team management', 'project management', 'agile', 'scrum', 'collaboration',
                            'money', 'financial', 'economy', 'market', 'industry', 'corporate'
                        ],
                        domains: ['linkedin.com', 'forbes.com', 'bloomberg.com', 'businessinsider.com', 
                                'harvard.business.review', 'wsj.com', 'ft.com', 'entrepreneur.com',
                                'inc.com', 'fastcompany.com', 'techcrunch.com', 'crunchbase.com']
                    },
                    'Science': {
                        icon: 'üî¨',
                        priority: 'high',
                        keywords: [
                            'science', 'research', 'study', 'experiment', 'discovery', 'theory', 'hypothesis',
                            'biology', 'chemistry', 'physics', 'mathematics', 'statistics', 'data science',
                            'medicine', 'medical', 'clinical', 'pharmaceutical', 'drug', 'vaccine',
                            'climate', 'environment', 'sustainability', 'renewable energy', 'solar', 'wind',
                            'space', 'astronomy', 'nasa', 'spacex', 'mars', 'rocket', 'satellite',
                            'genetics', 'dna', 'genome', 'crispr', 'biotechnology', 'biotech',
                            'neuroscience', 'brain', 'psychology', 'cognitive', 'mental health',
                            'quantum', 'particle', 'energy', 'nuclear', 'microscopy', 'telescope',
                            'scientific', 'laboratory', 'analysis', 'methodology'
                        ],
                        domains: ['arxiv.org', 'nature.com', 'science.org', 'plos.org', 'pubmed.ncbi.nlm.nih.gov',
                                'scientificamerican.com', 'newscientist.com', 'sciencedaily.com', 'cell.com']
                    },
                    'Design': {
                        icon: 'üé®',
                        priority: 'medium',
                        keywords: [
                            'design', 'ui', 'ux', 'user experience', 'user interface', 'visual design',
                            'graphic design', 'web design', 'product design', 'interaction design',
                            'creative', 'art', 'illustration', 'typography', 'font', 'color', 'palette',
                            'layout', 'composition', 'grid', 'wireframe', 'prototype', 'mockup',
                            'figma', 'sketch', 'adobe', 'photoshop', 'illustrator', 'indesign',
                            'branding', 'logo', 'identity', 'brand', 'aesthetic', 'minimalism',
                            'accessibility', 'usability', 'human centered', 'design thinking',
                            'portfolio', 'dribbble', 'behance', 'awwwards', 'designer'
                        ],
                        domains: ['dribbble.com', 'behance.net', 'medium.com/tag/design', 'uxdesign.cc',
                                'smashingmagazine.com', 'designmodo.com', 'awwwards.com', 'uxplanet.org']
                    },
                    'Economics': {
                        icon: 'üìä',
                        priority: 'high',
                        keywords: [
                            'economics', 'economy', 'economic', 'economist', 'gdp', 'inflation', 'recession',
                            'monetary policy', 'fiscal policy', 'federal reserve', 'interest rates', 'unemployment',
                            'market', 'capitalism', 'socialism', 'macroeconomics', 'microeconomics',
                            'supply', 'demand', 'price', 'cost', 'value', 'currency', 'exchange rate',
                            'trade', 'import', 'export', 'tariff', 'globalization', 'inequality', 'poverty'
                        ],
                        domains: ['economist.com', 'bloomberg.com', 'ft.com', 'wsj.com', 'federalreserve.gov']
                    },
                    'Climate': {
                        icon: 'üåç',
                        priority: 'high',
                        keywords: [
                            'climate', 'climate change', 'global warming', 'environment', 'environmental',
                            'sustainability', 'renewable energy', 'solar', 'wind', 'carbon', 'emissions',
                            'greenhouse gas', 'fossil fuel', 'pollution', 'conservation', 'biodiversity',
                            'ecosystem', 'deforestation', 'ocean', 'arctic', 'temperature', 'weather',
                            'paris agreement', 'ipcc', 'cop26', 'green', 'clean energy', 'electric vehicle'
                        ],
                        domains: ['climate.gov', 'epa.gov', 'ipcc.ch', 'nationalgeographic.com/environment']
                    },
                    'News': {
                        icon: 'üì∞',
                        priority: 'medium',
                        keywords: [
                            'news', 'breaking news', 'current events', 'journalism', 'reporter', 'media',
                            'international', 'global', 'world', 'country', 'nation', 'crisis', 'conflict', 
                            'war', 'peace', 'security', 'terrorism', 'social', 'society', 'culture', 
                            'community', 'public', 'civil rights', 'breaking', 'latest', 'update', 'report'
                        ],
                        domains: ['bbc.com', 'cnn.com', 'nytimes.com', 'washingtonpost.com', 'guardian.co.uk',
                                'reuters.com', 'ap.org', 'npr.org', 'wsj.com', 'ft.com', 'economist.com']
                    },
                    'Health': {
                        icon: 'üè•',
                        priority: 'high',
                        keywords: [
                            'health', 'healthy', 'wellness', 'fitness', 'exercise', 'workout', 'training',
                            'nutrition', 'diet', 'food', 'eating', 'weight loss', 'muscle', 'strength',
                            'cardio', 'running', 'yoga', 'meditation', 'mindfulness', 'mental health',
                            'medical', 'medicine', 'doctor', 'physician', 'patient', 'treatment',
                            'therapy', 'rehabilitation', 'recovery', 'surgery', 'hospital', 'clinic',
                            'disease', 'illness', 'symptoms', 'diagnosis', 'prevention', 'immune',
                            'vitamin', 'supplement', 'organic', 'natural', 'holistic', 'alternative',
                            'healthcare', 'pharmaceutical', 'drug', 'vaccine'
                        ],
                        domains: ['mayoclinic.org', 'webmd.com', 'healthline.com', 'nih.gov', 'who.int',
                                'medicalnewstoday.com', 'everydayhealth.com', 'health.com', 'myfitnesspal.com']
                    },
                    'Education': {
                        icon: 'üéì',
                        priority: 'medium',
                        keywords: [
                            'education', 'learning', 'teaching', 'teacher', 'student', 'school', 'university',
                            'college', 'course', 'class', 'lesson', 'tutorial', 'training', 'workshop',
                            'academic', 'academia', 'research', 'study', 'exam', 'test', 'grade',
                            'degree', 'diploma', 'certificate', 'certification', 'skill', 'knowledge',
                            'online learning', 'elearning', 'mooc', 'distance learning', 'homeschool',
                            'curriculum', 'pedagogy', 'educational technology', 'edtech', 'educational'
                        ],
                        domains: ['coursera.org', 'edx.org', 'khanacademy.org', 'udemy.com', 'wikipedia.org',
                                'mit.edu', 'stanford.edu', 'harvard.edu', 'yale.edu', 'oxford.ac.uk']
                    },
                    'Entertainment': {
                        icon: 'üé¨',
                        priority: 'medium',
                        keywords: [
                            'entertainment', 'movie', 'film', 'cinema', 'tv', 'television', 'show', 'series',
                            'streaming', 'netflix', 'disney', 'hulu', 'amazon prime', 'hbo', 'youtube',
                            'music', 'song', 'album', 'artist', 'musician', 'concert', 'festival',
                            'spotify', 'apple music', 'podcast', 'gaming', 'video game', 'game',
                            'esports', 'twitch', 'steam', 'playstation', 'xbox', 'nintendo',
                            'celebrity', 'actor', 'actress', 'director', 'producer', 'hollywood',
                            'review', 'rating', 'critic', 'trailer', 'release', 'box office'
                        ],
                        domains: ['youtube.com', 'netflix.com', 'spotify.com', 'imdb.com', 'ign.com',
                                'gamespot.com', 'polygon.com', 'variety.com', 'hollywoodreporter.com']
                    },
                    'Travel': {
                        icon: '‚úàÔ∏è',
                        priority: 'medium',
                        keywords: [
                            'travel', 'traveling', 'trip', 'vacation', 'holiday', 'journey', 'adventure',
                            'tourism', 'tourist', 'destination', 'explore', 'exploration', 'discovery',
                            'flight', 'airline', 'airport', 'hotel', 'accommodation', 'booking',
                            'backpacking', 'solo travel', 'family travel', 'business travel',
                            'culture', 'cultural', 'local', 'tradition', 'heritage', 'history',
                            'guide', 'guidebook', 'itinerary', 'recommendation', 'review',
                            'country', 'city', 'region', 'continent', 'international', 'domestic'
                        ],
                        domains: ['tripadvisor.com', 'booking.com', 'airbnb.com', 'lonelyplanet.com',
                                'expedia.com', 'kayak.com', 'skyscanner.com', 'nationalgeographic.com']
                    },
                    'Food': {
                        icon: 'üç≥',
                        priority: 'medium',
                        keywords: [
                            'food', 'cooking', 'recipe', 'chef', 'cuisine', 'culinary', 'kitchen',
                            'ingredient', 'meal', 'dish', 'restaurant', 'dining', 'eat', 'eating',
                            'baking', 'pastry', 'dessert', 'cake', 'bread', 'healthy eating',
                            'vegan', 'vegetarian', 'gluten free', 'organic', 'farm to table',
                            'wine', 'beer', 'cocktail', 'beverage', 'drink', 'coffee', 'tea',
                            'taste', 'flavor', 'spice', 'herb', 'seasoning', 'sauce', 'marinade'
                        ],
                        domains: ['allrecipes.com', 'foodnetwork.com', 'epicurious.com', 'bonappetit.com',
                                'seriouseats.com', 'tasteofhome.com', 'food.com', 'yummly.com']
                    },
                    'Sports': {
                        icon: '‚öΩ',
                        priority: 'medium',
                        keywords: [
                            'sports', 'sport', 'football', 'soccer', 'basketball', 'baseball', 'tennis',
                            'golf', 'hockey', 'olympics', 'athletic', 'athlete', 'team', 'player',
                            'game', 'match', 'tournament', 'championship', 'league', 'season',
                            'fitness', 'training', 'workout', 'exercise', 'competition', 'competitive',
                            'coaching', 'strategy', 'performance', 'statistics', 'score', 'win', 'loss'
                        ],
                        domains: ['espn.com', 'sports.com', 'bleacherreport.com', 'nfl.com', 'nba.com',
                                'mlb.com', 'nhl.com', 'fifa.com', 'olympic.org', 'si.com']
                    },
                    'Finance': {
                        icon: 'üí∞',
                        priority: 'high',
                        keywords: [
                            'finance', 'financial', 'money', 'investment', 'investing', 'investor',
                            'stock', 'bond', 'portfolio', 'trading', 'cryptocurrency', 'bitcoin',
                            'blockchain', 'fintech', 'banking', 'bank', 'credit', 'debt', 'loan',
                            'mortgage', 'insurance', 'retirement', '401k', 'ira', 'pension',
                            'budget', 'budgeting', 'saving', 'spending', 'tax', 'taxes',
                            'wealth', 'rich', 'millionaire', 'financial planning', 'advisor'
                        ],
                        domains: ['bloomberg.com', 'reuters.com', 'marketwatch.com', 'yahoo.finance',
                                'wsj.com', 'ft.com', 'cnbc.com', 'thestreet.com', 'morningstar.com']
                    }
                };
            }

            // REVOLUTIONARY: Improved categorization algorithm with smart category creation
            categorizeArticle(article) {
                const title = (article.title || '').toLowerCase();
                const excerpt = (article.excerpt || '').toLowerCase();
                const url = (article.url || '').toLowerCase();
                const domain = this.getDomain(article.url).toLowerCase();
                const content = this.getArticleContentForAnalysis(article).toLowerCase();

                // Store current article for smart category creation
                this.currentAnalyzingArticle = article;

                // Combine all text for analysis
                const fullText = `${title} ${excerpt} ${content}`.substring(0, 5000);
                
                console.log(`ü§ñ SMART Auto-categorizing: "${article.title.substring(0, 50)}..."`);

                // Extract keywords using improved algorithm
                const extractedKeywords = this.extractKeywords(fullText);
                
                // Score categories using enhanced scoring
                const categoryScores = this.calculateImprovedCategoryScores(article, fullText, extractedKeywords, domain, url);
                
                // Find best category with revolutionary smart creation
                const result = this.selectBestCategory(categoryScores);
                
                // Store results
                article.category = result.category;
                article.categoryScore = result.score;
                article.categoryConfidence = result.confidence;
                article.extractedKeywords = extractedKeywords.slice(0, 10);
                
                console.log(`üéØ RESULT: "${result.category}" (confidence: ${result.confidence}, score: ${Math.round(result.score)})`);
                
                // Clear current analyzing article
                this.currentAnalyzingArticle = null;
                
                return result.category;
            }

            extractKeywords(text) {
                const words = text.toLowerCase()
                    .replace(/[^\w\s]/g, ' ')
                    .split(/\s+/)
                    .filter(word => word.length > 3 && !this.stopWords.has(word));

                const wordFreq = {};
                words.forEach(word => {
                    wordFreq[word] = (wordFreq[word] || 0) + 1;
                });

                // Calculate TF-IDF-like score
                const totalWords = words.length;
                const keywordScores = [];

                Object.entries(wordFreq).forEach(([word, freq]) => {
                    const tf = freq / totalWords;
                    const lengthBoost = Math.min(word.length / 8, 2);
                    const techBoost = this.isTechnicalTerm(word) ? 1.5 : 1;
                    const score = tf * lengthBoost * techBoost * freq;
                    
                    if (score > 0.001 && freq > 1) {
                        keywordScores.push({ word, score, freq });
                    }
                });

                return keywordScores
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 20)
                    .map(item => item.word);
            }

            isTechnicalTerm(word) {
                const technicalPatterns = [
                    /^[a-z]+ing$/, /^[a-z]+tion$/, /^[a-z]+ment$/, /^[a-z]+ness$/,
                    /^[a-z]+ity$/, /^[a-z]+ology$/
                ];

                return technicalPatterns.some(pattern => pattern.test(word)) ||
                       word.includes('tech') || word.includes('science') || word.includes('digital');
            }

            // FIXED: Enhanced scoring algorithm with better accuracy
            calculateImprovedCategoryScores(article, fullText, extractedKeywords, domain, url) {
                const scores = new Map();
                const title = article.title.toLowerCase();

                for (const [categoryName, categoryData] of Object.entries(this.categoryKeywords)) {
                    let score = 0;
                    let matches = [];

                    // 1. Domain matching (highest weight - 200 points) - INCREASED
                    if (categoryData.domains.some(d => domain.includes(d))) {
                        score += 200;
                        matches.push(`domain:${domain}`);
                    }

                    // 2. Title exact word matching (very high weight - 150 points per match) - INCREASED
                    const titleWords = title.split(/\s+/);
                    for (const keyword of categoryData.keywords) {
                        const keywordLower = keyword.toLowerCase();
                        
                        if (titleWords.includes(keywordLower)) {
                            score += 150;
                            matches.push(`title-exact:${keyword}`);
                        } else if (title.includes(keywordLower)) {
                            score += 80; // INCREASED from 60
                            matches.push(`title-contains:${keyword}`);
                        }
                    }

                    // 3. Direct keyword matching in extracted keywords (high weight - 120 points) - INCREASED
                    for (const keyword of categoryData.keywords) {
                        if (extractedKeywords.includes(keyword.toLowerCase())) {
                            score += 120;
                            matches.push(`extracted:${keyword}`);
                        }
                    }

                    // 4. Content matching with frequency weighting (medium weight - 8-40 points) - INCREASED
                    for (const keyword of categoryData.keywords) {
                        const regex = new RegExp(`\\b${keyword.toLowerCase()}\\b`, 'gi');
                        const contentMatches = fullText.match(regex);
                        if (contentMatches) {
                            const contextScore = Math.min(contentMatches.length * 8, 40); // INCREASED
                            score += contextScore;
                            matches.push(`content:${keyword}(${contentMatches.length}x)`);
                        }
                    }

                    // 5. URL path analysis (low weight - 15 points) - INCREASED
                    for (const keyword of categoryData.keywords) {
                        if (url.includes(keyword.toLowerCase())) {
                            score += 15;
                            matches.push(`url:${keyword}`);
                        }
                    }

                    // 6. Compound keyword bonus for exact phrase matches - INCREASED
                    const compoundKeywords = categoryData.keywords.filter(k => k.includes(' '));
                    for (const compound of compoundKeywords) {
                        if (title.includes(compound.toLowerCase())) {
                            score += 180; // INCREASED from 120
                            matches.push(`compound-title:${compound}`);
                        } else if (fullText.includes(compound.toLowerCase())) {
                            score += 90; // INCREASED from 60
                            matches.push(`compound-content:${compound}`);
                        }
                    }

                    // 7. Category priority boost
                    if (categoryData.priority === 'high') {
                        score *= 1.1; // Slightly increased
                    }

                    // 8. Clear weak matches (but more lenient threshold)
                    if (matches.length === 0 && score < 15) { // LOWERED from 20
                        score = 0;
                    }

                    scores.set(categoryName, { score, matches });
                }

                return scores;
            }

            // REVOLUTIONARY: Improved confidence calculation with AGGRESSIVE category creation
            selectBestCategory(categoryScores) {
                let bestCategory = 'Other';
                let bestScore = 0;
                let secondBestScore = 0;

                const sortedScores = Array.from(categoryScores.entries())
                    .sort((a, b) => b[1].score - a[1].score);

                if (sortedScores.length > 0) {
                    bestScore = sortedScores[0][1].score;
                    if (bestScore >= this.minCategoryConfidence) {
                        bestCategory = sortedScores[0][0];
                    }
                }

                if (sortedScores.length > 1) {
                    secondBestScore = sortedScores[1][1].score;
                }

                // REVOLUTIONARY: If no good match found, create new category instead of "Other"
                if (bestCategory === 'Other' && bestScore < this.minCategoryConfidence) {
                    const newCategory = this.createSmartCategory(this.currentAnalyzingArticle);
                    if (newCategory && newCategory !== 'Other') {
                        console.log(`üî• CREATING NEW CATEGORY: "${newCategory}" for article: "${this.currentAnalyzingArticle?.title?.substring(0, 30)}..."`);
                        bestCategory = newCategory;
                        bestScore = this.minCategoryConfidence + 5; // Give it a decent score
                    }
                }

                // FIXED: Much more lenient confidence calculation
                let confidence = 'low';
                const scoreDifference = bestScore - secondBestScore;
                
                if (bestScore >= 80 && scoreDifference >= 25) { // LOWERED from 100/40
                    confidence = 'high';
                } else if (bestScore >= 50 && scoreDifference >= 15) { // LOWERED from 60/20
                    confidence = 'medium';
                } else if (bestScore >= this.minCategoryConfidence && scoreDifference >= 5) { // LOWERED from 10
                    confidence = 'low';
                }

                return {
                    category: bestCategory,
                    score: bestScore,
                    confidence: confidence,
                    scoreDifference: scoreDifference,
                    allScores: sortedScores.slice(0, 3)
                };
            }

            // REVOLUTIONARY: Smart category creation from article content
            createSmartCategory(article) {
                if (!article) return 'Other';

                const title = article.title.toLowerCase();
                const excerpt = (article.excerpt || '').toLowerCase();
                const domain = this.getDomain(article.url).toLowerCase();
                const fullText = `${title} ${excerpt}`.substring(0, 1000);

                console.log(`üß† Creating smart category for: "${title.substring(0, 50)}..."`);

                // STRATEGY 1: Extract obvious category words from title
                const categoryWords = this.extractCategoryFromTitle(title);
                if (categoryWords) {
                    console.log(`‚úÖ Found category from title: ${categoryWords}`);
                    return categoryWords;
                }

                // STRATEGY 2: Analyze domain patterns
                const domainCategory = this.extractCategoryFromDomain(domain);
                if (domainCategory) {
                    console.log(`‚úÖ Found category from domain: ${domainCategory}`);
                    return domainCategory;
                }

                // STRATEGY 3: Extract topic from content using keyword clustering
                const topicCategory = this.extractTopicFromContent(fullText);
                if (topicCategory) {
                    console.log(`‚úÖ Found category from content analysis: ${topicCategory}`);
                    return topicCategory;
                }

                // STRATEGY 4: Use the most frequent meaningful word as category
                const words = title.split(/\s+/).filter(word => 
                    word.length > 4 && 
                    !this.stopWords.has(word) && 
                    !['article', 'guide', 'tutorial', 'introduction'].includes(word)
                );

                if (words.length > 0) {
                    const category = this.formatCategoryName(words[0]);
                    console.log(`‚úÖ Created category from title word: ${category}`);
                    return category;
                }

                console.log(`‚ùå Could not create smart category, using Other`);
                return 'Other';
            }

            // Extract category from title patterns
            extractCategoryFromTitle(title) {
                // Common category patterns in titles
                const patterns = {
                    'Artificial Intelligence': ['artificial intelligence', 'machine learning', 'deep learning', 'neural network', 'ai model'],
                    'Cryptocurrency': ['cryptocurrency', 'bitcoin', 'ethereum', 'blockchain', 'crypto', 'defi', 'nft'],
                    'Climate Science': ['climate change', 'global warming', 'carbon emission', 'renewable energy', 'sustainability'],
                    'Space Exploration': ['space exploration', 'nasa', 'spacex', 'mars mission', 'astronomy', 'satellite'],
                    'Cybersecurity': ['cybersecurity', 'data breach', 'hacking', 'security vulnerability', 'cyber attack'],
                    'Mental Health': ['mental health', 'depression', 'anxiety', 'therapy', 'psychological'],
                    'Social Media': ['social media', 'facebook', 'twitter', 'instagram', 'tiktok', 'linkedin'],
                    'Productivity': ['productivity', 'time management', 'efficiency', 'workflow', 'organization'],
                    'Remote Work': ['remote work', 'work from home', 'telecommuting', 'distributed team'],
                    'Personal Finance': ['personal finance', 'budgeting', 'saving money', 'investment', 'retirement'],
                    'Entrepreneurship': ['entrepreneurship', 'startup', 'business idea', 'venture capital'],
                    'Data Science': ['data science', 'machine learning', 'analytics', 'big data', 'statistics'],
                    'Web Development': ['web development', 'frontend', 'backend', 'fullstack', 'javascript'],
                    'Mobile Development': ['mobile development', 'ios development', 'android development', 'app development'],
                    'Gaming': ['gaming', 'video games', 'esports', 'game development', 'nintendo', 'playstation'],
                    'Photography': ['photography', 'camera', 'photo editing', 'photoshop', 'portrait'],
                    'Music Production': ['music production', 'audio engineering', 'recording', 'mixing'],
                    'Real Estate': ['real estate', 'property investment', 'housing market', 'mortgage'],
                    'Fashion': ['fashion', 'style', 'clothing', 'designer', 'trends'],
                    'Fitness': ['fitness', 'workout', 'exercise', 'gym', 'bodybuilding', 'strength training'],
                    'Meditation': ['meditation', 'mindfulness', 'yoga', 'spirituality', 'zen'],
                    'Parenting': ['parenting', 'children', 'kids', 'family', 'childcare'],
                    'Career Development': ['career development', 'job search', 'resume', 'interview', 'professional'],
                    'Leadership': ['leadership', 'management', 'team building', 'executive'],
                    'Marketing': ['marketing', 'advertising', 'branding', 'digital marketing', 'seo'],
                    'Philosophy': ['philosophy', 'ethics', 'morality', 'existentialism', 'stoicism'],
                    'Politics': ['politics', 'election', 'government', 'policy', 'democracy'],
                    'History': ['history', 'historical', 'ancient', 'medieval', 'war', 'civilization'],
                    'Literature': ['literature', 'poetry', 'novel', 'writing', 'author', 'book'],
                    'Art': ['art', 'painting', 'sculpture', 'artist', 'gallery', 'museum'],
                    'Architecture': ['architecture', 'building design', 'urban planning', 'construction']
                };

                for (const [category, keywords] of Object.entries(patterns)) {
                    for (const keyword of keywords) {
                        if (title.includes(keyword)) {
                            return category;
                        }
                    }
                }

                return null;
            }

            // Extract category from domain patterns
            extractCategoryFromDomain(domain) {
                const domainPatterns = {
                    'Cryptocurrency': ['coindesk', 'coinbase', 'binance', 'crypto', 'bitcoin'],
                    'Gaming': ['ign.com', 'gamespot', 'polygon', 'kotaku', 'steam'],
                    'Photography': ['petapixel', 'dpreview', 'fstoppers', 'photo'],
                    'Music': ['pitchfork', 'rolling stone', 'spotify', 'soundcloud'],
                    'Real Estate': ['zillow', 'realtor', 'redfin', 'trulia'],
                    'Fashion': ['vogue', 'elle', 'fashion', 'style'],
                    'Fitness': ['bodybuilding', 'fitness', 'muscle', 'workout'],
                    'Programming': ['github', 'stackoverflow', 'dev.to', 'freecodecamp'],
                    'Academic': ['.edu', 'scholar', 'research', 'university'],
                    'Government': ['.gov', 'whitehouse', 'congress', 'senate'],
                    'Nonprofit': ['.org', 'charity', 'foundation', 'nonprofit']
                };

                for (const [category, patterns] of Object.entries(domainPatterns)) {
                    for (const pattern of patterns) {
                        if (domain.includes(pattern)) {
                            return category;
                        }
                    }
                }

                return null;
            }

            // Extract topic from content using keyword clustering
            extractTopicFromContent(text) {
                const words = text.toLowerCase()
                    .replace(/[^\w\s]/g, ' ')
                    .split(/\s+/)
                    .filter(word => word.length > 4 && !this.stopWords.has(word));

                // Count word frequencies
                const wordFreq = {};
                words.forEach(word => {
                    wordFreq[word] = (wordFreq[word] || 0) + 1;
                });

                // Find most frequent meaningful words
                const topWords = Object.entries(wordFreq)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .map(([word]) => word);

                // Topic clusters based on common word combinations
                const topicClusters = {
                    'Artificial Intelligence': ['artificial', 'intelligence', 'machine', 'learning', 'neural', 'algorithm'],
                    'Climate Science': ['climate', 'warming', 'carbon', 'emissions', 'environment', 'energy'],
                    'Cryptocurrency': ['crypto', 'bitcoin', 'blockchain', 'ethereum', 'digital', 'currency'],
                    'Space Exploration': ['space', 'rocket', 'mars', 'mission', 'satellite', 'universe'],
                    'Mental Health': ['mental', 'health', 'therapy', 'depression', 'anxiety', 'psychological'],
                    'Data Science': ['data', 'analysis', 'statistics', 'research', 'study', 'findings'],
                    'Cybersecurity': ['security', 'cyber', 'hacking', 'breach', 'vulnerability', 'attack'],
                    'Social Issues': ['social', 'society', 'community', 'culture', 'inequality', 'justice'],
                    'Innovation': ['innovation', 'technology', 'future', 'breakthrough', 'advancement', 'progress'],
                    'Productivity': ['productivity', 'efficiency', 'workflow', 'organization', 'management', 'time'],
                    'Personal Development': ['personal', 'development', 'growth', 'improvement', 'skills', 'habits']
                };

                for (const [topic, clusterWords] of Object.entries(topicClusters)) {
                    const matchCount = clusterWords.filter(word => topWords.includes(word)).length;
                    if (matchCount >= 2) { // Need at least 2 matching words
                        return topic;
                    }
                }

                return null;
            }

            // Discover dynamic categories from content
            discoverDynamicCategories() {
                if (!this.enableDynamicCategories || this.articles.length < 10) return;

                console.log('üîç Discovering dynamic categories from content...');
                
                const allKeywords = new Map();
                const keywordArticles = new Map();

                for (const article of this.articles) {
                    if (article.extractedKeywords) {
                        article.extractedKeywords.forEach(keyword => {
                            allKeywords.set(keyword, (allKeywords.get(keyword) || 0) + 1);
                            
                            if (!keywordArticles.has(keyword)) {
                                keywordArticles.set(keyword, []);
                            }
                            keywordArticles.get(keyword).push(article);
                        });
                    }
                }

                const potentialCategories = [];
                for (const [keyword, count] of allKeywords.entries()) {
                    if (count >= 3 && keyword.length > 4) {
                        const articles = keywordArticles.get(keyword);
                        const uniqueDomains = new Set(articles.map(a => this.getDomain(a.url))).size;
                        
                        if (uniqueDomains >= 2) {
                            potentialCategories.push({
                                name: this.formatCategoryName(keyword),
                                keyword: keyword,
                                count: count,
                                articles: articles,
                                score: count * uniqueDomains
                            });
                        }
                    }
                }

                const topCategories = potentialCategories
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 5);

                topCategories.forEach(cat => {
                    this.dynamicCategories.set(cat.name, {
                        icon: this.guessIconForCategory(cat.keyword),
                        articles: cat.articles,
                        dynamic: true,
                        keyword: cat.keyword
                    });
                });

                if (topCategories.length > 0) {
                    console.log(`‚ú® Discovered ${topCategories.length} dynamic categories:`, 
                              topCategories.map(c => c.name).join(', '));
                }
            }

            formatCategoryName(keyword) {
                return keyword.charAt(0).toUpperCase() + keyword.slice(1)
                    .replace(/([a-z])([A-Z])/g, '$1 $2')
                    .replace(/[-_]/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase());
            }

            guessIconForCategory(keyword) {
                const iconMap = {
                    'crypto': '‚Çø', 'blockchain': '‚õìÔ∏è', 'ai': 'ü§ñ', 'machine': 'ü§ñ',
                    'cloud': '‚òÅÔ∏è', 'mobile': 'üì±', 'security': 'üîí', 'data': 'üìä',
                    'marketing': 'üìà', 'social': 'üë•', 'music': 'üéµ', 'photo': 'üì∏',
                    'video': 'üé•', 'game': 'üéÆ', 'book': 'üìö', 'history': 'üìú',
                    'politics': 'üèõÔ∏è', 'energy': '‚ö°', 'environment': 'üåç', 'space': 'üöÄ'
                };

                for (const [term, icon] of Object.entries(iconMap)) {
                    if (keyword.includes(term)) return icon;
                }

                return 'üìã';
            }

            // FIXED: Re-categorize all articles with enhanced intelligence
            recategorizeAllArticles() {
                console.log('üìÇ Auto-categorizing all articles...');
                this.categories.clear();
                this.dynamicCategories.clear();

                // First pass: categorize all articles
                for (const article of this.articles) {
                    const category = this.categorizeArticle(article);
                    this.categories.set(category, (this.categories.get(category) || 0) + 1);
                }

                // Second pass: discover dynamic categories
                this.discoverDynamicCategories();

                // Merge static and dynamic categories for display
                const allCategories = new Map([...this.categories]);
                for (const [dynCat, dynData] of this.dynamicCategories.entries()) {
                    allCategories.set(dynCat, dynData.articles.length);
                }

                console.log(`üß† Categorization complete: ${allCategories.size} categories found`);
                console.log(`üìä Distribution:`, Object.fromEntries(allCategories));
                
                this.updateCategoryUI();
                this.updateSidebarCategories();
            }

            // FIXED: Enhanced category UI with AI indicators
            updateCategoryUI() {
                const categoryChips = document.getElementById('categoryChips');
                if (!categoryChips) return;

                // Merge static and dynamic categories
                const allCategories = new Map();
                
                for (const [cat, count] of this.categories.entries()) {
                    allCategories.set(cat, {
                        count: count,
                        dynamic: false,
                        icon: this.categoryKeywords[cat]?.icon || 'üìÑ'
                    });
                }
                
                for (const [cat, data] of this.dynamicCategories.entries()) {
                    allCategories.set(cat, {
                        count: data.articles.length,
                        dynamic: true,
                        icon: data.icon
                    });
                }

                const sortedCategories = Array.from(allCategories.entries())
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, this.maxCategories);

                const totalArticles = this.currentDisplayedArticles.length;

                const dynamicCount = Array.from(allCategories.values()).filter(c => c.dynamic).length;
                const aiIndicator = dynamicCount > 0 ? ` (${dynamicCount} AI-discovered)` : '';

                categoryChips.innerHTML = `
                    <div class="category-chip show-all ${!this.activeCategory ? 'active' : ''}" 
                         onclick="webReader.filterByCategory(null)">
                        <span>ü§ñ</span>
                        <span>All Articles</span>
                        <span class="category-count">${totalArticles}</span>
                    </div>
                    ${sortedCategories.map(([category, data]) => {
                        const isActive = this.activeCategory === category;
                        const isDynamic = data.dynamic;
                        const dynamicBadge = isDynamic ? ' üî•' : '';
                        const title = isDynamic 
                            ? `AI-discovered category: ${category} (${data.count} articles)`
                            : `${category} (${data.count} articles)`;
                        
                        return `
                            <div class="category-chip ${isActive ? 'active' : ''}" 
                                 onclick="webReader.filterByCategory('${category}')"
                                 title="${title}">
                                <span>${data.icon}${dynamicBadge}</span>
                                <span>${category}</span>
                                <span class="category-count">${data.count}</span>
                            </div>
                        `;
                    }).join('')}
                `;

                // Update header to show category capabilities
                const header = categoryChips.parentElement.querySelector('.category-header h3');
                if (header && dynamicCount > 0) {
                    header.textContent = `üìÇ AI-Powered Category Filter (${dynamicCount} discovered)`;
                }
                
                this.updateSidebarCounts();
            }

            // FIXED: Update sidebar with dynamic categories
            updateSidebarCategories() {
                const categoryNav = document.getElementById('dynamicCategoryNav');
                if (!categoryNav) return;

                // Show top 5 categories in sidebar
                const allCategories = new Map([...this.categories]);
                for (const [dynCat, dynData] of this.dynamicCategories.entries()) {
                    allCategories.set(dynCat, dynData.articles.length);
                }

                const topCategories = Array.from(allCategories.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5);

                categoryNav.innerHTML = topCategories.map(([category, count]) => {
                    const categoryData = this.categoryKeywords[category] || this.dynamicCategories.get(category) || { icon: 'üìÑ' };
                    const isDynamic = this.dynamicCategories.has(category);
                    const isActive = this.activeCategory === category;
                    
                    return `
                        <button class="nav-item ${isActive ? 'active' : ''}" 
                                onclick="webReader.filterByCategory('${category}')">
                            <span class="icon">${categoryData.icon}${isDynamic ? 'üî•' : ''}</span>
                            <span class="label">${category}</span>
                            <span class="badge">${count}</span>
                        </button>
                    `;
                }).join('');
            }

            // Enhanced category badge with confidence indicators
            getCategoryBadgeHTML(article) {
                if (!article.category) {
                    this.categorizeArticle(article);
                }

                const category = article.category || 'Other';
                const confidence = article.categoryConfidence || 'low';
                const isDynamic = this.dynamicCategories.has(category);
                
                let categoryData = this.categoryKeywords[category];
                if (!categoryData && isDynamic) {
                    categoryData = this.dynamicCategories.get(category);
                }
                
                const icon = categoryData?.icon || 'üìÑ';
                const confidenceClass = confidence ? `${confidence}-confidence` : '';
                const dynamicIndicator = isDynamic ? ' üî•' : '';

                return `
                    <div class="article-category ${confidenceClass}" 
                         title="AI Category: ${category} (${confidence} confidence)${isDynamic ? ' - AI discovered' : ''}">
                        ${icon}${dynamicIndicator} ${category}
                    </div>
                `;
            }

            // Filter by category including dynamic categories
            filterByCategory(category) {
                this.activeCategory = category;

                let filtered;
                if (!category) {
                    filtered = this.articles;
                } else {
                    if (this.dynamicCategories.has(category)) {
                        filtered = this.dynamicCategories.get(category).articles;
                    } else {
                        filtered = this.articles.filter(article => {
                            if (!article.category) {
                                this.categorizeArticle(article);
                            }
                            return article.category === category;
                        });
                    }
                }

                this.currentDisplayedArticles = filtered;
                this.displayArticles(filtered);

                this.updateCategoryUI();
                this.updateSidebarCategories();

                if (!category) {
                    this.updateStatus(`ü§ñ Showing all ${filtered.length} articles`, 'success');
                } else {
                    const isDynamic = this.dynamicCategories.has(category);
                    const aiIndicator = isDynamic ? 'üî• AI-discovered' : '';
                    const categoryData = this.categoryKeywords[category] || this.dynamicCategories.get(category) || { icon: 'üìÑ' };
                    this.updateStatus(`${categoryData.icon} Showing ${filtered.length} ${category.toLowerCase()} articles ${aiIndicator}`, 'success');
                }

                console.log(`ü§ñ Filtered by AI category: ${category || 'All'} (${filtered.length} articles)`);
            }

            // ===== END ENHANCED AI CATEGORIZATION SYSTEM =====

            init() {
                this.setupEventListeners();
                this.checkAuthFromURL();
                this.loadStoredToken();
                this.loadThemePreference();
                this.loadImageCache();
            }

            setupEventListeners() {
                document.getElementById('searchInput').addEventListener('input', (e) => this.searchArticles(e.target.value));
                document.getElementById('closeReader').addEventListener('click', () => this.closeReader());
                document.getElementById('openOriginal').addEventListener('click', () => this.openOriginal());

                // Search toggle keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                        e.preventDefault();
                        this.toggleSearch(true);
                    } else if (e.key === '/' && !this.isInputFocused()) {
                        e.preventDefault();
                        this.toggleSearch(true);
                    } else if (e.key === 'Escape') {
                        this.toggleSearch(false);
                    }
                });

                // Close search when clicking outside
                document.addEventListener('click', (e) => {
                    const searchContainer = document.getElementById('searchContainer');
                    const searchToggleBtn = document.getElementById('searchToggleBtn');

                    if (searchContainer.style.display !== 'none' &&
                        !searchContainer.contains(e.target) &&
                        !searchToggleBtn.contains(e.target)) {
                        this.toggleSearch(false);
                    }
                });

                // Close category filter when clicking outside
                document.addEventListener('click', (e) => {
                    const categoryContainer = document.getElementById('categoryContainer');
                    const categoriesBtn = document.getElementById('categoriesBtn');

                    if (categoryContainer.style.display !== 'none' &&
                        !categoryContainer.contains(e.target) &&
                        !categoriesBtn.contains(e.target)) {
                        this.toggleCategoryFilter(false);
                    }
                });

                // Close mobile menu when clicking on overlay
                document.addEventListener('click', (e) => {
                    const sidebar = document.getElementById('sidebar');
                    const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
                    
                    if (window.innerWidth <= 768 && 
                        sidebar.classList.contains('mobile-open') &&
                        !sidebar.contains(e.target) && 
                        !mobileMenuBtn?.contains(e.target)) {
                        this.toggleMobileMenu();
                    }
                });
            }

            isInputFocused() {
                const activeElement = document.activeElement;
                return activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');
            }

            // Toggle category filter visibility
            toggleCategoryFilter(forceState = null) {
                const categoryContainer = document.getElementById('categoryContainer');
                const categoriesBtn = document.getElementById('categoriesBtn');

                const isCurrentlyVisible = categoryContainer.style.display !== 'none';
                const shouldShow = forceState !== null ? forceState : !isCurrentlyVisible;

                if (shouldShow) {
                    this.recategorizeAllArticles();

                    categoryContainer.style.display = 'block';
                    setTimeout(() => {
                        categoryContainer.classList.add('visible');
                    }, 10);

                    this.setActiveNavItem('categoriesBtn');
                    document.getElementById('pageTitle').textContent = 'Categories';

                    this.updateStatus('üè∑Ô∏è Category filter active - Click a category to filter articles', 'success');
                } else {
                    categoryContainer.classList.remove('visible');
                    setTimeout(() => {
                        if (!categoryContainer.classList.contains('visible')) {
                            categoryContainer.style.display = 'none';
                        }
                    }, 300);

                    if (this.activeCategory) {
                        this.showAllArticles();
                    }
                }
            }

            // ===== PKCE IMPLEMENTATION =====

            generateCodeVerifier() {
                const array = new Uint8Array(32);
                crypto.getRandomValues(array);
                return this.base64URLEncode(array);
            }

            async generateCodeChallenge(codeVerifier) {
                const encoder = new TextEncoder();
                const data = encoder.encode(codeVerifier);
                const digest = await crypto.subtle.digest('SHA-256', data);
                return this.base64URLEncode(new Uint8Array(digest));
            }

            base64URLEncode(array) {
                return btoa(String.fromCharCode.apply(null, array))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            }

            generateState() {
                const array = new Uint8Array(16);
                crypto.getRandomValues(array);
                return this.base64URLEncode(array);
            }

            storePKCEParameters(codeVerifier, state) {
                sessionStorage.setItem('mypocket_code_verifier', codeVerifier);
                sessionStorage.setItem('mypocket_state', state);
                console.log('üîê PKCE parameters stored securely');
            }

            retrievePKCEParameters() {
                const codeVerifier = sessionStorage.getItem('mypocket_code_verifier');
                const state = sessionStorage.getItem('mypocket_state');
                return { codeVerifier, state };
            }

            clearPKCEParameters() {
                sessionStorage.removeItem('mypocket_code_verifier');
                sessionStorage.removeItem('mypocket_state');
                console.log('üóëÔ∏è PKCE parameters cleared');
            }

            // ENHANCED: Secure authentication with PKCE
            async authenticate() {
                if (!this.redirectUri || (!this.redirectUri.startsWith('http://') && !this.redirectUri.startsWith('https://'))) {
                    this.updateStatus('‚ùå Invalid redirect URI. Please open this page via HTTP/HTTPS.', 'error');
                    console.error('üî¥ Invalid redirect URI:', this.redirectUri);
                    alert(`Redirect URI Error:\n\nCurrent URI: ${this.redirectUri}\n\nPlease:\n1. Open this page via HTTP/HTTPS (not file://)\n2. Register this exact URI in Azure AD\n3. Use a web server to serve this file`);
                    return;
                }

                try {
                    this.updateStatus('üîê Generating secure authentication parameters...', 'loading');

                    this.codeVerifier = this.generateCodeVerifier();
                    this.codeChallenge = await this.generateCodeChallenge(this.codeVerifier);
                    this.state = this.generateState();

                    this.storePKCEParameters(this.codeVerifier, this.state);

                    const authUrl = `https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize?` +
                        `client_id=${this.clientId}&` +
                        `response_type=code&` +
                        `redirect_uri=${encodeURIComponent(this.redirectUri)}&` +
                        `scope=${encodeURIComponent('Files.ReadWrite User.Read')}&` +
                        `state=${this.state}&` +
                        `code_challenge=${this.codeChallenge}&` +
                        `code_challenge_method=S256&` +
                        `response_mode=query`;

                    console.log('üîê PKCE Auth URL generated');
                    console.log('üîê Code Challenge:', this.codeChallenge.substring(0, 20) + '...');
                    console.log('üîê State:', this.state.substring(0, 20) + '...');

                    this.updateStatus('üîÑ Redirecting to secure Microsoft login...', 'loading');

                    setTimeout(() => {
                        window.location.href = authUrl;
                    }, 1000);

                } catch (error) {
                    console.error('PKCE generation error:', error);
                    this.updateStatus('‚ùå Error generating secure authentication. Please try again.', 'error');
                }
            }

            async checkAuthFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const state = urlParams.get('state');
                const error = urlParams.get('error');
                const errorDescription = urlParams.get('error_description');

                if (error) {
                    this.updateStatus(`‚ùå Authentication error: ${error} - ${errorDescription || 'Unknown error'}`, 'error');
                    this.clearPKCEParameters();
                    window.history.replaceState({}, document.title, window.location.pathname);
                    return;
                }

                if (code && state) {
                    try {
                        this.updateStatus('üîê Exchanging authorization code for tokens...', 'loading');

                        const { codeVerifier, state: storedState } = this.retrievePKCEParameters();

                        if (!storedState || state !== storedState) {
                            throw new Error('State parameter mismatch. Possible CSRF attack.');
                        }

                        if (!codeVerifier) {
                            throw new Error('Code verifier not found. Please try authenticating again.');
                        }

                        const tokenResponse = await this.exchangeCodeForTokens(code, codeVerifier);

                        if (tokenResponse.access_token) {
                            this.accessToken = tokenResponse.access_token;
                            this.saveToken(tokenResponse.access_token);

                            if (tokenResponse.refresh_token) {
                                this.saveRefreshToken(tokenResponse.refresh_token);
                            }

                            this.updateConnectionStatus(true);
                            this.loadArticles();

                            this.clearPKCEParameters();
                            window.history.replaceState({}, document.title, window.location.pathname);

                            this.updateStatus('‚úÖ Secure authentication successful!', 'success');
                        } else {
                            throw new Error('No access token received from authorization server');
                        }

                    } catch (error) {
                        console.error('Token exchange error:', error);
                        this.updateStatus(`‚ùå Token exchange failed: ${error.message}`, 'error');
                        this.clearPKCEParameters();
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }
                }
            }

            async exchangeCodeForTokens(authorizationCode, codeVerifier) {
                const tokenEndpoint = 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                const tokenRequest = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        client_id: this.clientId,
                        scope: 'Files.ReadWrite User.Read',
                        code: authorizationCode,
                        redirect_uri: this.redirectUri,
                        grant_type: 'authorization_code',
                        code_verifier: codeVerifier
                    })
                };

                console.log('üîê Exchanging authorization code for tokens...');

                const response = await fetch(tokenEndpoint, tokenRequest);

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Token exchange failed: ${errorData.error} - ${errorData.error_description}`);
                }

                const tokenData = await response.json();
                console.log('‚úÖ Token exchange successful');

                return tokenData;
            }

            saveToken(token) {
                localStorage.setItem('mypocket_access_token', token);
                localStorage.setItem('mypocket_token_timestamp', Date.now().toString());
            }

            saveRefreshToken(refreshToken) {
                localStorage.setItem('mypocket_refresh_token', refreshToken);
            }

            getRefreshToken() {
                return localStorage.getItem('mypocket_refresh_token');
            }

            clearTokens() {
                localStorage.removeItem('mypocket_access_token');
                localStorage.removeItem('mypocket_refresh_token');
                localStorage.removeItem('mypocket_token_timestamp');
                this.accessToken = null;
            }

            async ensureValidToken() {
                if (!this.accessToken) {
                    return false;
                }

                const tokenTimestamp = localStorage.getItem('mypocket_token_timestamp');
                if (tokenTimestamp) {
                    const tokenAge = Date.now() - parseInt(tokenTimestamp);
                    const oneHour = 60 * 60 * 1000;

                    if (tokenAge > oneHour) {
                        console.log('üîÑ Token expired, attempting refresh...');
                        const refreshSuccess = await this.refreshAccessToken();
                        if (!refreshSuccess) {
                            console.log('‚ùå Token refresh failed, need to re-authenticate');
                            return false;
                        }
                    }
                }

                return true;
            }

            async refreshAccessToken() {
                const refreshToken = this.getRefreshToken();
                if (!refreshToken) {
                    console.log('No refresh token available');
                    return false;
                }

                try {
                    const tokenEndpoint = 'https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                    const refreshRequest = {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: this.clientId,
                            scope: 'Files.ReadWrite User.Read',
                            refresh_token: refreshToken,
                            grant_type: 'refresh_token'
                        })
                    };

                    const response = await fetch(tokenEndpoint, refreshRequest);

                    if (!response.ok) {
                        console.log('Refresh token request failed');
                        return false;
                    }

                    const tokenData = await response.json();

                    if (tokenData.access_token) {
                        this.accessToken = tokenData.access_token;
                        this.saveToken(tokenData.access_token);

                        if (tokenData.refresh_token) {
                            this.saveRefreshToken(tokenData.refresh_token);
                        }

                        console.log('‚úÖ Token refreshed successfully');
                        return true;
                    }

                    return false;

                } catch (error) {
                    console.error('Token refresh error:', error);
                    return false;
                }
            }

            loadStoredToken() {
                this.accessToken = localStorage.getItem('mypocket_access_token');
                if (this.accessToken) {
                    this.updateConnectionStatus(true);
                    this.ensureValidToken().then(isValid => {
                        if (isValid) {
                            this.loadArticles();
                        } else {
                            this.updateConnectionStatus(false);
                            this.updateStatus('Stored token expired. Please reconnect.', 'error');
                        }
                    });
                }
            }

            updateConnectionStatus(connected) {
                const connectionStatus = document.getElementById('connectionStatus');
                const connectBtn = document.getElementById('connectBtn');
                const refreshBtn = document.getElementById('refreshBtn');
                const syncBtn = document.getElementById('syncBtn');
                const retryFailedBtn = document.getElementById('retryFailedBtn');

                if (connected) {
                    connectionStatus.innerHTML = '<span>‚úÖ</span><span>Connected to OneDrive</span>';
                    connectBtn.innerHTML = '<span class="icon">‚úÖ</span><span class="label">Connected to OneDrive</span>';
                    
                    if (refreshBtn) refreshBtn.style.display = 'block';
                    if (syncBtn) syncBtn.style.display = 'block';
                    if (retryFailedBtn) retryFailedBtn.style.display = 'block';
                } else {
                    connectionStatus.innerHTML = '<span>üîê</span><span>Secure Connect Required</span>';
                    connectBtn.innerHTML = '<span class="icon">‚òÅÔ∏è</span><span class="label">Connect to OneDrive</span>';
                    
                    if (refreshBtn) refreshBtn.style.display = 'none';
                    if (syncBtn) syncBtn.style.display = 'none';
                    if (retryFailedBtn) retryFailedBtn.style.display = 'none';
                }
            }

            showAllArticles() {
                this.activeCategory = null;
                this.currentDisplayedArticles = this.articles;
                this.displayArticles(this.articles);
                
                this.setActiveNavItem('allArticlesBtn');
                document.getElementById('pageTitle').textContent = 'All Articles';
                
                this.toggleCategoryFilter(false);
                
                this.updateStatus(`Showing all ${this.articles.length} articles`, 'success');
            }

            toggleMobileMenu() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('mobileOverlay');
                const isOpen = sidebar.classList.contains('mobile-open');
                
                if (isOpen) {
                    sidebar.classList.remove('mobile-open');
                    overlay.classList.remove('active');
                } else {
                    sidebar.classList.add('mobile-open');
                    overlay.classList.add('active');
                }
            }

            setActiveNavItem(activeId) {
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                const activeItem = document.getElementById(activeId);
                if (activeItem) {
                    activeItem.classList.add('active');
                }
            }

            updateSidebarCounts() {
                const allCount = document.getElementById('allArticleCount');
                const categoryCountElement = document.getElementById('categoryCount');
                
                if (allCount) {
                    allCount.textContent = this.articles.length;
                }
                
                if (categoryCountElement) {
                    const totalCategories = this.categories.size + this.dynamicCategories.size;
                    categoryCountElement.textContent = totalCategories;
                }
            }

            toggleSearch(forceState = null) {
                const searchContainer = document.getElementById('searchContainer');
                const searchInput = document.getElementById('searchInput');
                const searchToggleBtn = document.getElementById('searchToggleBtn');

                const isCurrentlyVisible = searchContainer.style.display !== 'none';
                const shouldShow = forceState !== null ? forceState : !isCurrentlyVisible;

                if (shouldShow) {
                    searchContainer.style.display = 'block';
                    setTimeout(() => {
                        searchContainer.classList.add('visible');
                        searchInput.focus();
                    }, 10);

                    this.setActiveNavItem('searchToggleBtn');
                    document.getElementById('pageTitle').textContent = 'Search Articles';

                    this.updateStatus('üîç Search mode active - Type to search or press Escape to close', 'success');
                } else {
                    searchContainer.classList.remove('visible');
                    setTimeout(() => {
                        if (!searchContainer.classList.contains('visible')) {
                            searchContainer.style.display = 'none';
                        }
                    }, 300);

                    if (searchInput.value) {
                        searchInput.value = '';
                        this.searchArticles('');
                    }

                    this.showAllArticles();
                    searchInput.blur();
                }
            }

            getArticleContentForAnalysis(article) {
                const contentFields = ['content', 'textContent', 'excerpt', 'description', 'summary'];

                for (const field of contentFields) {
                    if (article[field] && typeof article[field] === 'string' && article[field].length > 10) {
                        return article[field];
                    }
                }

                return article.title || '';
            }

            async refreshSingleImage(originalIndex, displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                const imageElement = document.getElementById(`image-${originalIndex}`);
                if (!imageElement) {
                    console.error('Image element not found for index:', originalIndex);
                    return;
                }

                const proceed = confirm(`Refresh image for "${article.title.substring(0, 50)}..."?\n\nThis will:\n‚Ä¢ Clear the current image\n‚Ä¢ Try to find a better image from the original source\n‚Ä¢ Use alternative sources if needed\n\nProceed?`);

                if (!proceed) return;

                console.log(`üîÑ Refreshing single image for: ${article.title.substring(0, 30)}...`);

                const cacheIndicator = imageElement.querySelector('.cache-indicator');
                if (cacheIndicator) {
                    cacheIndicator.textContent = 'üîÑ Refreshing...';
                    cacheIndicator.className = 'cache-indicator loading';
                }

                imageElement.innerHTML = `
                    ${this.createPlaceholderHTML()}
                    <div class="cache-indicator loading">
                        üîÑ Refreshing...
                    </div>
                `;

                try {
                    const cacheKey = this.getCacheKey(article);
                    this.imageCache.delete(cacheKey);

                    const mainArticleIndex = this.articles.findIndex(a =>
                        a.url === article.url && a.title === article.title
                    );
                    if (mainArticleIndex !== -1 && this.articles[mainArticleIndex].cachedImage) {
                        delete this.articles[mainArticleIndex].cachedImage;
                    }

                    let success = false;

                    try {
                        console.log(`üåê Attempting fresh extraction from: ${this.getDomain(article.url)}`);
                        const extractedImage = await this.fetchRealImageFromWebsite(article.url);
                        if (extractedImage) {
                            console.log(`‚úÖ Fresh extraction successful: ${article.title.substring(0, 30)}...`);
                            await this.setArticleImageAndCache(article, originalIndex, extractedImage, 'refreshed');
                            success = true;
                        }
                    } catch (error) {
                        console.log(`‚ö†Ô∏è Fresh extraction failed: ${error.message}`);
                    }

                    if (!success) {
                        try {
                            console.log(`üîÑ Trying alternative methods...`);
                            success = await this.tryAlternativeImageStrategies(article, originalIndex);
                        } catch (error) {
                            console.log(`‚ö†Ô∏è Alternative methods failed: ${error.message}`);
                        }
                    }

                    if (!success) {
                        console.log(`üé® Using refreshed category image...`);
                        const fallbackImage = this.getCategoryBasedImage(article, originalIndex + Date.now());
                        await this.setArticleImageAndCache(article, originalIndex, fallbackImage, 'refreshed');
                        success = true;
                    }

                    if (success) {
                        this.updateStatus(`‚úÖ Image refreshed successfully for "${article.title.substring(0, 40)}..."`, 'success');

                        if (this.accessToken) {
                            try {
                                await this.updateOneDriveBackup();
                                console.log('‚úÖ Updated backup with refreshed image');
                            } catch (error) {
                                console.error('‚ö†Ô∏è Failed to update backup:', error);
                            }
                        }
                    } else {
                        throw new Error('All refresh strategies failed');
                    }

                } catch (error) {
                    console.error('Single image refresh error:', error);
                    this.updateStatus(`‚ùå Failed to refresh image: ${error.message}`, 'error');

                    const errorCacheIndicator = imageElement.querySelector('.cache-indicator');
                    if (errorCacheIndicator) {
                        errorCacheIndicator.textContent = '‚ùå Refresh Failed';
                        errorCacheIndicator.className = 'cache-indicator error';
                    }
                }
            }

            async retryFailedImages() {
                if (!this.accessToken) {
                    this.updateStatus('‚ùå Please connect to OneDrive first', 'error');
                    return;
                }

                const articlesWithFailedImages = this.articles.filter((article, index) => {
                    const isExplicitlyFailed = this.failedImages.has(index);

                    const imageElement = document.getElementById(`image-${index}`);
                    const cacheIndicator = imageElement?.querySelector('.cache-indicator');
                    const hasFailedIndicator = cacheIndicator && cacheIndicator.textContent.includes('‚ùå Failed');

                    return isExplicitlyFailed || hasFailedIndicator;
                });

                if (articlesWithFailedImages.length === 0) {
                    this.updateStatus('‚úÖ No explicitly failed images found. Use "Sync Images" for broader updates.', 'success');
                    return;
                }

                const proceed = confirm(`Retry ${articlesWithFailedImages.length} explicitly failed images?\n\nThis will ONLY affect images marked with "‚ùå Failed" status.\nWorking images will NOT be touched.\n\nProceed?`);

                if (!proceed) {
                    this.updateStatus('Retry cancelled by user', 'error');
                    return;
                }

                this.updateStatus(`üîÑ Retrying ONLY ${articlesWithFailedImages.length} explicitly failed images...`, 'loading');

                let retriedCount = 0;
                let successCount = 0;

                for (const article of articlesWithFailedImages) {
                    const originalIndex = this.articles.findIndex(a => a === article);
                    if (originalIndex === -1) continue;

                    try {
                        retriedCount++;
                        console.log(`üîÑ Retrying FAILED image ${retriedCount}/${articlesWithFailedImages.length}: ${article.title.substring(0, 30)}...`);

                        this.failedImages.delete(originalIndex);

                        const success = await this.tryAlternativeImageStrategies(article, originalIndex);
                        if (success) {
                            successCount++;
                            console.log(`‚úÖ Successfully recovered image: ${article.title.substring(0, 30)}...`);
                        }

                        this.updateStatus(`üîÑ Retrying failed images... ${retriedCount}/${articlesWithFailedImages.length} (${successCount} recovered)`, 'loading');

                        await new Promise(resolve => setTimeout(resolve, 300));

                    } catch (error) {
                        console.error(`Failed to retry image for ${article.title}:`, error);
                        this.failedImages.add(originalIndex);
                    }
                }

                const message = successCount > 0
                    ? `‚úÖ Retry complete! Recovered ${successCount}/${articlesWithFailedImages.length} failed images. Working images were untouched.`
                    : `‚ö†Ô∏è Could not recover the failed images - they may be permanently unavailable.`;

                this.updateStatus(message, successCount > 0 ? 'success' : 'error');

                if (successCount > 0 && this.accessToken) {
                    try {
                        await this.updateOneDriveBackup();
                        console.log('‚úÖ OneDrive backup updated with recovered images');
                    } catch (error) {
                        console.error('‚ö†Ô∏è Failed to save recovered images to backup:', error);
                    }
                }
            }

            showImageHelp() {
                const helpText = `
MyPocket AI Reader - Image System Help:
======================================

üñºÔ∏è IMAGE STATUS INDICATORS:
‚Ä¢ üåê Synced - Stored across all devices
‚Ä¢ üíæ Cached - Stored locally on this device  
‚Ä¢ üîÑ Refreshed - Recently updated image
‚Ä¢ ‚ùå Failed - Could not load image

üîß AVAILABLE ACTIONS:

1Ô∏è‚É£ INDIVIDUAL IMAGE REFRESH (üñºÔ∏è button):
   ‚Ä¢ Use when an image loaded but shows wrong content
   ‚Ä¢ Click the üñºÔ∏è button on any article card
   ‚Ä¢ Tries to find the correct image for that article
   ‚Ä¢ Works even if current image appears "successful"

2Ô∏è‚É£ RETRY FAILED IMAGES (Retry Failed button):
   ‚Ä¢ Only processes images marked "‚ùå Failed"
   ‚Ä¢ Leaves working images untouched
   ‚Ä¢ Appears when connected to OneDrive

3Ô∏è‚É£ SYNC ALL IMAGES (Sync Images button):
   ‚Ä¢ Forces refresh of ALL images
   ‚Ä¢ Stores images for cross-device access
   ‚Ä¢ Use for complete refresh

ü§ñ AI CATEGORIZATION FEATURES:
‚Ä¢ Intelligent content analysis with keyword extraction
‚Ä¢ Dynamic category discovery from your articles
‚Ä¢ Confidence scoring (high/medium/low)
‚Ä¢ 12+ predefined categories + AI-discovered categories
‚Ä¢ Categories marked with üî• are AI-discovered
‚Ä¢ Click categories to filter articles

üéØ WHEN TO USE EACH:

Wrong but Working Image ‚Üí Use üñºÔ∏è (Individual Refresh)
Red "‚ùå Failed" Status ‚Üí Use "Retry Failed" button  
Want All Fresh Images ‚Üí Use "Sync Images" button

üí° TIP: The üñºÔ∏è button appears when you hover over article cards (or always visible on mobile). Perfect for fixing individual wrong images!

üß† AI CATEGORIZATION TIP: Categories are automatically discovered from your content. The more articles you have, the smarter the categorization becomes!
                `;

                alert(helpText);
            }

            async tryAlternativeImageStrategies(article, index) {
                console.log(`üéØ Trying alternative strategies for: ${article.title.substring(0, 30)}...`);

                try {
                    const extractedImage = await this.tryAlternativeProxies(article.url);
                    if (extractedImage) {
                        console.log(`‚úÖ Recovered via alternative proxy: ${article.title.substring(0, 30)}...`);
                        this.setArticleImageAndCache(article, index, extractedImage, 'extracted');
                        return true;
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è Alternative proxy failed: ${error.message}`);
                }

                try {
                    const searchBasedImage = await this.getImageFromTitleKeywords(article);
                    if (searchBasedImage) {
                        console.log(`‚úÖ Found via title search: ${article.title.substring(0, 30)}...`);
                        this.setArticleImageAndCache(article, index, searchBasedImage, 'search');
                        return true;
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è Title search failed: ${error.message}`);
                }

                try {
                    const domainImage = this.getDomainSpecificImage(article);
                    if (domainImage) {
                        console.log(`‚úÖ Using domain-specific image: ${article.title.substring(0, 30)}...`);
                        this.setArticleImageAndCache(article, index, domainImage, 'domain');
                        return true;
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è Domain-specific image failed: ${error.message}`);
                }

                console.log(`üé® Using enhanced fallback for: ${article.title.substring(0, 30)}...`);
                const fallbackImage = this.getCategoryBasedImage(article, index);
                this.setArticleImageAndCache(article, index, fallbackImage, 'fallback');

                const imageElement = document.getElementById(`image-${index}`);
                const cacheIndicator = imageElement?.querySelector('.cache-indicator');
                if (cacheIndicator) {
                    cacheIndicator.textContent = 'üé® Enhanced';
                    cacheIndicator.className = 'cache-indicator fallback';
                }

                return true;
            }

            async tryAlternativeProxies(url) {
                const proxies = [
                    `https://corsproxy.io/?${encodeURIComponent(url)}`,
                    `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
                    `https://thingproxy.freeboard.io/fetch/${encodeURIComponent(url)}`
                ];

                for (const proxyUrl of proxies) {
                    try {
                        console.log(`Trying proxy: ${proxyUrl.substring(0, 50)}...`);
                        const response = await fetch(proxyUrl);

                        if (response.ok) {
                            const html = await response.text();
                            if (html && html.length > 1000) {
                                const extractedImage = this.parseHTMLForBestImage(html, url);
                                if (extractedImage) {
                                    return extractedImage;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`Proxy failed: ${error.message}`);
                        continue;
                    }
                }

                return null;
            }

            async getImageFromTitleKeywords(article) {
                const title = article.title.toLowerCase();
                const commonWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'how', 'what', 'why', 'when', 'where'];
                const keywords = title
                    .split(/[^\w]+/)
                    .filter(word => word.length > 3 && !commonWords.includes(word))
                    .slice(0, 3)
                    .join(' ');

                if (!keywords) return null;

                try {
                    if (keywords.includes('tech') || keywords.includes('code') || keywords.includes('software')) {
                        return 'https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                    }
                    if (keywords.includes('business') || keywords.includes('work') || keywords.includes('office')) {
                        return 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                    }
                    if (keywords.includes('design') || keywords.includes('art') || keywords.includes('creative')) {
                        return 'https://images.unsplash.com/photo-1561070791-2526d30994b5?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                    }

                    return 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                } catch (error) {
                    console.log(`Keyword-based search failed: ${error.message}`);
                    return null;
                }
            }

            getDomainSpecificImage(article) {
                const domain = this.getDomain(article.url).toLowerCase();

                const siteDefaults = {
                    'github.com': 'https://images.unsplash.com/photo-1618401471353-b98afee0b2eb?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'medium.com': 'https://images.unsplash.com/photo-1481627834876-b7833e8f5570?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'youtube.com': 'https://images.unsplash.com/photo-1611162617474-5b21e879e113?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'stackoverflow.com': 'https://images.unsplash.com/photo-1516116216624-53e697fedbea?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'dev.to': 'https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'reddit.com': 'https://images.unsplash.com/photo-1611224923853-80b023f02d71?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'news': 'https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'blog': 'https://images.unsplash.com/photo-1486312338219-ce68e2c6b9d6?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                };

                for (const [siteDomain, image] of Object.entries(siteDefaults)) {
                    if (domain.includes(siteDomain)) {
                        return image;
                    }
                }

                return null;
            }

            async forceSyncImages() {
                if (!this.accessToken) {
                    this.updateStatus('‚ùå Please connect to OneDrive first', 'error');
                    return;
                }

                this.updateStatus('üîÑ Force syncing all images to OneDrive...', 'loading');

                try {
                    let syncedCount = 0;
                    const totalArticles = this.articles.length;

                    for (let i = 0; i < this.articles.length; i++) {
                        const article = this.articles[i];

                        if (!article.cachedImage) {
                            let imageUrl = this.getCachedImage(article);

                            if (!imageUrl) {
                                imageUrl = this.getBestArticleImage(article);
                            }

                            if (!imageUrl) {
                                imageUrl = this.getCategoryBasedImage(article, i);
                            }

                            if (imageUrl) {
                                try {
                                    const imageData = await this.convertImageToBase64(imageUrl);
                                    if (imageData.stored) {
                                        article.cachedImage = {
                                            base64: imageData.base64,
                                            url: imageData.url,
                                            timestamp: Date.now(),
                                            size: imageData.size,
                                            source: 'force_sync'
                                        };
                                        syncedCount++;
                                    }
                                } catch (error) {
                                    console.error(`Failed to sync image for ${article.title}:`, error);
                                }
                            }
                        } else {
                            syncedCount++;
                        }

                        if (i % 5 === 0) {
                            this.updateStatus(`üîÑ Syncing images... ${i + 1}/${totalArticles}`, 'loading');
                        }
                    }

                    await this.updateOneDriveBackup();

                    this.updateStatus(`‚úÖ Force sync complete! ${syncedCount}/${totalArticles} images synced to OneDrive`, 'success');

                    this.displayArticles(this.articles);

                } catch (error) {
                    console.error('Force sync error:', error);
                    this.updateStatus(`‚ùå Force sync failed: ${error.message}`, 'error');
                }
            }

            updateStatus(message, type = '') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = `status ${type}`;
            }

            // ===== IMAGE CACHE SYSTEM =====

            loadImageCache() {
                try {
                    const cachedData = localStorage.getItem(this.cacheKey);
                    if (cachedData) {
                        const cache = JSON.parse(cachedData);

                        const now = Date.now();
                        const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                        for (const [key, entry] of Object.entries(cache)) {
                            if (now - entry.timestamp < expiryTime) {
                                this.imageCache.set(key, entry);
                            }
                        }

                        console.log(`üì¶ Loaded ${this.imageCache.size} cached images`);
                    }
                } catch (error) {
                    console.error('Error loading image cache:', error);
                    this.imageCache.clear();
                }
            }

            saveImageCache() {
                try {
                    const cacheObject = {};
                    for (const [key, value] of this.imageCache.entries()) {
                        cacheObject[key] = value;
                    }
                    localStorage.setItem(this.cacheKey, JSON.stringify(cacheObject));
                    console.log(`üíæ Saved ${this.imageCache.size} images to cache`);
                } catch (error) {
                    console.error('Error saving image cache:', error);
                }
            }

            getCacheKey(article) {
                return `${this.getDomain(article.url)}_${article.url.substring(article.url.length - 20)}_${article.title.substring(0, 30)}`.replace(/[^a-zA-Z0-9]/g, '_');
            }

            getCachedImage(article) {
                const key = this.getCacheKey(article);
                const cached = this.imageCache.get(key);

                if (cached) {
                    const now = Date.now();
                    const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                    if (now - cached.timestamp < expiryTime) {
                        console.log(`‚úÖ Using cached image for: ${article.title.substring(0, 30)}...`);
                        return cached.imageUrl;
                    } else {
                        this.imageCache.delete(key);
                        console.log(`‚è∞ Cache expired for: ${article.title.substring(0, 30)}...`);
                    }
                }

                return null;
            }

            setCachedImage(article, imageUrl) {
                const key = this.getCacheKey(article);
                this.imageCache.set(key, {
                    imageUrl: imageUrl,
                    timestamp: Date.now(),
                    domain: this.getDomain(article.url),
                    title: article.title.substring(0, 50)
                });

                clearTimeout(this.cacheSaveTimeout);
                this.cacheSaveTimeout = setTimeout(() => this.saveImageCache(), 1000);

                console.log(`üíæ Cached image for: ${article.title.substring(0, 30)}...`);
            }

            clearImageCache() {
                if (confirm('Clear all cached images?\n\nThis will:\n- Clear local cache\n- Remove stored images from articles\n- Force re-downloading images next time')) {
                    this.imageCache.clear();
                    localStorage.removeItem(this.cacheKey);

                    this.articles.forEach(article => {
                        if (article.cachedImage) {
                            delete article.cachedImage;
                        }
                    });

                    this.updateStatus('üóëÔ∏è All image data cleared. Images will be re-downloaded and stored for cross-device access.', 'success');
                    console.log('üóëÔ∏è All image data cleared');

                    this.displayArticles(this.articles);
                }
            }

            getCacheStats() {
                const timestamps = Array.from(this.imageCache.values()).map(entry => entry.timestamp);
                return {
                    total: this.imageCache.size,
                    memoryUsage: JSON.stringify(Object.fromEntries(this.imageCache)).length,
                    oldestEntry: timestamps.length > 0 ? Math.min(...timestamps) : null,
                    newestEntry: timestamps.length > 0 ? Math.max(...timestamps) : null
                };
            }

            // ===== CROSS-DEVICE IMAGE STORAGE =====

            async convertImageToBase64(imageUrl) {
                try {
                    console.log(`üì∏ Converting image to base64: ${imageUrl.substring(0, 50)}...`);

                    const img = new Image();
                    img.crossOrigin = 'anonymous';

                    return new Promise((resolve, reject) => {
                        img.onload = () => {
                            try {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');

                                const maxWidth = 400;
                                const maxHeight = 250;

                                let { width, height } = img;

                                if (width > maxWidth) {
                                    height = (height * maxWidth) / width;
                                    width = maxWidth;
                                }
                                if (height > maxHeight) {
                                    width = (width * maxHeight) / height;
                                    height = maxHeight;
                                }

                                canvas.width = width;
                                canvas.height = height;

                                ctx.drawImage(img, 0, 0, width, height);
                                const base64 = canvas.toDataURL('image/jpeg', 0.8);

                                const sizeKB = Math.round(base64.length * 0.75 / 1024);

                                if (sizeKB > this.maxImageSizeKB) {
                                    console.log(`‚ö†Ô∏è Image too large (${sizeKB}KB), using URL only`);
                                    resolve({ url: imageUrl, size: sizeKB, stored: false });
                                } else {
                                    console.log(`‚úÖ Image converted (${sizeKB}KB): ${imageUrl.substring(0, 30)}...`);
                                    resolve({ base64: base64, url: imageUrl, size: sizeKB, stored: true });
                                }
                            } catch (error) {
                                console.log(`‚ùå Canvas conversion failed: ${error.message}`);
                                resolve({ url: imageUrl, stored: false });
                            }
                        };

                        img.onerror = () => {
                            console.log(`‚ùå Image load failed: ${imageUrl}`);
                            resolve({ url: imageUrl, stored: false });
                        };

                        img.src = imageUrl;
                    });
                } catch (error) {
                    console.error('Image conversion error:', error);
                    return { url: imageUrl, stored: false };
                }
            }

            // ENHANCED: More aggressive synced image prioritization
            displayArticles(articles) {
                const container = document.getElementById('articlesContainer');

                if (articles.length === 0) {
                    this.displayEmptyState();
                    return;
                }

                this.currentDisplayedArticles = articles;

                const isMobile = window.innerWidth <= 768;

                let imagesFromBackup = 0;
                let imagesFromCache = 0;
                let imagesNeedLoading = 0;

                console.log('üéØ DISPLAYING ARTICLES - Image Source Priority Check:');

                const articlesHTML = articles.map((article, displayIndex) => {
                    const index = displayIndex;

                    let imageHTML = '';
                    let cacheStatus = 'loading';
                    let statusText = 'üîÑ Loading';
                    let imageSource = 'none';

                    // PRIORITY 1: Synced base64 images
                    if (article.cachedImage && article.cachedImage.base64) {
                        imageHTML = this.createImageHTML(article.cachedImage.base64, true);
                        cacheStatus = 'synced';
                        statusText = 'üåê Synced';
                        imageSource = 'synced_base64';
                        imagesFromBackup++;
                        console.log(`‚úÖ ${displayIndex}: Using SYNCED base64 for "${article.title.substring(0, 30)}..." (${Math.round(article.cachedImage.size)}KB)`);
                    }
                    // PRIORITY 2: Synced URLs
                    else if (article.cachedImage && article.cachedImage.url && !article.cachedImage.base64) {
                        imageHTML = this.createImageHTML(article.cachedImage.url, true);
                        cacheStatus = 'synced';
                        statusText = 'üîó Synced URL';
                        imageSource = 'synced_url';
                        imagesFromBackup++;
                        console.log(`‚úÖ ${displayIndex}: Using SYNCED URL for "${article.title.substring(0, 30)}..."`);
                    }
                    // PRIORITY 3: Local cache
                    else if (this.getCachedImage(article)) {
                        imageHTML = this.createImageHTML(this.getCachedImage(article), true);
                        cacheStatus = 'cached';
                        statusText = 'üíæ Local Cache';
                        imageSource = 'local_cache';
                        imagesFromCache++;
                        console.log(`‚ö° ${displayIndex}: Using LOCAL cache for "${article.title.substring(0, 30)}..."`);
                    }
                    // PRIORITY 4: Article metadata
                    else if (this.getBestArticleImage(article)) {
                        const savedImage = this.getBestArticleImage(article);
                        imageHTML = this.createImageHTML(savedImage, false);
                        cacheStatus = 'metadata';
                        statusText = 'üìÑ Metadata';
                        imageSource = 'metadata';
                        console.log(`üìÑ ${displayIndex}: Using METADATA image for "${article.title.substring(0, 30)}..." - will sync`);

                        setTimeout(() => this.setArticleImageAndCache(article, index, savedImage, 'saved'), 100);
                    }
                    // PRIORITY 5: Need to extract from website
                    else {
                        imageHTML = this.createPlaceholderHTML();
                        cacheStatus = 'loading';
                        statusText = isMobile ? 'üì± Loading...' : 'üîÑ Loading';
                        imageSource = 'needs_extraction';
                        imagesNeedLoading++;
                        console.log(`‚ùå ${displayIndex}: NO image found for "${article.title.substring(0, 30)}..." - needs extraction`);
                    }

                    return `
                    <div class="article-card" data-index="${index}" data-display-index="${displayIndex}" data-image-source="${imageSource}">
                        <div class="article-image" id="image-${index}">
                            ${imageHTML}
                            <div class="cache-indicator ${cacheStatus}">
                                ${statusText}
                            </div>
                        </div>
                        <div class="article-content" onclick="webReader.openReaderByDisplayIndex(${displayIndex})">
                            <h2 class="article-title">${this.escapeHtml(article.title)}</h2>
                            <p class="article-excerpt">${this.escapeHtml(article.excerpt)}</p>
                            <div class="article-meta">
                                <span class="article-domain">üåê ${this.getDomain(article.url)}</span>
                                <span class="article-date">üìÖ ${this.formatDate(article.dateAdded)}</span>
                            </div>
                            <div class="article-stats">
                                <span>‚è±Ô∏è ${article.readTime || 1} min read</span>
                                <span>üìù ${article.wordCount || 0} words</span>
                            </div>
                        </div>
                        <div class="article-actions">
                            <button class="action-btn read-btn" onclick="event.stopPropagation(); webReader.openReaderByDisplayIndex(${displayIndex})" title="Read article">
                                üìñ
                            </button>
                            <button class="action-btn refresh-image-btn" onclick="event.stopPropagation(); webReader.refreshSingleImage(${index}, ${displayIndex})" title="Refresh this image">
                                üñºÔ∏è
                            </button>
                            <button class="action-btn export-btn" onclick="event.stopPropagation(); webReader.exportArticleByDisplayIndex(${displayIndex})" title="Export article">
                                üì§
                            </button>
                            <button class="action-btn delete-btn" onclick="event.stopPropagation(); webReader.deleteArticleByDisplayIndex(${displayIndex})" title="Delete article">
                                üóëÔ∏è
                            </button>
                        </div>
                    </div>
                `}).join('');

                container.innerHTML = `<div class="articles-grid">${articlesHTML}</div>`;

                const totalReady = imagesFromBackup + imagesFromCache;

                console.log(`üìä IMAGE SUMMARY: ${imagesFromBackup} synced, ${imagesFromCache} cached, ${imagesNeedLoading} need loading`);

                if (imagesNeedLoading === 0) {
                    const message = isMobile ?
                        `üì± ALL images ready! ${totalReady}/${articles.length} synced perfectly ‚ú®` :
                        `‚úÖ ALL images ready! ${imagesFromBackup} synced, ${imagesFromCache} cached ‚ú®`;
                    this.updateStatus(message, 'success');
                } else {
                    const message = isMobile ?
                        `üì± ${totalReady} ready instantly, extracting ${imagesNeedLoading} more...` :
                        `‚ö° ${totalReady} ready instantly, extracting ${imagesNeedLoading} more...`;
                    this.updateStatus(message, 'loading');

                    if (isMobile) {
                        setTimeout(() => this.loadMissingImages(articles), 500);
                    } else {
                        this.loadMissingImages(articles);
                    }
                }
            }

            createImageHTML(imageUrl, fromCache = false) {
                return `
                    <img src="${imageUrl}" 
                         alt="Article image" 
                         style="
                            opacity: 0; 
                            transition: opacity 0.8s ease;
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: inherit;
                         "
                         onload="
                            this.style.opacity='1';
                            console.log('‚úÖ Image loaded ${fromCache ? 'from cache' : 'successfully'}');
                         " 
                         onerror="
                            console.log('‚ö†Ô∏è Image failed, tracking for retry');
                            const cardElement = this.closest('.article-card');
                            if (cardElement) {
                                const index = parseInt(cardElement.dataset.index);
                                if (!isNaN(index)) {
                                    webReader.failedImages.add(index);
                                    const indicator = this.parentElement.querySelector('.cache-indicator');
                                    if (indicator) {
                                        indicator.textContent = '‚ùå Failed';
                                        indicator.className = 'cache-indicator error';
                                    }
                                }
                            }
                            this.src='https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                         ">
                `;
            }

            createPlaceholderHTML() {
                return `
                    <div style="
                        width: 100%; 
                        height: 100%; 
                        background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%), 
                                   linear-gradient(-45deg, #f0f0f0 25%, transparent 25%), 
                                   linear-gradient(45deg, transparent 75%, #f0f0f0 75%), 
                                   linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
                        background-size: 20px 20px;
                        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: #999;
                        animation: shimmer 1.5s ease-in-out infinite;
                    ">
                        <div style="text-align: center;">
                            <div style="font-size: 1.2em; margin-bottom: 5px;">üñºÔ∏è</div>
                            <div style="font-size: 0.7em;">Loading image...</div>
                        </div>
                    </div>
                `;
            }

            async loadMissingImages(articles) {
                console.log('üé® SMART IMAGE LOADER - Loading same images for all devices...');

                const articlesNeedingImages = articles.filter((article, index) => {
                    const hasStoredImage = article.cachedImage && article.cachedImage.base64;
                    const hasCachedImage = this.getCachedImage(article);
                    return !hasStoredImage && !hasCachedImage;
                });

                if (articlesNeedingImages.length === 0) {
                    this.updateStatus(`‚úÖ All images loaded!`, 'success');
                    return;
                }

                const isMobile = window.innerWidth <= 768;
                let successCount = 0;
                const totalNew = articlesNeedingImages.length;

                console.log(`üîÑ Loading ${totalNew} SAME images${isMobile ? ' (mobile optimized)' : ''}`);

                const batchSize = isMobile ? 2 : 5;
                const delayBetweenImages = isMobile ? 800 : 300;

                for (let i = 0; i < articlesNeedingImages.length; i += batchSize) {
                    const batch = articlesNeedingImages.slice(i, i + batchSize);

                    await Promise.all(batch.map(async (article) => {
                        const originalIndex = articles.findIndex(a => a === article);

                        try {
                            const success = await this.extractAndCacheRealImage(article, originalIndex);
                            if (success) successCount++;
                        } catch (error) {
                            console.error(`Failed to extract image for article ${originalIndex}:`, error);
                            const fallbackImage = this.getCategoryBasedImage(article, originalIndex);
                            this.setArticleImageAndCache(article, originalIndex, fallbackImage, 'fallback');
                            successCount++;
                        }
                    }));

                    const progress = Math.round(((i + batchSize) / totalNew) * 100);
                    if (isMobile) {
                        this.updateStatus(`üì± Loading images... ${Math.min(i + batchSize, totalNew)}/${totalNew}`, 'loading');
                    } else {
                        this.updateStatus(`üîç Loading new images... ${Math.min(i + batchSize, totalNew)}/${totalNew} (${progress}%)`, 'loading');
                    }

                    if (i + batchSize < articlesNeedingImages.length) {
                        await new Promise(resolve => setTimeout(resolve, delayBetweenImages));
                    }
                }

                const totalCached = this.imageCache.size;

                if (isMobile) {
                    this.updateStatus(`üì± ${successCount} images loaded! Same as desktop üéâ`, 'success');
                } else {
                    this.updateStatus(`‚úÖ Loaded ${successCount}/${totalNew} new images! (${totalCached} total cached)`, 'success');
                }

                console.log(`üé® Image loading complete: ${successCount}/${totalNew} SAME images on both platforms`);
            }

            async setArticleImageAndCache(article, index, imageUrl, source) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return;

                imageElement.innerHTML = this.createImageHTML(imageUrl, false);

                const cacheIndicator = imageElement.querySelector('.cache-indicator');
                if (cacheIndicator) {
                    if (source === 'extracted') {
                        cacheIndicator.textContent = 'üåê Fresh';
                        cacheIndicator.className = 'cache-indicator fresh';
                    } else if (source === 'refreshed') {
                        cacheIndicator.textContent = 'üîÑ Refreshed';
                        cacheIndicator.className = 'cache-indicator fresh';
                    } else {
                        cacheIndicator.textContent = 'üíæ Cached';
                        cacheIndicator.className = 'cache-indicator cached';
                    }
                }

                this.setCachedImage(article, imageUrl);

                if (this.storeImagesInBackup && (source === 'extracted' || source === 'saved' || source === 'fallback' || source === 'refreshed')) {
                    try {
                        console.log(`üîÑ Converting image for cross-device storage: ${article.title.substring(0, 30)}...`);
                        const imageData = await this.convertImageToBase64(imageUrl);

                        if (imageData.stored) {
                            const articleIndex = this.articles.findIndex(a => a.url === article.url);
                            if (articleIndex !== -1) {
                                this.articles[articleIndex].cachedImage = {
                                    base64: imageData.base64,
                                    url: imageData.url,
                                    timestamp: Date.now(),
                                    size: imageData.size,
                                    source: source
                                };

                                console.log(`üíæ Stored ${imageData.size}KB image in backup for cross-device sync`);

                                if (cacheIndicator) {
                                    cacheIndicator.textContent = 'üåê Synced';
                                    cacheIndicator.className = 'cache-indicator synced';
                                }

                                if (this.accessToken) {
                                    console.log('üíæ Auto-saving to OneDrive for instant cross-device sync...');
                                    try {
                                        await this.updateOneDriveBackup();
                                        console.log('‚úÖ OneDrive backup updated with new image');
                                    } catch (error) {
                                        console.error('‚ö†Ô∏è Failed to auto-save backup:', error);
                                    }
                                }
                            }
                        } else {
                            console.log(`‚ö†Ô∏è Image too large for cross-device storage: ${imageData.size}KB`);
                        }
                    } catch (error) {
                        console.error('Error storing image for cross-device sync:', error);
                    }
                }
            }

            async extractAndCacheRealImage(article, index) {
                const imageElement = document.getElementById(`image-${index}`);
                if (!imageElement) return false;

                console.log(`üîç Extracting new image from: ${this.getDomain(article.url)}`);

                const savedImage = this.getBestArticleImage(article);
                if (savedImage) {
                    console.log(`‚úÖ Using saved image: ${article.title.substring(0, 30)}...`);
                    this.setArticleImageAndCache(article, index, savedImage, 'saved');
                    return true;
                }

                try {
                    const extractedImage = await this.fetchRealImageFromWebsite(article.url);
                    if (extractedImage) {
                        console.log(`‚úÖ Extracted real image: ${article.title.substring(0, 30)}...`);
                        this.setArticleImageAndCache(article, index, extractedImage, 'extracted');
                        return true;
                    }
                } catch (error) {
                    console.log(`‚ö†Ô∏è Could not extract from website: ${error.message}`);
                }

                console.log(`üé® Using intelligent fallback: ${article.title.substring(0, 30)}...`);
                const fallbackImage = this.getCategoryBasedImage(article, index);
                this.setArticleImageAndCache(article, index, fallbackImage, 'fallback');
                return true;
            }

            // ENHANCED: Load articles with automatic token refresh
            async loadArticles() {
                const hasValidToken = await this.ensureValidToken();
                if (!hasValidToken) {
                    this.updateConnectionStatus(false);
                    this.updateStatus('Authentication expired. Please reconnect.', 'error');
                    return;
                }

                try {
                    this.updateStatus('Loading articles... ‚è≥', 'loading');

                    const listResponse = await fetch('https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket:/children', {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!listResponse.ok) {
                        if (listResponse.status === 401) {
                            const refreshSuccess = await this.refreshAccessToken();
                            if (refreshSuccess) {
                                return this.loadArticles();
                            } else {
                                this.clearTokens();
                                this.updateConnectionStatus(false);
                                this.updateStatus('Session expired. Please reconnect.', 'error');
                                return;
                            }
                        }
                        throw new Error(`Failed to list files: ${listResponse.status}`);
                    }

                    const fileList = await listResponse.json();
                    const backupFiles = fileList.value.filter(file =>
                        file.name.startsWith('mypocket-backup-') && file.name.endsWith('.json')
                    );

                    if (backupFiles.length === 0) {
                        this.updateStatus('No backup files found. Save some articles with the browser extension first.', 'error');
                        this.displayEmptyState();
                        return;
                    }

                    const latestFile = backupFiles.sort((a, b) =>
                        new Date(b.lastModifiedDateTime) - new Date(a.lastModifiedDateTime)
                    )[0];

                    const downloadResponse = await fetch(`https://graph.microsoft.com/v1.0/me/drive/items/${latestFile.id}/content`, {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`
                        }
                    });

                    if (!downloadResponse.ok) {
                        throw new Error(`Failed to download backup: ${downloadResponse.status}`);
                    }

                    const backupContent = await downloadResponse.text();
                    const backup = JSON.parse(backupContent);

                    this.articles = backup.articles || [];
                    this.currentDisplayedArticles = this.articles;

                    console.log('üìÇ Auto-categorizing loaded articles...');
                    this.recategorizeAllArticles();

                    this.displayArticles(this.articles);
                    
                    this.updateSidebarCounts();

                    const cacheStats = this.getCacheStats();
                    const storedImages = this.articles.filter(a => a.cachedImage).length;
                    const dynamicCount = this.dynamicCategories.size;
                    const aiIndicator = dynamicCount > 0 ? ` (${dynamicCount} auto-discovered categories)` : '';
                    
                    this.updateStatus(`‚úÖ Loaded ${this.articles.length} articles from ${latestFile.name} (${storedImages} with stored images, ${cacheStats.total} locally cached)${aiIndicator}`, 'success');

                } catch (error) {
                    console.error('Error loading articles:', error);
                    this.updateStatus(`Error loading articles: ${error.message}`, 'error');
                }
            }

            displayEmptyState() {
                const container = document.getElementById('articlesContainer');
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìñ</div>
                        <h3>No articles found</h3>
                        <p>Use the MyPocket browser extension to save articles, then refresh this page to see intelligent categorization!</p>
                    </div>`;
            }

            searchArticles(query) {
                if (this.activeCategory && query.trim() !== '') {
                    this.activeCategory = null;
                    this.updateCategoryUI();
                }

                if (!query || query.trim() === '') {
                    this.currentDisplayedArticles = this.articles;
                    this.displayArticles(this.articles);
                    if (this.articles.length > 0) {
                        this.updateStatus(`Showing all ${this.articles.length} articles`, 'success');
                    }
                    return;
                }

                const searchTerm = query.toLowerCase().trim();
                console.log(`üîç Enhanced searching for: "${searchTerm}"`);

                const filtered = this.articles.filter(article => {
                    const titleMatch = article.title && article.title.toLowerCase().includes(searchTerm);
                    const excerptMatch = article.excerpt && article.excerpt.toLowerCase().includes(searchTerm);

                    const contentFields = ['content', 'textContent', 'html', 'fullContent', 'body', 'readableContent'];
                    const contentMatch = contentFields.some(field =>
                        article[field] && typeof article[field] === 'string' &&
                        article[field].toLowerCase().includes(searchTerm)
                    );

                    const authorMatch = article.author && article.author.toLowerCase().includes(searchTerm);
                    const domainMatch = this.getDomain(article.url).toLowerCase().includes(searchTerm);
                    const urlMatch = article.url && article.url.toLowerCase().includes(searchTerm);

                    const tagsMatch = article.tags && Array.isArray(article.tags) &&
                        article.tags.some(tag => tag.toLowerCase().includes(searchTerm));

                    if (!article.category) {
                        this.categorizeArticle(article);
                    }
                    const categoryMatch = article.category && article.category.toLowerCase().includes(searchTerm);

                    const keywordMatch = article.extractedKeywords && Array.isArray(article.extractedKeywords) &&
                        article.extractedKeywords.some(keyword => keyword.toLowerCase().includes(searchTerm));

                    return titleMatch || excerptMatch || contentMatch || authorMatch || domainMatch || urlMatch || tagsMatch || categoryMatch || keywordMatch;
                });

                console.log(`üéØ Search results: ${filtered.length}/${this.articles.length} articles`);

                this.currentDisplayedArticles = filtered;
                this.displayArticles(filtered);

                if (filtered.length === 0) {
                    this.updateStatus(`No articles found matching "${query}". Try different keywords or check categories.`, 'error');
                } else if (filtered.length === 1) {
                    this.updateStatus(`Found 1 article matching "${query}"`, 'success');
                } else {
                    this.updateStatus(`Found ${filtered.length} articles matching "${query}"`, 'success');
                }
            }

            openReaderByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                this.currentArticle = article;
                const overlay = document.getElementById('readerOverlay');

                document.getElementById('readerTitle').textContent = article.title;
                document.getElementById('readerDate').textContent = this.formatDate(article.dateAdded);
                document.getElementById('readerDomain').textContent = this.getDomain(article.url);
                document.getElementById('readerTime').textContent = `${article.readTime || 1} min read`;

                document.getElementById('readerContent').innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                        <p>Checking for article content...</p>
                    </div>
                `;

                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';

                setTimeout(() => this.loadArticleContent(article), 100);
            }

            exportArticleByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                try {
                    const html = this.createArticleHTML(article);
                    const filename = `${this.sanitizeFilename(article.title)}.html`;
                    this.downloadFile(html, filename, 'text/html');
                    this.updateStatus(`üì§ Article "${article.title}" exported successfully!`, 'success');
                } catch (error) {
                    console.error('Error exporting article:', error);
                    this.updateStatus(`‚ùå Failed to export article: ${error.message}`, 'error');
                }
            }

            async deleteArticleByDisplayIndex(displayIndex) {
                const article = this.currentDisplayedArticles[displayIndex];
                if (!article) {
                    console.error('Article not found at display index:', displayIndex);
                    return;
                }

                if (confirm(`Delete "${article.title}"?\n\nThis will permanently remove the article from your OneDrive backup.`)) {
                    try {
                        const originalIndex = this.articles.findIndex(a =>
                            a.url === article.url && a.title === article.title
                        );

                        if (originalIndex === -1) {
                            throw new Error('Could not find article in main collection');
                        }

                        const cacheKey = this.getCacheKey(article);
                        this.imageCache.delete(cacheKey);
                        this.saveImageCache();

                        this.articles.splice(originalIndex, 1);
                        this.currentDisplayedArticles.splice(displayIndex, 1);

                        if (this.accessToken) {
                            this.updateStatus('üè∑Ô∏è Updating categories and OneDrive backup...', 'loading');
                            await this.updateOneDriveBackup();
                            this.recategorizeAllArticles();
                            this.updateStatus(`‚úÖ Article deleted and backup updated. ${this.articles.length} articles remaining.`, 'success');
                        } else {
                            this.updateStatus(`‚ùå Article deleted locally but OneDrive backup not updated (not connected).`, 'error');
                        }

                        this.displayArticles(this.currentDisplayedArticles);

                    } catch (error) {
                        console.error('Error deleting article:', error);
                        this.updateStatus(`‚ùå Failed to delete article: ${error.message}`, 'error');
                    }
                }
            }

            async loadArticleContent(article) {
                console.log('üöÄ CONTENT LOADER WITH CACHING');
                const contentElement = document.getElementById('readerContent');

                let content = this.getArticleContent(article);

                if (!content) {
                    console.log('üåê No saved content found. Attempting to fetch from original URL...');

                    try {
                        contentElement.innerHTML = `
                            <div style="text-align: center; padding: 40px;">
                                <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                                <p><strong>üåê Fetching article content...</strong></p>
                                <p style="font-size: 0.9em; color: var(--text-secondary);">
                                    Loading from ${this.getDomain(article.url)}
                                </p>
                                <p style="font-size: 0.8em; color: var(--text-secondary);">
                                    This may take a few seconds...
                                </p>
                            </div>
                        `;

                        const fetchedContent = await this.fetchArticleContent(article.url);

                        if (fetchedContent && fetchedContent.trim()) {
                            content = fetchedContent;
                            console.log('‚úÖ Successfully fetched article content');
                            this.updateStatus('‚úÖ Article content loaded successfully!', 'success');
                        } else {
                            throw new Error('No content extracted from fetched page');
                        }

                    } catch (error) {
                        console.log('‚ùå Failed to fetch content:', error.message);
                        this.updateStatus('‚ùå Could not fetch article content. Using fallback.', 'error');
                        content = this.getFallbackContent(article, error.message);
                    }
                } else {
                    console.log('‚úÖ Using saved content');
                    this.updateStatus('‚úÖ Article loaded from saved content', 'success');
                }

                contentElement.innerHTML = content;
            }

            async fetchArticleContent(url) {
                try {
                    console.log(`üåê Starting fetch for: ${url}`);

                    try {
                        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                        console.log(`Trying AllOrigins proxy...`);

                        const response = await fetch(proxyUrl);

                        if (response.ok) {
                            const data = await response.json();
                            const html = data.contents;

                            if (html && html.length > 1000) {
                                console.log(`‚úÖ AllOrigins success: ${html.length} chars`);
                                const extractedContent = this.extractContentFromHTML(html, url);
                                if (extractedContent && extractedContent.length > 500) {
                                    return extractedContent;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`AllOrigins failed: ${error.message}`);
                    }

                    try {
                        const corsProxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                        console.log(`Trying CORS proxy...`);

                        const response = await fetch(corsProxyUrl);

                        if (response.ok) {
                            const html = await response.text();

                            if (html && html.length > 1000) {
                                console.log(`‚úÖ CORS proxy success: ${html.length} chars`);
                                const extractedContent = this.extractContentFromHTML(html, url);
                                if (extractedContent && extractedContent.length > 500) {
                                    return extractedContent;
                                }
                            }
                        }
                    } catch (error) {
                        console.log(`CORS proxy failed: ${error.message}`);
                    }

                    try {
                        console.log(`Trying direct fetch...`);
                        const response = await fetch(url, {
                            mode: 'cors',
                            headers: {
                                'User-Agent': 'Mozilla/5.0 (compatible; MyPocket AI Reader)'
                            }
                        });

                        if (response.ok) {
                            const html = await response.text();
                            console.log(`‚úÖ Direct fetch success: ${html.length} chars`);
                            return this.extractContentFromHTML(html, url);
                        }
                    } catch (error) {
                        console.log(`Direct fetch failed (expected): ${error.message}`);
                    }

                    throw new Error('All proxy methods failed to fetch content');

                } catch (error) {
                    console.error('‚ùå All fetch methods failed:', error);
                    throw error;
                }
            }

            extractContentFromHTML(html, url) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    const unwantedSelectors = [
                        'script', 'style', 'nav', 'header', 'footer',
                        '.sidebar', '.menu', '.navigation', '.comments',
                        '.advertisement', '.ads', '.social-share',
                        '[role="banner"]', '[role="navigation"]', '[role="complementary"]'
                    ];

                    unwantedSelectors.forEach(selector => {
                        doc.querySelectorAll(selector).forEach(el => el.remove());
                    });

                    const contentSelectors = [
                        'article',
                        '[role="main"]',
                        '.post-content', '.entry-content', '.article-content',
                        '.content', '.main-content', '.post-body',
                        '.entry', '.post', '.article-body',
                        'main', '#content', '#main'
                    ];

                    let contentElement = null;

                    for (const selector of contentSelectors) {
                        contentElement = doc.querySelector(selector);
                        if (contentElement && contentElement.textContent.trim().length > 200) {
                            break;
                        }
                    }

                    if (!contentElement || contentElement.textContent.trim().length < 200) {
                        const paragraphs = Array.from(doc.querySelectorAll('p'))
                            .filter(p => p.textContent.trim().length > 50)
                            .slice(0, 20);

                        if (paragraphs.length > 0) {
                            const div = doc.createElement('div');
                            paragraphs.forEach(p => div.appendChild(p.cloneNode(true)));
                            contentElement = div;
                        }
                    }

                    if (contentElement) {
                        let content = contentElement.innerHTML;

                        const baseUrl = new URL(url).origin;
                        content = content.replace(/src="\/([^"]+)"/g, `src="${baseUrl}/$1"`);
                        content = content.replace(/href="\/([^"]+)"/g, `href="${baseUrl}/$1"`);

                        content = `
                            <div style="background: #e3f2fd; border: 1px solid #2196f3; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                                <p style="margin: 0; font-size: 0.9em;">
                                    <strong>üì° Content fetched from original source</strong><br>
                                    This article content was retrieved in real-time from <a href="${url}" target="_blank" style="color: #1976d2;">${this.getDomain(url)}</a>
                                </p>
                            </div>
                            ${content}
                        `;

                        return content;
                    }

                    throw new Error('Could not extract readable content from page');

                } catch (error) {
                    console.error('Content extraction error:', error);
                    throw error;
                }
            }

            getFallbackContent(article, errorMessage) {
                return `
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h3>üìÑ Content Not Available</h3>
                        <p>We couldn't load the full article content. This can happen because:</p>
                        <ul style="margin: 15px 0;">
                            <li>The website blocks automated content fetching</li>
                            <li>CORS (Cross-Origin) restrictions prevent access</li>
                            <li>The article content wasn't saved by the browser extension</li>
                            <li>Network connectivity issues</li>
                        </ul>
                        
                        <p><strong>What you can do:</strong></p>
                        <ol style="margin: 15px 0;">
                            <li><strong>Visit the original article</strong> using the button below</li>
                            <li><strong>Re-save the article</strong> with your browser extension</li>
                            <li><strong>Check extension settings</strong> for content extraction options</li>
                        </ol>
                        
                        <div style="background: #f9f9f9; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <p><strong>Available excerpt:</strong></p>
                            <p style="font-style: italic;">${article.excerpt || 'No excerpt available'}</p>
                            
                            ${article.category ? `
                                <p><strong>ü§ñ AI Category:</strong> ${article.category} 
                                   ${article.categoryConfidence ? `(${article.categoryConfidence} confidence)` : ''}
                                </p>
                            ` : ''}
                            
                            ${article.extractedKeywords ? `
                                <p><strong>üîç AI Keywords:</strong> ${article.extractedKeywords.slice(0, 5).join(', ')}</p>
                            ` : ''}
                        </div>
                        
                        <div style="text-align: center; margin: 20px 0;">
                            <a href="${article.url}" target="_blank" style="display: inline-block; background: #ee5a24; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                                üîó Read Full Article
                            </a>
                        </div>
                        
                        <details style="margin-top: 20px;">
                            <summary style="cursor: pointer; color: #666;">Technical Details</summary>
                            <p style="font-size: 0.9em; color: #666; margin-top: 10px;">
                                Error: ${errorMessage}
                            </p>
                        </details>
                    </div>
                `;
            }

            getArticleContent(article) {
                console.log('üìñ Checking for saved content...');

                const contentFields = ['content', 'html', 'fullContent', 'textContent', 'body', 'readableContent', 'articleContent', 'savedContent'];

                for (const field of contentFields) {
                    if (article[field] && article[field].trim()) {
                        console.log(`‚úÖ Found content in ${field} (${article[field].length} chars)`);
                        return article[field];
                    }
                }

                for (const [key, value] of Object.entries(article)) {
                    if (typeof value === 'string' && value.length > 200 && key !== 'excerpt' && key !== 'url') {
                        console.log(`‚úÖ Found substantial content in ${key} (${value.length} chars)`);
                        return value;
                    }
                }

                console.log('‚ùå No saved content found');
                return null;
            }

            closeReader() {
                const overlay = document.getElementById('readerOverlay');
                overlay.classList.remove('active');
                document.body.style.overflow = 'auto';
            }

            openOriginal() {
                if (this.currentArticle) {
                    window.open(this.currentArticle.url, '_blank');
                }
            }

            // Enhanced backup to include image data and AI analysis
            async updateOneDriveBackup() {
                if (!this.accessToken) {
                    throw new Error('Not connected to OneDrive');
                }

                const articlesWithImages = this.articles.filter(a => a.cachedImage);
                const totalImageSizeKB = articlesWithImages.reduce((total, article) => {
                    return total + (article.cachedImage ? article.cachedImage.size || 0 : 0);
                }, 0);

                const articlesWithAI = this.articles.filter(a => a.category || a.extractedKeywords);
                const dynamicCategoriesCount = this.dynamicCategories.size;

                console.log(`üì¶ Creating AI-enhanced backup with ${articlesWithImages.length} stored images (${Math.round(totalImageSizeKB)}KB) and ${articlesWithAI.length} AI-analyzed articles`);

                const backup = {
                    articles: this.articles,
                    settings: {
                        storeImagesInBackup: this.storeImagesInBackup,
                        maxImageSizeKB: this.maxImageSizeKB,
                        enableDynamicCategories: this.enableDynamicCategories,
                        minCategoryConfidence: this.minCategoryConfidence
                    },
                    aiAnalysis: {
                        dynamicCategories: Object.fromEntries(this.dynamicCategories),
                        categoryCounts: Object.fromEntries(this.categories),
                        totalAnalyzedArticles: articlesWithAI.length,
                        dynamicCategoriesFound: dynamicCategoriesCount
                    },
                    exportDate: new Date().toISOString(),
                    version: "5.0",
                    deviceInfo: {
                        browser: "MyPocket AI Reader with PKCE Security + AI Categorization",
                        platform: navigator.platform,
                        timestamp: Date.now(),
                        articleCount: this.articles.length,
                        storedImages: articlesWithImages.length,
                        totalImageSizeKB: Math.round(totalImageSizeKB),
                        aiAnalyzedArticles: articlesWithAI.length,
                        dynamicCategories: dynamicCategoriesCount,
                        authMethod: "Authorization Code + PKCE"
                    }
                };

                const fileName = `mypocket-backup-${new Date().toISOString().split('T')[0]}.json`;
                const fileContent = JSON.stringify(backup, null, 2);

                const backupSizeMB = fileContent.length / (1024 * 1024);
                if (backupSizeMB > 10) {
                    console.warn(`‚ö†Ô∏è Large backup detected: ${backupSizeMB.toFixed(1)}MB`);
                }

                const uploadUrl = `https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket/${fileName}:/content`;

                const uploadResponse = await fetch(uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${this.accessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: fileContent
                });

                if (!uploadResponse.ok) {
                    const errorText = await uploadResponse.text();
                    throw new Error(`Failed to update OneDrive backup: ${uploadResponse.status} - ${errorText}`);
                }

                console.log(`‚úÖ AI-enhanced backup saved with ${articlesWithImages.length} images (${Math.round(totalImageSizeKB)}KB) and ${dynamicCategoriesCount} AI-discovered categories`);
                return await uploadResponse.json();
            }

            createArticleHTML(article) {
                const aiInfo = article.category ? `
                    <div style="background: #e8f5e8; padding: 12px; border-radius: 8px; margin: 16px 0;">
                        <strong>ü§ñ AI Analysis:</strong><br>
                        Category: ${article.category} ${article.categoryConfidence ? `(${article.categoryConfidence} confidence)` : ''}<br>
                        ${article.extractedKeywords ? `Keywords: ${article.extractedKeywords.slice(0, 5).join(', ')}` : ''}
                    </div>
                ` : '';

                return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escapeHtml(article.title)}</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            max-width: 800px; 
            margin: 0 auto; 
            padding: 40px 20px; 
            line-height: 1.7; 
            color: #333;
        }
        .header { 
            border-bottom: 3px solid #ee5a24; 
            margin-bottom: 32px; 
            padding-bottom: 24px; 
        }
        .title { 
            font-size: 2.4em; 
            font-weight: bold; 
            margin-bottom: 16px; 
            color: #2c3e50; 
            line-height: 1.2; 
        }
        .meta { 
            color: #7f8c8d; 
            font-size: 0.95em; 
            margin-bottom: 24px; 
        }
        .content { 
            font-size: 1.15em; 
            line-height: 1.8; 
        }
        .content img { 
            max-width: 100%; 
            height: auto; 
            margin: 24px 0; 
            border-radius: 8px; 
        }
        .content p { 
            margin-bottom: 1.4em; 
        }
        .footer { 
            margin-top: 48px; 
            padding-top: 24px; 
            border-top: 2px solid #f0f0f0; 
            color: #666; 
            font-size: 0.9em; 
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">${this.escapeHtml(article.title)}</h1>
        <div class="meta">
            <div style="margin-bottom: 8px;">üåê From: <a href="${article.url}" style="color: #ee5a24;">${this.getDomain(article.url)}</a></div>
            ${article.author ? `<div style="margin-bottom: 8px;">‚úçÔ∏è By: ${this.escapeHtml(article.author)}</div>` : ''}
            <div style="margin-bottom: 8px;">üìÖ Saved: ${this.formatDate(article.dateAdded)}</div>
            <div>‚è±Ô∏è Reading time: ${article.readTime || 1} minutes</div>
        </div>
        ${aiInfo}
    </div>
    <div class="content">
        ${article.content}
    </div>
    <div class="footer">
        <p><strong>ü§ñ Exported from MyPocket AI Reader (PKCE Secured)</strong></p>
        <p>Original URL: <a href="${article.url}" style="color: #ee5a24;">${article.url}</a></p>
        <p>Export Date: ${new Date().toLocaleDateString()}</p>
        ${article.category ? `<p>AI Category: ${article.category}</p>` : ''}
    </div>
</body>
</html>`;
            }

            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                URL.revokeObjectURL(url);
            }

            getBestArticleImage(article) {
                if (article.images && article.images.length > 0) {
                    let bestImage = article.images[0];

                    for (const img of article.images) {
                        if (img.width && img.height) {
                            if (img.width >= 300 && img.height >= 150) {
                                bestImage = img;
                                break;
                            }
                        }
                    }

                    return bestImage.src || bestImage.url || bestImage;
                }

                if (article.featuredImage) {
                    return article.featuredImage;
                }

                if (article.image) {
                    return article.image;
                }

                if (article.content) {
                    const imgMatch = article.content.match(/<img[^>]+src="([^"]+)"/i);
                    if (imgMatch && imgMatch[1]) {
                        return imgMatch[1];
                    }
                }

                return null;
            }

            async fetchRealImageFromWebsite(url) {
                try {
                    console.log(`üåê Fetching webpage to extract image: ${url}`);

                    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                    const response = await fetch(proxyUrl);

                    if (!response.ok) {
                        throw new Error('Failed to fetch webpage');
                    }

                    const data = await response.json();
                    const html = data.contents;

                    if (!html || html.length < 500) {
                        throw new Error('No substantial HTML content received');
                    }

                    const extractedImageUrl = this.parseHTMLForBestImage(html, url);

                    if (extractedImageUrl) {
                        console.log(`üéØ Found image: ${extractedImageUrl}`);
                        return extractedImageUrl;
                    }

                    throw new Error('No suitable image found in webpage');

                } catch (error) {
                    console.log(`‚ùå Website image extraction failed: ${error.message}`);

                    try {
                        return await this.tryAlternativeImageExtraction(url);
                    } catch (altError) {
                        console.log(`‚ùå Alternative extraction also failed: ${altError.message}`);
                        throw error;
                    }
                }
            }

            parseHTMLForBestImage(html, baseUrl) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    // Strategy 1: Look for Open Graph image
                    const ogImage = doc.querySelector('meta[property="og:image"]');
                    if (ogImage) {
                        const imageUrl = this.makeAbsoluteUrl(ogImage.getAttribute('content'), baseUrl);
                        if (this.isValidImageUrl(imageUrl)) {
                            console.log(`üéØ Found Open Graph image: ${imageUrl}`);
                            return imageUrl;
                        }
                    }

                    // Strategy 2: Look for Twitter card image
                    const twitterImage = doc.querySelector('meta[name="twitter:image"], meta[property="twitter:image"]');
                    if (twitterImage) {
                        const imageUrl = this.makeAbsoluteUrl(twitterImage.getAttribute('content'), baseUrl);
                        if (this.isValidImageUrl(imageUrl)) {
                            console.log(`üéØ Found Twitter card image: ${imageUrl}`);
                            return imageUrl;
                        }
                    }

                    // Strategy 3: Look for article featured image
                    const featuredSelectors = [
                        '.featured-image img',
                        '.hero-image img',
                        '.post-thumbnail img',
                        '.article-image img',
                        '.entry-image img',
                        '.wp-post-image',
                        'article img:first-of-type',
                        '.content img:first-of-type',
                        '.post-content img:first-of-type'
                    ];

                    for (const selector of featuredSelectors) {
                        const img = doc.querySelector(selector);
                        if (img) {
                            const src = img.getAttribute('src') || img.getAttribute('data-src') || img.getAttribute('data-lazy-src');
                            if (src) {
                                const imageUrl = this.makeAbsoluteUrl(src, baseUrl);
                                if (this.isValidImageUrl(imageUrl) && !this.isIconOrLogo(src)) {
                                    console.log(`üéØ Found featured image: ${imageUrl}`);
                                    return imageUrl;
                                }
                            }
                        }
                    }

                    // Strategy 4: Look for the first substantial image in the content
                    const allImages = Array.from(doc.querySelectorAll('img')).filter(img => {
                        const src = img.getAttribute('src') || img.getAttribute('data-src');
                        const width = img.getAttribute('width') || img.style.width;
                        const height = img.getAttribute('height') || img.style.height;

                        return src &&
                            !this.isIconOrLogo(src) &&
                            !this.isSmallImage(width, height) &&
                            !src.includes('avatar') &&
                            !src.includes('profile');
                    });

                    for (const img of allImages) {
                        const src = img.getAttribute('src') || img.getAttribute('data-src');
                        if (src) {
                            const imageUrl = this.makeAbsoluteUrl(src, baseUrl);
                            if (this.isValidImageUrl(imageUrl)) {
                                console.log(`üéØ Found content image: ${imageUrl}`);
                                return imageUrl;
                            }
                        }
                    }

                    console.log(`‚ùå No suitable image found in HTML`);
                    return null;

                } catch (error) {
                    console.error('HTML parsing error:', error);
                    return null;
                }
            }

            async tryAlternativeImageExtraction(url) {
                try {
                    const corsProxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
                    const response = await fetch(corsProxyUrl);

                    if (response.ok) {
                        const html = await response.text();
                        const extractedImage = this.parseHTMLForBestImage(html, url);
                        if (extractedImage) return extractedImage;
                    }
                } catch (error) {
                    console.log(`CORS proxy failed: ${error.message}`);
                }

                const guessedImage = this.guessImageFromUrl(url);
                if (guessedImage) return guessedImage;

                throw new Error('All alternative extraction methods failed');
            }

            guessImageFromUrl(url) {
                const domain = this.getDomain(url).toLowerCase();

                if (domain.includes('medium.com')) {
                    const match = url.match(/\/([a-f0-9]+)$/);
                    if (match) {
                        return `https://miro.medium.com/max/1400/1*${match[1]}.png`;
                    }
                }

                if (domain.includes('github.com')) {
                    const pathMatch = url.match(/github\.com\/([^\/]+)\/([^\/]+)/);
                    if (pathMatch) {
                        return `https://opengraph.githubassets.com/1/${pathMatch[1]}/${pathMatch[2]}`;
                    }
                }

                if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                    const videoIdMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/);
                    if (videoIdMatch) {
                        return `https://img.youtube.com/vi/${videoIdMatch[1]}/maxresdefault.jpg`;
                    }
                }

                return null;
            }

            isValidImageUrl(url) {
                if (!url || typeof url !== 'string') return false;

                try {
                    new URL(url);
                } catch {
                    return false;
                }

                const imagePattern = /\.(jpg|jpeg|png|gif|webp|svg)(\?|$)/i;
                const imageServices = ['unsplash.com', 'images.unsplash.com', 'picsum.photos', 'via.placeholder.com'];

                return imagePattern.test(url) || imageServices.some(service => url.includes(service));
            }

            isIconOrLogo(src) {
                if (!src) return false;

                const iconPatterns = [
                    'icon', 'logo', 'avatar', 'profile', 'favicon', 'sprite',
                    'button', 'badge', 'social', 'thumb', 'thumbnail',
                    '/icons/', '/images/icons/', 'gravatar', 'user-content'
                ];

                const srcLower = src.toLowerCase();
                return iconPatterns.some(pattern => srcLower.includes(pattern)) ||
                    srcLower.includes('.ico') ||
                    (srcLower.includes('64x64') || srcLower.includes('32x32'));
            }

            isSmallImage(width, height) {
                if (!width && !height) return false;

                const w = parseInt(width) || 0;
                const h = parseInt(height) || 0;

                return (w > 0 && w < 200) || (h > 0 && h < 150);
            }

            getCategoryBasedImage(article, index) {
                const domain = this.getDomain(article.url).toLowerCase();
                const title = article.title.toLowerCase();
                const url = article.url.toLowerCase();

                const articleSeed = article.url + article.title;
                let hash = 0;
                for (let i = 0; i < articleSeed.length; i++) {
                    const char = articleSeed.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                const consistentIndex = Math.abs(hash);

                if (article.category && this.categoryKeywords[article.category]) {
                    const categoryData = this.categoryKeywords[article.category];
                    
                    if (article.category === 'Technology') {
                        return `https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    if (article.category === 'Business' || article.category === 'Finance') {
                        return `https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    if (article.category === 'Design') {
                        return `https://images.unsplash.com/photo-1561070791-2526d30994b5?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    if (article.category === 'Science') {
                        return `https://images.unsplash.com/photo-1532094349884-543bc11b234d?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    if (article.category === 'Health') {
                        return `https://images.unsplash.com/photo-1571019613454-1cb2f99b2d8b?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    if (article.category === 'News') {
                        return `https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    if (article.category === 'Food') {
                        return `https://images.unsplash.com/photo-1504674900247-0877df9cc836?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    if (article.category === 'Travel') {
                        return `https://images.unsplash.com/photo-1488646953014-85cb44e25828?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    if (article.category === 'Education') {
                        return `https://images.unsplash.com/photo-1523240795612-9a054b0db644?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    if (article.category === 'Entertainment') {
                        return `https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                    
                    if (article.category === 'Sports') {
                        return `https://images.unsplash.com/photo-1461896836934-ffe607ba8211?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                    }
                }

                if (domain.includes('github') || domain.includes('stackoverflow') || domain.includes('dev.to') ||
                    title.includes('code') || title.includes('programming') || title.includes('javascript') || title.includes('react')) {
                    return `https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }

                if (domain.includes('business') || domain.includes('finance') || domain.includes('linkedin') ||
                    title.includes('business') || title.includes('finance') || title.includes('startup') || title.includes('entrepreneur')) {
                    return `https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }

                if (domain.includes('dribbble') || domain.includes('behance') ||
                    title.includes('design') || title.includes('ui') || title.includes('ux') || title.includes('creative')) {
                    return `https://images.unsplash.com/photo-1561070791-2526d30994b5?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }

                if (domain.includes('news') || domain.includes('bbc') || domain.includes('cnn') ||
                    title.includes('news') || title.includes('politics') || title.includes('media')) {
                    return `https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;
                }

                const defaultImages = [
                    'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1511593358241-7eea1f3c84e5?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1519681393784-d120267933ba?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1517077304055-6e89abbf09b0?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1470115636492-6d2b56f9146d?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1503023345310-bd7c1de61c7d?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1558618047-3c8c76ca7d13?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1506744038136-46273834b3fb?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                    'https://images.unsplash.com/photo-1518837695005-2083093ee35b?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                ];

                return defaultImages[consistentIndex % defaultImages.length];
            }

            makeAbsoluteUrl(imageUrl, baseUrl) {
                if (!imageUrl) return null;

                try {
                    if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                        return imageUrl;
                    }

                    if (imageUrl.startsWith('//')) {
                        return 'https:' + imageUrl;
                    }

                    const base = new URL(baseUrl);
                    return new URL(imageUrl, base.origin).href;
                } catch (error) {
                    console.log(`Failed to make absolute URL: ${imageUrl}, base: ${baseUrl}`);
                    return null;
                }
            }

            getArticleIcon(url) {
                const domain = this.getDomain(url).toLowerCase();

                const siteIcons = {
                    'youtube.com': 'üì∫',
                    'github.com': 'üêô',
                    'stackoverflow.com': 'üíª',
                    'medium.com': 'üìù',
                    'dev.to': 'üë®‚Äçüíª',
                    'twitter.com': 'üê¶',
                    'x.com': 'üê¶',
                    'linkedin.com': 'üíº',
                    'reddit.com': 'üî¥',
                    'hackernews.ycombinator.com': 'üü†',
                    'techcrunch.com': 'üì∞',
                    'theverge.com': 'üì±',
                    'arstechnica.com': 'üî¨',
                    'wired.com': '‚ö°',
                    'bbc.com': 'üì∫',
                    'cnn.com': 'üì∞',
                    'nytimes.com': 'üì∞',
                    'guardian.co.uk': 'üì∞',
                    'washingtonpost.com': 'üì∞',
                    'wikipedia.org': 'üìñ',
                    'arxiv.org': 'üéì',
                };

                for (const [siteDomain, icon] of Object.entries(siteIcons)) {
                    if (domain.includes(siteDomain)) {
                        return icon;
                    }
                }

                if (domain.includes('blog') || domain.includes('medium')) return 'üìù';
                if (domain.includes('news')) return 'üì∞';
                if (domain.includes('tech')) return 'üíª';
                if (domain.includes('code') || domain.includes('dev')) return 'üë®‚Äçüíª';
                if (domain.includes('video') || domain.includes('tube')) return 'üì∫';
                if (domain.includes('music') || domain.includes('spotify')) return 'üéµ';
                if (domain.includes('photo') || domain.includes('image')) return 'üì∏';
                if (domain.includes('shop') || domain.includes('store')) return 'üõí';
                if (domain.includes('book') || domain.includes('read')) return 'üìö';
                if (domain.includes('learn') || domain.includes('edu')) return 'üéì';

                return 'üìÑ';
            }

            getDomain(url) {
                try {
                    return new URL(url).hostname.replace('www.', '');
                } catch (e) {
                    return url;
                }
            }

            formatDate(dateString) {
                try {
                    const date = new Date(dateString);

                    if (isNaN(date.getTime())) {
                        console.error('Invalid date:', dateString);
                        return 'invalid date';
                    }

                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const targetDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

                    const diffMs = today.getTime() - targetDate.getTime();
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

                    if (diffDays < 0) {
                        return date.toLocaleDateString();
                    }

                    if (diffDays === 0) {
                        return 'today';
                    } else if (diffDays === 1) {
                        return 'yesterday';
                    } else if (diffDays <= 7) {
                        return `${diffDays} days ago`;
                    } else if (diffDays <= 30) {
                        const weeks = Math.floor(diffDays / 7);
                        return weeks === 1 ? '1 week ago' : `${weeks} weeks ago`;
                    } else if (diffDays <= 365) {
                        const months = Math.floor(diffDays / 30);
                        return months === 1 ? '1 month ago' : `${months} months ago`;
                    } else {
                        const years = Math.floor(diffDays / 365);
                        return years === 1 ? '1 year ago' : `${years} years ago`;
                    }
                } catch (error) {
                    console.error('Date formatting error:', error, 'Input:', dateString);
                    return 'date error';
                }
            }

            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            sanitizeFilename(filename) {
                if (!filename) return 'article';
                return filename.replace(/[^a-z0-9\s]/gi, '_').toLowerCase().substring(0, 50);
            }

            showDebugInfo() {
                const cacheStats = this.getCacheStats();
                const storedImages = this.articles.filter(a => a.cachedImage).length;
                const totalStoredSizeKB = this.articles.reduce((total, article) => {
                    return total + (article.cachedImage ? article.cachedImage.size || 0 : 0);
                }, 0);

                const hasRefreshToken = !!this.getRefreshToken();
                const tokenTimestamp = localStorage.getItem('mypocket_token_timestamp');
                const tokenAge = tokenTimestamp ? Math.round((Date.now() - parseInt(tokenTimestamp)) / 1000 / 60) : 'Unknown';

                const searchContainer = document.getElementById('searchContainer');
                const isSearchVisible = searchContainer.style.display !== 'none';

                const categoryContainer = document.getElementById('categoryContainer');
                const isCategoryVisible = categoryContainer.style.display !== 'none';

                const categorizedArticles = this.articles.filter(a => a.category).length;
                const categoryBreakdown = Array.from(this.categories.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .map(([cat, count]) => `${cat}: ${count}`)
                    .join(', ');

                const dynamicCategoryBreakdown = Array.from(this.dynamicCategories.entries())
                    .slice(0, 3)
                    .map(([cat, data]) => `${cat}: ${data.articles.length}`)
                    .join(', ');

                const aiAnalyzedArticles = this.articles.filter(a => a.extractedKeywords && a.extractedKeywords.length > 0).length;

                const info = `
MyPocket AI Reader Debug Info (Enhanced PKCE + AI):
==================================================

Current URL: ${window.location.href}
Redirect URI: ${this.redirectUri}
Client ID: ${this.clientId}
Protocol: ${window.location.protocol}
Host: ${window.location.host}

üîê SECURITY (PKCE):
- Authentication Method: Authorization Code + PKCE
- Security Level: HIGH (recommended for SPAs)
- Anti-CSRF Protection: Enabled (state parameter)
- Code Challenge Method: SHA256
- Token Storage: localStorage (access), sessionStorage (PKCE params)

üé´ TOKEN STATUS:
- Has Access Token: ${!!this.accessToken}
- Has Refresh Token: ${hasRefreshToken}
- Token Age: ${tokenAge} minutes
- Auto-Refresh: Enabled

üìö ARTICLES & IMAGES:
- Articles Loaded: ${this.articles.length}
- Currently Displayed: ${this.currentDisplayedArticles.length}
- Store Images in Backup: ${this.storeImagesInBackup}
- Max Image Size: ${this.maxImageSizeKB}KB
- Articles with Stored Images: ${storedImages}
- Total Stored Image Size: ${Math.round(totalStoredSizeKB)}KB
- Failed Images: ${this.failedImages.size}

üîç SEARCH STATUS:
- Search Visible: ${isSearchVisible}
- Keyboard Shortcuts: Ctrl/Cmd+K, / (open), Esc (close)
- Click Outside: Enabled

ü§ñ AI CATEGORIZATION:
- AI Analysis Enabled: ${this.enableDynamicCategories}
- Min Category Confidence: ${this.minCategoryConfidence}
- Max Categories: ${this.maxCategories}
- AI Analyzed Articles: ${aiAnalyzedArticles}/${this.articles.length}
- Categorized Articles: ${categorizedArticles}/${this.articles.length}
- Static Categories Found: ${this.categories.size}
- Dynamic Categories (AI-discovered): ${this.dynamicCategories.size}
- Top Static Categories: ${categoryBreakdown || 'None'}
- Top Dynamic Categories: ${dynamicCategoryBreakdown || 'None'}
- Category Filter Visible: ${isCategoryVisible}
- Active Category Filter: ${this.activeCategory || 'None'}

üíæ LOCAL CACHE:
- Total Cached Images: ${cacheStats.total}
- Memory Usage: ${Math.round(cacheStats.memoryUsage / 1024)} KB
- Cache Expiry: ${this.cacheExpiryDays} days

üõ°Ô∏è SECURITY BENEFITS:
‚úÖ No tokens exposed in URL
‚úÖ Protection against code interception
‚úÖ Anti-CSRF state verification
‚úÖ Automatic token refresh
‚úÖ Secure parameter storage

ü§ñ AI CATEGORIZATION FEATURES:
‚úÖ Intelligent content analysis with TF-IDF-like scoring
‚úÖ Dynamic category discovery from content patterns
‚úÖ Multi-factor analysis (title, content, domain, keywords)
‚úÖ Confidence scoring (high/medium/low confidence indicators)
‚úÖ Stop word filtering and keyword extraction
‚úÖ Cross-device AI analysis consistency
‚úÖ Support for 12+ predefined categories + unlimited dynamic categories

Azure AD Setup for PKCE:
1. App Registration ‚Üí Authentication
2. Add Web platform: ${this.redirectUri}
3. Enable "Access tokens" and "ID tokens"
4. Set redirect URI exactly: ${this.redirectUri}
5. PKCE is automatically supported for public clients

Cross-Device Image Features:
- Images stored in OneDrive backup for instant loading
- Base64 encoding with ${this.maxImageSizeKB}KB size limit
- Automatic compression to 80% quality
- Works across all devices and browsers

AI Categorization Algorithm:
- Extracts meaningful keywords using frequency analysis
- Scores categories using domain matching, keyword analysis, semantic understanding
- Discovers new categories dynamically from content patterns
- Maintains consistency across devices through content-based analysis
- Provides confidence indicators for category assignments
                `;

                alert(info);
                console.log('ü§ñ AI Debug Info:', {
                    currentUrl: window.location.href,
                    redirectUri: this.redirectUri,
                    authMethod: 'Authorization Code + PKCE',
                    securityLevel: 'HIGH',
                    hasToken: !!this.accessToken,
                    hasRefreshToken: hasRefreshToken,
                    tokenAge: `${tokenAge} minutes`,
                    articlesCount: this.articles.length,
                    displayedCount: this.currentDisplayedArticles.length,
                    searchVisible: isSearchVisible,
                    categoryVisible: isCategoryVisible,
                    categorizedArticles: categorizedArticles,
                    staticCategories: this.categories.size,
                    dynamicCategories: this.dynamicCategories.size,
                    aiAnalyzedArticles: aiAnalyzedArticles,
                    activeCategory: this.activeCategory,
                    cacheStats: cacheStats,
                    storedImages: storedImages,
                    crossDeviceEnabled: this.storeImagesInBackup,
                    aiSettings: {
                        enableDynamicCategories: this.enableDynamicCategories,
                        minCategoryConfidence: this.minCategoryConfidence,
                        maxCategories: this.maxCategories
                    }
                });
            }

            toggleTestMode() {
                document.body.classList.toggle('test-mode');
                const isTestMode = document.body.classList.contains('test-mode');

                const testBtn = document.querySelector('[onclick="webReader.toggleTestMode()"]');
                if (testBtn) {
                    const iconSpan = testBtn.querySelector('.icon');
                    const labelSpan = testBtn.querySelector('.label');
                    
                    if (isTestMode) {
                        iconSpan.textContent = 'üëÅÔ∏è';
                        labelSpan.textContent = 'Hide Buttons';
                    } else {
                        iconSpan.textContent = 'üëÅÔ∏è';
                        labelSpan.textContent = 'Show Buttons';
                    }
                }

                this.updateStatus(
                    isTestMode
                        ? 'üîç Test mode ON - Action buttons always visible'
                        : 'üëÅÔ∏è Test mode OFF - Action buttons show on hover',
                    'success'
                );
            }

            toggleDarkMode() {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);

                this.updateDarkModeButton(newTheme);
                this.updateStatus(
                    newTheme === 'dark' ? 'üåô Dark mode enabled' : '‚òÄÔ∏è Light mode enabled',
                    'success'
                );
            }

            loadThemePreference() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                document.documentElement.setAttribute('data-theme', savedTheme);
                this.updateDarkModeButton(savedTheme);
            }

            updateDarkModeButton(theme) {
                const darkModeBtn = document.querySelector('[onclick="webReader.toggleDarkMode()"]');
                if (darkModeBtn) {
                    const iconSpan = darkModeBtn.querySelector('.icon');
                    const labelSpan = darkModeBtn.querySelector('.label');
                    
                    if (theme === 'dark') {
                        iconSpan.textContent = '‚òÄÔ∏è';
                        labelSpan.textContent = 'Light Mode';
                    } else {
                        iconSpan.textContent = 'üåô';
                        labelSpan.textContent = 'Dark Mode';
                    }
                }
            }
        }

        let webReader;
        document.addEventListener('DOMContentLoaded', () => {
            webReader = new MyPocketWebReader();
            window.webReader = webReader;
        });
    </script>
</body>

</html>
