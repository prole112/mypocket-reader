<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyPocket - Web Reader (Enhanced AI Categories)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #ee5a24;
            --secondary-color: #667eea;
            --background: #f8f9fa;
            --surface: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --border: #e9ecef;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        /* Enhanced Dark mode with better contrast */
        [data-theme="dark"] {
            --primary-color: #ff6b35;
            --secondary-color: #7b88f7;
            --background: #0d1117;
            --surface: #161b22;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --border: #30363d;
            --shadow: 0 2px 12px rgba(0, 0, 0, 0.6);
            --shadow-hover: 0 4px 20px rgba(0, 0, 0, 0.8);
        }

        /* Dark mode specific improvements */
        [data-theme="dark"] .article-card {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .article-card:hover {
            border-color: #484f58;
            transform: translateY(-2px) scale(1.02);
        }

        [data-theme="dark"] .search-input {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .search-input:focus {
            border-color: var(--primary-color);
            background: var(--surface);
        }

        [data-theme="dark"] .search-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.8;
        }

        [data-theme="dark"] .search-close-btn:hover {
            background: #21262d;
            color: var(--text-primary);
        }

        [data-theme="dark"] .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border-color: var(--border);
        }

        [data-theme="dark"] .btn-secondary:hover {
            background: #21262d;
            border-color: #484f58;
            color: var(--text-primary);
        }

        [data-theme="dark"] .action-btn {
            background: rgba(22, 27, 34, 0.95);
            border-color: var(--border);
            color: var(--text-primary);
            backdrop-filter: blur(10px);
        }

        [data-theme="dark"] .action-btn:hover {
            background: rgba(33, 38, 45, 0.95);
            border-color: #484f58;
        }

        [data-theme="dark"] .read-btn:hover {
            background: rgba(13, 110, 253, 0.2);
            border-color: #0d6efd;
            color: #58a6ff;
        }

        [data-theme="dark"] .export-btn:hover {
            background: rgba(25, 135, 84, 0.2);
            border-color: #198754;
            color: #3fb950;
        }

        [data-theme="dark"] .refresh-image-btn:hover {
            background: rgba(255, 152, 0, 0.2);
            border-color: #ff9800;
            color: #ffb74d;
        }

        [data-theme="dark"] .delete-btn:hover {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #f85149;
        }

        [data-theme="dark"] .reader-container {
            background: var(--surface);
            border: 1px solid var(--border);
        }

        [data-theme="dark"] .reader-header {
            background: var(--background);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .reader-content {
            color: var(--text-primary);
        }

        [data-theme="dark"] .reader-content h1,
        [data-theme="dark"] .reader-content h2,
        [data-theme="dark"] .reader-content h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .reader-content blockquote {
            background: var(--background);
            border-left-color: var(--primary-color);
        }

        [data-theme="dark"] .close-reader {
            background: var(--primary-color);
        }

        [data-theme="dark"] .empty-state {
            color: var(--text-secondary);
        }

        [data-theme="dark"] .empty-state h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .connection-status.connected {
            background: rgba(25, 135, 84, 0.2);
            border-color: #198754;
            color: #3fb950;
        }

        [data-theme="dark"] .connection-status.disconnected {
            background: rgba(220, 53, 69, 0.2);
            border-color: #dc3545;
            color: #f85149;
        }

        /* NEW: Enhanced dark mode styles for cache indicators */
        [data-theme="dark"] .cache-indicator.synced {
            background: rgba(76, 175, 80, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.fallback {
            background: rgba(255, 152, 0, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.metadata {
            background: rgba(103, 58, 183, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.error {
            background: rgba(244, 67, 54, 0.9);
            color: white;
        }

        /* NEW: AI categorization indicator */
        [data-theme="dark"] .cache-indicator.ai-categorized {
            background: rgba(76, 175, 80, 0.9);
            color: white;
        }

        [data-theme="dark"] .cache-indicator.smart-categorized {
            background: rgba(103, 58, 183, 0.9);
            color: white;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background: var(--background);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            color: white;
            padding: 20px 0;
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-left: 60px;
            /* Account for sidebar */
        }

        .logo {
            font-size: 1.8em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        /* Left Sidebar - Pocket Style */
        .sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: 280px;
            height: 100vh;
            background: var(--surface);
            border-right: 1px solid var(--border);
            z-index: 101;
            overflow-y: auto;
            transition: transform 0.3s ease;
            box-shadow: var(--shadow);
        }

        .sidebar.collapsed {
            transform: translateX(-220px);
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: var(--background);
        }

        .sidebar-brand {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.2em;
            font-weight: 600;
            color: var(--text-primary);
        }

        .sidebar-toggle {
            position: absolute;
            right: -40px;
            top: 20px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 0 8px 8px 0;
            padding: 8px;
            cursor: pointer;
            color: var(--text-primary);
            transition: all 0.2s ease;
            z-index: 102;
        }

        .sidebar-toggle:hover {
            background: var(--primary-color);
            color: white;
        }

        .sidebar-nav {
            padding: 20px 0;
        }

        .nav-section {
            margin-bottom: 30px;
        }

        .nav-section-title {
            padding: 0 20px 10px;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            letter-spacing: 0.5px;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            color: var(--text-primary);
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 14px;
        }

        .nav-item:hover {
            background: var(--background);
            color: var(--primary-color);
        }

        .nav-item.active {
            background: var(--primary-color);
            color: white;
            border-right: 3px solid var(--secondary-color);
        }

        .nav-item .icon {
            width: 20px;
            text-align: center;
            font-size: 16px;
        }

        .nav-item .text {
            flex: 1;
        }

        .nav-item .badge {
            background: var(--border);
            color: var(--text-secondary);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: 500;
        }

        .nav-item.active .badge {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        /* Connection Status in Sidebar */
        .connection-panel {
            padding: 15px 20px;
            margin: 10px 0;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
        }

        .connection-status-sidebar {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9em;
        }

        .connection-status-sidebar.connected {
            color: #27ae60;
        }

        .connection-status-sidebar.disconnected {
            color: #e74c3c;
        }

        .connect-btn-sidebar {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .connect-btn-sidebar:hover {
            background: var(--secondary-color);
            transform: translateY(-1px);
        }

        .connect-btn-sidebar.connected {
            background: #27ae60;
        }

        /* Main Content Area */
        .main-content {
            margin-left: 280px;
            min-height: 100vh;
            transition: margin-left 0.3s ease;
        }

        .main-content.sidebar-collapsed {
            margin-left: 60px;
        }

        /* Mobile Sidebar */
        .mobile-header {
            display: none;
        }

        /* Dark mode sidebar styles */
        [data-theme="dark"] .sidebar {
            background: var(--surface);
            border-right-color: var(--border);
        }

        [data-theme="dark"] .sidebar-header {
            background: var(--background);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .sidebar-brand {
            color: var(--text-primary);
        }

        [data-theme="dark"] .sidebar-toggle {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .sidebar-toggle:hover {
            background: var(--primary-color);
            color: white;
        }

        [data-theme="dark"] .nav-section-title {
            color: var(--text-secondary);
        }

        [data-theme="dark"] .nav-item {
            color: var(--text-primary);
        }

        [data-theme="dark"] .nav-item:hover {
            background: var(--background);
            color: var(--primary-color);
        }

        [data-theme="dark"] .nav-item.active {
            background: var(--primary-color);
            color: white;
        }

        [data-theme="dark"] .nav-item .badge {
            background: var(--border);
            color: var(--text-secondary);
        }

        [data-theme="dark"] .nav-item.active .badge {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        [data-theme="dark"] .connection-panel {
            border-top-color: var(--border);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .connect-btn-sidebar {
            background: var(--primary-color);
        }

        [data-theme="dark"] .connect-btn-sidebar:hover {
            background: var(--secondary-color);
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .btn-primary:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
            transform: translateY(-1px);
        }

        /* Search Toggle Animation */
        .search-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 90;
            padding: 30px 0;
        }

        .search-container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .search-container.hidden {
            opacity: 0;
            transform: translateY(-10px);
        }

        /* Category Filter Styles */
        .category-container {
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 89;
            padding: 20px 0;
        }

        .category-container.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .category-container.hidden {
            opacity: 0;
            transform: translateY(-10px);
        }

        .category-filter {
            max-width: 800px;
            margin: 0 auto;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .category-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.2em;
        }

        .category-close-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .category-close-btn:hover {
            background: var(--border);
            color: var(--text-primary);
            transform: scale(1.1);
        }

        .category-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        .category-chip {
            background: var(--background);
            border: 2px solid var(--border);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
        }

        .category-chip:hover {
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: white;
            transform: translateY(-2px);
        }

        .category-chip.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        .category-chip.show-all {
            background: var(--secondary-color);
            border-color: var(--secondary-color);
            color: white;
            font-weight: 600;
        }

        .category-chip.show-all:hover {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .category-count {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .category-chip:not(.active) .category-count {
            background: var(--border);
            color: var(--text-secondary);
        }

        /* AI indicator for categories */
        .category-chip.ai-enhanced {
            border-color: #9c27b0;
            background: linear-gradient(45deg, var(--background), #f3e5f5);
        }

        .category-chip.ai-enhanced:hover {
            background: linear-gradient(45deg, var(--primary-color), #9c27b0);
        }

        .category-chip.ai-enhanced::after {
            content: "ü§ñ";
            font-size: 0.7em;
            margin-left: 4px;
        }

        /* Dark mode category styles */
        [data-theme="dark"] .category-container {
            background: var(--surface);
            border-bottom-color: var(--border);
        }

        [data-theme="dark"] .category-header h3 {
            color: var(--text-primary);
        }

        [data-theme="dark"] .category-close-btn:hover {
            background: #21262d;
            color: var(--text-primary);
        }

        [data-theme="dark"] .category-chip {
            background: var(--surface);
            border-color: var(--border);
            color: var(--text-primary);
        }

        [data-theme="dark"] .category-chip:hover {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        [data-theme="dark"] .category-chip.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
        }

        [data-theme="dark"] .category-chip:not(.active) .category-count {
            background: var(--border);
            color: var(--text-secondary);
        }

        [data-theme="dark"] .category-chip.ai-enhanced {
            background: linear-gradient(45deg, var(--surface), #3a1c3f);
            border-color: #9c27b0;
        }

        .search-box {
            position: relative;
            max-width: 600px;
            margin: 0 auto;
        }

        .search-input {
            width: 100%;
            padding: 15px 50px 15px 20px;
            border: 2px solid var(--border);
            border-radius: 25px;
            font-size: 16px;
            background: var(--background);
            transition: border-color 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .search-close-btn {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .search-close-btn:hover {
            background: var(--border);
            color: var(--text-primary);
            transform: translateY(-50%) scale(1.1);
        }

        /* Status */
        .status {
            padding: 20px 0;
            text-align: center;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
        }

        .status.loading {
            color: var(--secondary-color);
        }

        .status.error {
            color: #e74c3c;
        }

        .status.success {
            color: #27ae60;
        }

        /* Articles Grid - SMALLER TILES */
        .articles-section {
            padding: 40px 0;
            min-height: 60vh;
        }

        .articles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            /* REDUCED from 290px to 220px */
            gap: 18px;
            /* REDUCED from 24px to 18px */
            margin-top: 20px;
        }

        /* ORGANIC SHAPED TILES - SMALLER VERSION */
        .article-card {
            background: var(--surface);
            /* Organic rounded shape - different for each nth-child */
            border-radius: 32px 24px 32px 24px;
            overflow: visible;
            box-shadow: var(--shadow);
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border: 1px solid var(--border);
            position: relative;
            display: flex;
            flex-direction: column;
            transform-origin: center center;
        }

        /* Varying organic shapes for visual interest */
        .article-card:nth-child(3n+1) {
            border-radius: 28px 36px 28px 36px;
        }

        .article-card:nth-child(3n+2) {
            border-radius: 35px 25px 35px 25px;
        }

        .article-card:nth-child(3n+3) {
            border-radius: 30px 30px 40px 20px;
        }

        .article-card:nth-child(4n+1) {
            border-radius: 40px 20px 30px 30px;
        }

        .article-card:nth-child(5n+1) {
            border-radius: 25px 35px 25px 35px;
        }

        .article-card:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-8px) scale(1.02) rotate(1deg);
            border-color: var(--primary-color);
        }

        .article-card:nth-child(even):hover {
            transform: translateY(-8px) scale(1.02) rotate(-1deg);
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
        }

        /* AI categorization indicator on cards */
        .article-card.ai-categorized {
            border-color: #9c27b0;
        }

        .article-card.ai-categorized::before {
            content: "ü§ñ AI";
            position: absolute;
            top: 5px;
            left: 10px;
            background: rgba(156, 39, 176, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7em;
            z-index: 10;
        }

        /* Category correction button */
        .category-correction-btn {
            position: absolute;
            top: 5px;
            right: 50px;
            background: rgba(255, 152, 0, 0.9);
            color: white;
            border: none;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.7em;
            cursor: pointer;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .article-card:hover .category-correction-btn {
            opacity: 1;
        }

        /* Organic shaped image area - SMALLER */
        .article-image {
            width: 100%;
            height: 100px;
            /* REDUCED from 140px to 100px */
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            /* REDUCED from 2em to 1.5em */
            color: white;
            position: relative;
            overflow: hidden;
            /* Inherit the card's organic border radius for top corners */
            border-radius: inherit;
            border-bottom-left-radius: 16px;
            border-bottom-right-radius: 16px;
        }

        .article-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.4s ease, opacity 0.3s ease;
        }

        .article-image:hover img {
            transform: scale(1.08);
        }

        /* Compact content area with organic feel - SMALLER */
        .article-content {
            padding: 15px;
            /* REDUCED from 20px to 15px */
            flex: 1;
            cursor: pointer;
            border-radius: 0 0 inherit inherit;
        }

        .article-title {
            font-size: 1em;
            /* REDUCED from 1.1em to 1em */
            font-weight: 600;
            margin-bottom: 6px;
            /* REDUCED from 8px to 6px */
            line-height: 1.3;
            color: var(--text-primary);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-excerpt {
            color: var(--text-secondary);
            font-size: 0.8em;
            /* REDUCED from 0.9em to 0.8em */
            line-height: 1.4;
            margin-bottom: 10px;
            /* REDUCED from 12px to 10px */
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .article-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
            /* REDUCED from 8px to 6px */
            color: var(--text-secondary);
            font-size: 0.75em;
            /* REDUCED from 0.8em to 0.75em */
            margin-bottom: 6px;
            /* REDUCED from 8px to 6px */
        }

        .article-domain {
            font-weight: 500;
        }

        .article-date {
            opacity: 0.8;
        }

        .article-stats {
            display: flex;
            gap: 10px;
            /* REDUCED from 12px to 10px */
            font-size: 0.7em;
            /* REDUCED from 0.75em to 0.7em */
            color: var(--text-secondary);
        }

        /* Enhanced category badge on articles */
        .article-category {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: var(--primary-color);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.65em;
            font-weight: 500;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .article-category:hover {
            background: var(--secondary-color);
            transform: scale(1.05);
        }

        .article-category.ai-category {
            background: linear-gradient(45deg, var(--primary-color), #9c27b0);
        }

        .article-category.low-confidence {
            background: #ff9800;
        }

        /* Floating organic action buttons - SMALLER */
        .article-actions {
            position: absolute;
            top: 10px;
            /* REDUCED from 15px to 10px */
            right: 10px;
            /* REDUCED from 15px to 10px */
            display: flex;
            gap: 6px;
            /* REDUCED from 8px to 6px */
            opacity: 0 !important;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid var(--border);
            border-radius: 50%;
            /* Circular buttons for organic feel */
            padding: 8px;
            /* REDUCED from 12px to 8px */
            cursor: pointer;
            font-size: 14px;
            /* REDUCED from 16px to 14px */
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            min-width: 36px;
            /* REDUCED from 44px to 36px */
            height: 36px;
            /* REDUCED from 44px to 36px */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn:hover {
            transform: translateY(-4px) scale(1.15);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
            border-radius: 40% 60% 70% 30%;
        }

        .read-btn:hover {
            background: #e3f2fd;
            border-color: #2196f3;
            border-radius: 60% 40% 30% 70%;
        }

        .export-btn:hover {
            background: #e8f5e8;
            border-color: #4caf50;
            border-radius: 30% 70% 60% 40%;
        }

        .refresh-image-btn:hover {
            background: #fff3e0;
            border-color: #ff9800;
            border-radius: 40% 60% 40% 60%;
        }

        .delete-btn {
            color: #f44336;
        }

        .delete-btn:hover {
            background: #ffebee;
            border-color: #f44336;
            color: #d32f2f;
            border-radius: 70% 30% 40% 60%;
        }

        .article-card:hover .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
        }

        body.test-mode .article-actions {
            opacity: 1 !important;
            visibility: visible !important;
            background: rgba(255, 255, 0, 0.1);
            border: 2px dashed #ff9800;
            border-radius: 20px;
            padding: 5px;
        }

        .article-actions:hover {
            opacity: 1 !important;
            visibility: visible !important;
        }

        /* Reader View */
        .reader-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            overflow-y: auto;
        }

        .reader-overlay.active {
            display: block;
        }

        .reader-container {
            max-width: 800px;
            margin: 40px auto;
            background: var(--surface);
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.3);
        }

        .reader-header {
            padding: 30px;
            border-bottom: 1px solid var(--border);
            background: var(--background);
        }

        .reader-title {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 15px;
            line-height: 1.3;
        }

        .reader-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .reader-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .reader-content {
            padding: 40px;
            font-size: 1.1em;
            line-height: 1.8;
            max-width: none;
        }

        .reader-content h1,
        .reader-content h2,
        .reader-content h3 {
            margin: 30px 0 15px;
            color: var(--text-primary);
        }

        .reader-content p {
            margin-bottom: 20px;
        }

        .reader-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
        }

        .reader-content blockquote {
            border-left: 4px solid var(--primary-color);
            margin: 20px 0;
            padding: 15px 20px;
            background: var(--background);
            font-style: italic;
        }

        .close-reader {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-reader:hover {
            border-radius: 30% 70% 70% 30%;
            transform: scale(1.1);
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        /* Loading Animation */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }

            // Debug function to check elements
            debugElements() {
                console.log('üîß DEBUG: Checking sidebar elements...');

                const elements= {
                    'connectionStatusSidebar': document.getElementById('connectionStatusSidebar'),
                        'connectionIcon': document.getElementById('connectionIcon'),
                        'connectionText': document.getElementById('connectionText'),
                        'connectBtnSidebar': document.getElementById('connectBtnSidebar'),
                        'refreshNavBtn': document.getElementById('refreshNavBtn'),
                        'syncNavBtn': document.getElementById('syncNavBtn'),
                        'retryNavBtn': document.getElementById('retryNavBtn'),
                }

                ;

                for (const [name, element] of Object.entries(elements)) {
                    if (element) {
                        console.log(`‚úÖ $ {
                                name
                            }

                            : Found`);
                    }

                    else {
                        console.log(`‚ùå $ {
                                name
                            }

                            : NOT FOUND`);
                    }
                }

                return elements;
            }

            // Test authentication method
            testAuth() {
                console.log('üß™ Testing authentication...');
                console.log('üìç Redirect URI:', this.redirectUri);
                console.log('üîë Client ID:', this.clientId);

                // Test if we can generate PKCE parameters
                try {
                    const testVerifier=this.generateCodeVerifier();
                    console.log('‚úÖ Code verifier generation: OK');
                    console.log('‚úÖ Authentication setup: Ready');
                }

                catch (error) {
                    console.error('‚ùå Authentication setup failed:', error);
                }
            }

            updateConnectionStatus(connected) {
                // Use the correct IDs that actually exist in the HTML
                const connectBtn=document.getElementById('connectBtnSidebar');
                const connectIcon=document.getElementById('connectionIcon');
                const connectText=document.getElementById('connectionText');
                const connectionStatusSidebar=document.getElementById('connectionStatusSidebar');

                if (connected) {
                    if (connectIcon) connectIcon.textContent='‚úÖ';
                    if (connectText) connectText.textContent='Connected (PKCE+AI)';

                    if (connectBtn) {
                        connectBtn.style.background='#27ae60';
                        connectBtn.textContent='Connected ‚úÖ';
                    }

                    if (connectionStatusSidebar) {
                        connectionStatusSidebar.className='connection-status-sidebar connected';
                    }
                }

                else {
                    if (connectIcon) connectIcon.textContent='üîê';
                    if (connectText) connectText.textContent='Not Connected';

                    if (connectBtn) {
                        connectBtn.style.background='';
                        connectBtn.textContent='Secure Connect';
                    }

                    if (connectionStatusSidebar) {
                        connectionStatusSidebar.className='connection-status-sidebar disconnected';
                    }
                }
            }

            // ===== IMAGE CACHE SYSTEM =====

            loadImageCache() {
                try {
                    const cachedData=localStorage.getItem(this.cacheKey);

                    if (cachedData) {
                        const cache=JSON.parse(cachedData);

                        // Clean expired cache entries
                        const now=Date.now();
                        const expiryTime=this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                        for (const [key, entry] of Object.entries(cache)) {
                            if (now - entry.timestamp < expiryTime) {
                                this.imageCache.set(key, entry);
                            }
                        }

                        console.log(`üì¶ Loaded $ {
                                this.imageCache.size
                            }

                            cached images`);
                    }
                }

                catch (error) {
                    console.error('Error loading image cache:', error);
                    this.imageCache.clear();
                }
            }

            saveImageCache() {
                try {
                    const cacheObject= {}

                    ;

                    for (const [key, value] of this.imageCache.entries()) {
                        cacheObject[key]=value;
                    }

                    localStorage.setItem(this.cacheKey, JSON.stringify(cacheObject));

                    console.log(`üíæ Saved $ {
                            this.imageCache.size
                        }

                        images to cache`);
                }

                catch (error) {
                    console.error('Error saving image cache:', error);
                }
            }

            getCacheKey(article) {

                // Create a unique cache key based on article URL and title
                return `$ {
                    this.getDomain(article.url)
                }

                _$ {
                    article.url.substring(article.url.length - 20)
                }

                _$ {
                    article.title.substring(0, 30)
                }

                `.replace(/[^a-zA-Z0-9]/g, '_');
            }

            getCachedImage(article) {
                const key=this.getCacheKey(article);
                const cached=this.imageCache.get(key);

                if (cached) {
                    const now=Date.now();
                    const expiryTime=this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                    if (now - cached.timestamp < expiryTime) {
                        console.log(`‚úÖ Using cached image for: $ {
                                article.title.substring(0, 30)
                            }

                            ...`);
                        return cached.imageUrl;
                    }

                    else {
                        // Remove expired cache entry
                        this.imageCache.delete(key);

                        console.log(`‚è∞ Cache expired for: $ {
                                article.title.substring(0, 30)
                            }

                            ...`);
                    }
                }

                return null;
            }

            setCachedImage(article, imageUrl) {
                const key=this.getCacheKey(article);

                this.imageCache.set(key, {
                    imageUrl: imageUrl,
                    timestamp: Date.now(),
                    domain: this.getDomain(article.url),
                    title: article.title.substring(0, 50)
                });

            // Save to localStorage (debounced)
            clearTimeout(this.cacheSaveTimeout);
            this.cacheSaveTimeout=setTimeout(()=> this.saveImageCache(), 1000);

            console.log(`üíæ Cached image for: $ {
                    article.title.substring(0, 30)
                }

                ...`);
        }

        clearImageCache() {
            if (confirm('Clear all cached images?\n\nThis will:\n- Clear local cache\n- Remove stored images from articles\n- Force re-downloading images next time')) {
                // Clear local cache
                this.imageCache.clear();
                localStorage.removeItem(this.cacheKey);

                // Clear stored images from articles
                this.articles.forEach(article=> {
                        if (article.cachedImage) {
                            delete article.cachedImage;
                        }
                    });

                this.updateStatus('üóëÔ∏è All image data cleared. Images will be re-downloaded and stored for cross-device access.', 'success');
                console.log('üóëÔ∏è All image data cleared');

                // Refresh display
                this.displayArticles(this.articles);
            }
        }

        getCacheStats() {
            const timestamps=Array.from(this.imageCache.values()).map(entry=> entry.timestamp);

            return {
                total: this.imageCache.size,
                    memoryUsage: JSON.stringify(Object.fromEntries(this.imageCache)).length,
                    oldestEntry: timestamps.length > 0 ? Math.min(...timestamps): null,
                    newestEntry: timestamps.length > 0 ? Math.max(...timestamps): null
            }

            ;
        }

        // ===== CROSS-DEVICE IMAGE STORAGE =====

        // Convert image URL to base64 data for storage
        async convertImageToBase64(imageUrl) {
            try {
                console.log(`üì∏ Converting image to base64: $ {
                        imageUrl.substring(0, 50)
                    }

                    ...`);

                // Create a canvas to convert image to base64
                const img=new Image();
                img.crossOrigin='anonymous'; // Handle CORS

                return new Promise((resolve, reject)=> {
                        img.onload=()=> {
                            try {
                                const canvas=document.createElement('canvas');
                                const ctx=canvas.getContext('2d');

                                // Set canvas size (optimize for web display)
                                const maxWidth=400;
                                const maxHeight=250;

                                let {
                                    width, height
                                }

                                =img;

                                // Maintain aspect ratio while limiting size
                                if (width > maxWidth) {
                                    height=(height * maxWidth) / width;
                                    width=maxWidth;
                                }

                                if (height > maxHeight) {
                                    width=(width * maxHeight) / height;
                                    height=maxHeight;
                                }

                                canvas.width=width;
                                canvas.height=height;

                                // Draw and convert to base64
                                ctx.drawImage(img, 0, 0, width, height);
                                const base64=canvas.toDataURL('image/jpeg', 0.8); // Compress to 80% quality

                                // Check size limit
                                const sizeKB=Math.round(base64.length * 0.75 / 1024); // Rough base64 size calculation

                                if (sizeKB > this.maxImageSizeKB) {
                                    console.log(`‚ö†Ô∏è Image too large ($ {
                                                sizeKB
                                            }

                                            KB), using URL only`);

                                    resolve({
                                        url: imageUrl, size: sizeKB, stored: false
                                    });
                            }

                            else {
                                console.log(`‚úÖ Image converted ($ {
                                            sizeKB
                                        }

                                        KB): $ {
                                        imageUrl.substring(0, 30)
                                    }

                                    ...`);

                                resolve({
                                    base64: base64, url: imageUrl, size: sizeKB, stored: true
                                });
                        }
                    }

                    catch (error) {
                        console.log(`‚ùå Canvas conversion failed: $ {
                                error.message
                            }

                            `);

                        resolve({
                            url: imageUrl, stored: false
                        });
                }
            }

            ;

            img.onerror=()=> {
                console.log(`‚ùå Image load failed: $ {
                        imageUrl
                    }

                    `);

                resolve({
                    url: imageUrl, stored: false
                });
        }

        ;

        img.src=imageUrl;
        });
        }

        catch (error) {
            console.error('Image conversion error:', error);

            return {
                url: imageUrl, stored: false
            }

            ;
        }
        }

        // ENHANCED: More aggressive synced image prioritization with AI indicators
        displayArticles(articles) {
            const container=document.getElementById('articlesContainer');

            if (articles.length===0) {
                this.displayEmptyState();
                return;
            }

            // FIXED: Store what we're currently displaying
            this.currentDisplayedArticles=articles;

            // Check if mobile for performance optimization
            const isMobile=window.innerWidth <=768;

            let imagesFromBackup=0;
            let imagesFromCache=0;
            let imagesNeedLoading=0;

            console.log('üéØ DISPLAYING ARTICLES WITH IMPROVED AI CATEGORIES - Image Source Priority Check:');

            const articlesHTML=articles.map((article, displayIndex)=> {
                    // Use the display index for the currently shown articles
                    const index=displayIndex;

                    let imageHTML='';
                    let cacheStatus='loading';
                    let statusText='üîÑ Loading';
                    let imageSource='none';

                    // PRIORITY 1: Synced base64 images (HIGHEST PRIORITY - guaranteed same across devices)
                    if (article.cachedImage && article.cachedImage.base64) {
                        imageHTML=this.createImageHTML(article.cachedImage.base64, true);
                        cacheStatus='synced';
                        statusText='üåê Synced';
                        imageSource='synced_base64';
                        imagesFromBackup++;

                        console.log(`‚úÖ $ {
                                displayIndex
                            }

                            : Using SYNCED base64 for "${article.title.substring(0, 30)}..."($ {
                                    Math.round(article.cachedImage.size)
                                }

                                KB)`);
                    }

                    // PRIORITY 2: Synced URLs (still cross-device but less reliable)
                    else if (article.cachedImage && article.cachedImage.url && !article.cachedImage.base64) {
                        imageHTML=this.createImageHTML(article.cachedImage.url, true);
                        cacheStatus='synced';
                        statusText='üîó Synced URL';
                        imageSource='synced_url';
                        imagesFromBackup++;

                        console.log(`‚úÖ $ {
                                displayIndex
                            }

                            : Using SYNCED URL for "${article.title.substring(0, 30)}..." `);
                    }

                    // PRIORITY 3: Local cache (device specific)
                    else if (this.getCachedImage(article)) {
                        imageHTML=this.createImageHTML(this.getCachedImage(article), true);
                        cacheStatus='cached';
                        statusText='üíæ Local Cache';
                        imageSource='local_cache';
                        imagesFromCache++;

                        console.log(`‚ö° $ {
                                displayIndex
                            }

                            : Using LOCAL cache for "${article.title.substring(0, 30)}..." `);
                    }

                    // PRIORITY 4: Article metadata (extract and sync immediately)
                    else if (this.getBestArticleImage(article)) {
                        const savedImage=this.getBestArticleImage(article);
                        imageHTML=this.createImageHTML(savedImage, false);
                        cacheStatus='metadata';
                        statusText='üìÑ Metadata';
                        imageSource='metadata';

                        console.log(`üìÑ $ {
                                displayIndex
                            }

                            : Using METADATA image for "${article.title.substring(0, 30)}..." - will sync`);

                        // Store this image for cross-device sync IMMEDIATELY
                        setTimeout(()=> this.setArticleImageAndCache(article, index, savedImage, 'saved'), 100);
                    }

                    // PRIORITY 5: Need to extract from website (LAST resort)
                    else {
                        imageHTML=this.createPlaceholderHTML();
                        cacheStatus='loading';
                        statusText=isMobile ? 'üì± Loading...' : 'üîÑ Loading';
                        imageSource='needs_extraction';
                        imagesNeedLoading++;

                        console.log(`‚ùå $ {
                                displayIndex
                            }

                            : NO image found for "${article.title.substring(0, 30)}..." - needs extraction`);
                    }

                    // AI categorization indicators
                    const aiEnhanced=article.aiEnhanced ? 'ai-categorized' : '';

                    const categoryData=this.improvedCategorizer.categoryKeywords[article.category] || {
                        icon: 'üìÑ'
                    }

                    ;

                    // Enhanced category badge with correction button
                    const categoryBadge=article.category ? ` <div class="article-category ${article.aiEnhanced ? 'ai-category' : ''} ${article.categoryConfidence < 30 ? 'low-confidence' : ''}"
                    onclick="event.stopPropagation(); webReader.openCategoryCorrection(this.closest('.article-card').dataset.article, ${displayIndex})"

                    title="Click to correct category (Current: ${article.category}, Score: ${article.categoryScore || 0})" > <span>$ {
                        categoryData.icon
                    }

                    </span> <span>$ {
                        article.category
                    }

                    </span> $ {
                        article.aiEnhanced ? '<span>ü§ñ</span>' : ''
                    }

                    </div> ` : '';

                    return ` <div class="article-card ${aiEnhanced}" data-index="${index}" data-display-index="${displayIndex}" data-image-source="${imageSource}" data-article='${JSON.stringify(article)}' > <div class="article-image" id="image-${index}" > $ {
                        imageHTML
                    }

                    <div class="cache-indicator ${cacheStatus} ${article.aiEnhanced ? 'ai-categorized' : ''}" > $ {
                        statusText
                    }

                    </div> </div> <div class="article-content" onclick="webReader.openReaderByDisplayIndex(${displayIndex})" > $ {
                        categoryBadge
                    }

                    <h2 class="article-title" >$ {
                        this.escapeHtml(article.title)
                    }

                    </h2> <p class="article-excerpt" >$ {
                        this.escapeHtml(article.excerpt)
                    }

                    </p> <div class="article-meta" > <span class="article-domain" >üåê $ {
                        this.getDomain(article.url)
                    }

                    </span> <span class="article-date" >üìÖ $ {
                        this.formatDate(article.dateAdded)
                    }

                    </span> </div> <div class="article-stats" > <span>‚è±Ô∏è $ {
                        article.readTime || 1
                    }

                    min read</span> <span>üìù $ {
                        article.wordCount || 0
                    }

                    words</span> $ {
                        article.categoryScore ? `<span>ü§ñ $ {
                            article.categoryScore
                        }

                        </span>` : ''
                    }

                    </div> </div> <div class="article-actions" > <button class="action-btn read-btn" onclick="event.stopPropagation(); webReader.openReaderByDisplayIndex(${displayIndex})" title="Read article" > üìñ </button> <button class="action-btn refresh-image-btn" onclick="event.stopPropagation(); webReader.refreshSingleImage(${index}, ${displayIndex})" title="Refresh this image" > üñºÔ∏è </button> <button class="action-btn export-btn" onclick="event.stopPropagation(); webReader.exportArticleByDisplayIndex(${displayIndex})" title="Export article" > üì§ </button> <button class="action-btn delete-btn" onclick="event.stopPropagation(); webReader.deleteArticleByDisplayIndex(${displayIndex})" title="Delete article" > üóëÔ∏è </button> </div> </div> `
                }).join('');

            container.innerHTML=`<div class="articles-grid">$ {
                articlesHTML
            }

            </div>`;

            // Enhanced status reporting with AI info
            const totalReady=imagesFromBackup+imagesFromCache;
            const aiEnhancedCount=articles.filter(a=> a.aiEnhanced).length;

            console.log(`üìä IMAGE SUMMARY: $ {
                    imagesFromBackup
                }

                synced, $ {
                    imagesFromCache
                }

                cached, $ {
                    imagesNeedLoading
                }

                need loading`);

            console.log(`ü§ñ AI SUMMARY: $ {
                    aiEnhancedCount
                }

                /$ {
                    articles.length
                }

                articles AI-enhanced`);

            if (imagesNeedLoading===0) {
                const aiText=aiEnhancedCount>0 ? ` ($ {
                        aiEnhancedCount
                    }

                    AI-enhanced)` : '';

                const message=isMobile ? `üì± ALL images ready ! $ {
                    totalReady
                }

                /$ {
                    articles.length
                }

                synced perfectly ‚ú®$ {
                    aiText
                }

                ` : `‚úÖ ALL images ready ! $ {
                    imagesFromBackup
                }

                synced,
                $ {
                    imagesFromCache
                }

                cached ‚ú®$ {
                    aiText
                }

                `;
                this.updateStatus(message, 'success');
            }

            else {
                const aiText=aiEnhancedCount>0 ? ` ($ {
                        aiEnhancedCount
                    }

                    AI-categorized)` : '';

                const message=isMobile ? `üì± $ {
                    totalReady
                }

                ready instantly,
                extracting $ {
                    imagesNeedLoading
                }

                more...$ {
                    aiText
                }

                ` : `‚ö° $ {
                    totalReady
                }

                ready instantly,
                extracting $ {
                    imagesNeedLoading
                }

                more...$ {
                    aiText
                }

                `;
                this.updateStatus(message, 'loading');

                // Load missing images - prioritize on mobile for faster completion
                if (isMobile) {
                    setTimeout(()=> this.loadMissingImages(articles), 500); // Start faster on mobile
                }

                else {
                    this.loadMissingImages(articles);
                }
            }
        }

        createImageHTML(imageUrl, fromCache=false) {
            return ` <img src="${imageUrl}"
            alt="Article image"
            style="
 opacity: 0;
            transition: opacity 0.8s ease;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: inherit;
            "
 onload="
 this.style.opacity='1';
            console.log('‚úÖ Image loaded ${fromCache ? ' from cache' : ' successfully'}');
            " 
 onerror="
 console.log('‚ö†Ô∏è Image failed, tracking for retry');
            const cardElement=this.closest('.article-card');

            if (cardElement) {
                const index=parseInt(cardElement.dataset.index);

                if ( !isNaN(index)) {
                    webReader.failedImages.add(index);
                    const indicator=this.parentElement.querySelector('.cache-indicator');

                    if (indicator) {
                        indicator.textContent='‚ùå Failed';
                        indicator.className='cache-indicator error';
                    }
                }
            }

            this.src='https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
            ">
 `;
        }

        createPlaceholderHTML() {
            return ` <div style="
 width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #f0f0f0 25%, transparent 25%),
                linear-gradient(-45deg, #f0f0f0 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #f0f0f0 75%),
                linear-gradient(-45deg, transparent 75%, #f0f0f0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            animation: shimmer 1.5s ease-in-out infinite;
            ">
 <div style="text-align: center;"><div style="font-size: 1.2em; margin-bottom: 5px;">üñºÔ∏è</div><div style="font-size: 0.7em;">Loading image...</div></div></div>`;
        }

        // Mobile-optimized image loading with enhanced extraction
        async loadMissingImages(articles) {
            console.log('üé® ENHANCED IMAGE LOADER - Getting REAL images with smart fallbacks...');

            const articlesNeedingImages=articles.filter((article, index)=> {
                    // Check both stored backup images and local cache
                    const hasStoredImage=article.cachedImage && article.cachedImage.base64;
                    const hasCachedImage=this.getCachedImage(article);
                    return !hasStoredImage && !hasCachedImage;
                });

            if (articlesNeedingImages.length===0) {
                this.updateStatus(`‚úÖ All images loaded with enhanced quality !`, 'success');
                return;
            }

            const isMobile=window.innerWidth <=768;
            let successCount=0;
            const totalNew=articlesNeedingImages.length;

            console.log(`üîÑ Loading $ {
                    totalNew
                }

                images with enhanced extraction$ {
                    isMobile ? ' (mobile optimized)' : ''
                }

                `);

            // Mobile optimization: smaller batches for better performance, but same quality images
            const batchSize=isMobile ? 2 : 5;
            const delayBetweenImages=isMobile ? 800 : 300;

            for (let i=0; i < articlesNeedingImages.length; i +=batchSize) {
                const batch=articlesNeedingImages.slice(i, i + batchSize);

                // Process batch with enhanced extraction
                await Promise.all(batch.map(async (article)=> {
                            const originalIndex=articles.findIndex(a=> a===article);

                            try {
                                const success=await this.extractAndCacheRealImage(article, originalIndex);
                                if (success) successCount++;
                            }

                            catch (error) {
                                console.error(`Failed to extract image for article $ {
                                        originalIndex
                                    }

                                    :`, error);
                                // Use smart fallback for failed extractions
                                const smartFallback=this.getCategoryBasedImage(article, originalIndex);
                                this.setArticleImageAndCache(article, originalIndex, smartFallback, 'smart_fallback');
                                successCount++;
                            }
                        }));

                // Update progress with enhanced messaging
                const progress=Math.round(((i + batchSize) / totalNew) * 100);

                if (isMobile) {
                    this.updateStatus(`üì± Loading quality images... $ {
                            Math.min(i + batchSize, totalNew)
                        }

                        /$ {
                            totalNew
                        }

                        `, 'loading');
                }

                else {
                    this.updateStatus(`üéØ Loading enhanced images... $ {
                            Math.min(i + batchSize, totalNew)
                        }

                        /$ {
                            totalNew
                        }

                        ($ {
                                progress
                            }

                            %)`, 'loading');
                }

                // Delay between batches
                if (i + batchSize < articlesNeedingImages.length) {
                    await new Promise(resolve=> setTimeout(resolve, delayBetweenImages));
                }
            }

            const totalCached=this.imageCache.size;

            if (isMobile) {
                this.updateStatus(`üì± $ {
                        successCount
                    }

                    quality images loaded ! üéâ`, 'success');
            }

            else {
                this.updateStatus(`‚úÖ Loaded $ {
                        successCount
                    }

                    /$ {
                        totalNew
                    }

                    enhanced images ! ($ {
                            totalCached
                        }

                        total cached)`, 'success');
            }

            console.log(`üé® Enhanced image loading complete: $ {
                    successCount
                }

                /$ {
                    totalNew
                }

                quality images loaded`);
        }

        // ENHANCED: Force backup update when images are stored
        async setArticleImageAndCache(article, index, imageUrl, source) {
            const imageElement=document.getElementById(`image-$ {
                    index
                }

                `);
            if ( !imageElement) return;

            // Update the DOM immediately
            imageElement.innerHTML=this.createImageHTML(imageUrl, false);

            // Update cache indicator
            const cacheIndicator=imageElement.querySelector('.cache-indicator');

            if (cacheIndicator) {
                if (source==='extracted') {
                    cacheIndicator.textContent='üåê Fresh';
                    cacheIndicator.className='cache-indicator fresh';
                }

                else if (source==='refreshed') {
                    cacheIndicator.textContent='üîÑ Refreshed';
                    cacheIndicator.className='cache-indicator fresh';
                }

                else {
                    cacheIndicator.textContent='üíæ Cached';
                    cacheIndicator.className='cache-indicator cached';
                }
            }

            // Store in local cache
            this.setCachedImage(article, imageUrl);

            // ENHANCED: Always store base64 data for cross-device sync (not just extracted images)
            if (this.storeImagesInBackup && (source==='extracted' || source==='saved' || source==='fallback' || source==='refreshed')) {
                try {
                    console.log(`üîÑ Converting image for cross-device storage: $ {
                            article.title.substring(0, 30)
                        }

                        ...`);
                    const imageData=await this.convertImageToBase64(imageUrl);

                    if (imageData.stored) {
                        // Find the article in our array and add image data
                        const articleIndex=this.articles.findIndex(a=> a.url===article.url);

                        if (articleIndex !==-1) {
                            this.articles[articleIndex].cachedImage= {
                                base64: imageData.base64,
                                    url: imageData.url,
                                    timestamp: Date.now(),
                                    size: imageData.size,
                                    source: source
                            }

                            ;

                            console.log(`üíæ Stored $ {
                                    imageData.size
                                }

                                KB image in backup for cross-device sync`);

                            // Update cache indicator to show it's stored for sync
                            if (cacheIndicator) {
                                cacheIndicator.textContent='üåê Synced';
                                cacheIndicator.className='cache-indicator synced';
                            }

                            // IMMEDIATELY save to OneDrive to ensure sync
                            if (this.accessToken) {
                                console.log('üíæ Auto-saving to OneDrive for instant cross-device sync...');

                                try {
                                    await this.updateOneDriveBackup();
                                    console.log('‚úÖ OneDrive backup updated with new image');
                                }

                                catch (error) {
                                    console.error('‚ö†Ô∏è Failed to auto-save backup:', error);
                                }
                            }
                        }
                    }

                    else {
                        console.log(`‚ö†Ô∏è Image too large for cross-device storage: $ {
                                imageData.size
                            }

                            KB`);
                    }
                }

                catch (error) {
                    console.error('Error storing image for cross-device sync:', error);
                }
            }
        }

        // Extract and cache image with enhanced strategies
        async extractAndCacheRealImage(article, index) {
            const imageElement=document.getElementById(`image-$ {
                    index
                }

                `);
            if ( !imageElement) return false;

            console.log(`üéØ Enhanced image extraction for: $ {
                    this.getDomain(article.url)
                }

                `);

            // Strategy 1: Try saved article images first (fastest)
            const savedImage=this.getBestArticleImage(article);

            if (savedImage) {
                console.log(`‚úÖ Using saved image: $ {
                        article.title.substring(0, 30)
                    }

                    ...`);
                this.setArticleImageAndCache(article, index, savedImage, 'saved');
                return true;
            }

            // Strategy 2: Enhanced real-time extraction from website
            try {
                const extractedImage=await this.fetchRealImageFromWebsite(article.url);

                if (extractedImage) {
                    console.log(`‚úÖ Extracted real image: $ {
                            article.title.substring(0, 30)
                        }

                        ...`);
                    this.setArticleImageAndCache(article, index, extractedImage, 'extracted');
                    return true;
                }
            }

            catch (error) {
                console.log(`‚ö†Ô∏è Could not extract from website: $ {
                        error.message
                    }

                    `);
            }

            // Strategy 3: Use enhanced smart fallback system
            console.log(`üé® Using enhanced smart fallback: $ {
                    article.title.substring(0, 30)
                }

                ...`);
            const smartFallback=this.getCategoryBasedImage(article, index);
            this.setArticleImageAndCache(article, index, smartFallback, 'smart_fallback');
            return true;
        }

        // ENHANCED: Load articles with automatic token refresh and AI categorization
        async loadArticles() {
            // Ensure we have a valid token
            const hasValidToken=await this.ensureValidToken();

            if ( !hasValidToken) {
                this.updateConnectionStatus(false);
                this.updateStatus('Authentication expired. Please reconnect.', 'error');
                return;
            }

            try {
                this.updateStatus('Loading articles with improved AI categorization... ‚è≥', 'loading');

                const listResponse=await fetch('https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket:/children', {
                    headers: {
                        'Authorization': `Bearer $ {
                            this.accessToken
                        }

                        `,
                        'Content-Type': 'application/json'
                    }
                });

            if ( !listResponse.ok) {
                if (listResponse.status===401) {
                    // Try to refresh token
                    const refreshSuccess=await this.refreshAccessToken();

                    if (refreshSuccess) {
                        // Retry the request with new token
                        return this.loadArticles();
                    }

                    else {
                        this.clearTokens();
                        this.updateConnectionStatus(false);
                        this.updateStatus('Session expired. Please reconnect.', 'error');
                        return;
                    }
                }

                throw new Error(`Failed to list files: $ {
                        listResponse.status
                    }

                    `);
            }

            const fileList=await listResponse.json();
            const backupFiles=fileList.value.filter(file=> file.name.startsWith ('mypocket-backup-') && file.name.endsWith ('.json'));

            if (backupFiles.length===0) {
                this.updateStatus('No backup files found. Save some articles with the browser extension first.', 'error');
                this.displayEmptyState();
                return;
            }

            const latestFile=backupFiles.sort((a, b)=> new Date(b.lastModifiedDateTime) - new Date(a.lastModifiedDateTime))[0];

            const downloadResponse=await fetch(`https: //graph.microsoft.com/v1.0/me/drive/items/${latestFile.id}/content`, {

                headers: {
                    'Authorization': `Bearer $ {
                        this.accessToken
                    }

                    `
                }
            });

        if ( !downloadResponse.ok) {
            throw new Error(`Failed to download backup: $ {
                    downloadResponse.status
                }

                `);
        }

        const backupContent=await downloadResponse.text();
        const backup=JSON.parse(backupContent);

        this.articles=backup.articles || [];
        this.currentDisplayedArticles=this.articles; // Initialize displayed articles

        // IMPROVED AI categorization on load
        console.log('ü§ñ Starting improved AI categorization...');
        this.updateStatus('ü§ñ AI is analyzing your articles with improved algorithms...', 'loading');

        // Process categorization in background for better UX
        setTimeout(async ()=> {
                await this.recategorizeAllWithAI();

                // Update sidebar counts
                this.updateArticleCounts();

                this.displayArticles(this.articles);

                const cacheStats=this.getCacheStats();
                const storedImages=this.articles.filter(a=> a.cachedImage).length;
                const aiEnhancedCount=this.articles.filter(a=> a.aiEnhanced).length;

                this.updateStatus(`ü§ñ Loaded $ {
                        this.articles.length
                    }

                    articles with improved AI categorization ($ {
                            storedImages
                        }

                        with stored images, $ {
                            aiEnhancedCount
                        }

                        AI-enhanced)`, 'success');
            }

            , 100);

        }

        catch (error) {
            console.error('Error loading articles:', error);

            this.updateStatus(`Error loading articles: $ {
                    error.message
                }

                `, 'error');
        }
        }

        displayEmptyState() {
            const container=document.getElementById('articlesContainer');
            container.innerHTML=` <div class="empty-state"><div class="empty-state-icon">ü§ñ</div><h3>No articles found</h3><p>Use the MyPocket browser extension to save articles,
            then refresh this page for improved AI categorization !</p></div>`;
        }

        // Enhanced search with AI category awareness
        searchArticles(query) {

            // Clear any active category filter when searching
            if (this.activeCategory && query.trim() !=='') {
                this.activeCategory=null;
                this.updateCategoryUI();
            }

            if ( !query || query.trim()==='') {
                this.currentDisplayedArticles=this.articles;
                this.displayArticles(this.articles);

                if (this.articles.length > 0) {
                    this.updateStatus(`Showing all $ {
                            this.articles.length
                        }

                        articles`, 'success');
                }

                return;
            }

            const searchTerm=query.toLowerCase().trim();
            console.log(`üîç Improved AI-powered search for: "${searchTerm}" `);

            const filtered=this.articles.filter(article=> {
                    // Search in title (always exists)
                    const titleMatch=article.title && article.title.toLowerCase().includes(searchTerm);

                    // Search in excerpt (usually exists)
                    const excerptMatch=article.excerpt && article.excerpt.toLowerCase().includes(searchTerm);

                    // Search in various content fields
                    const contentFields=['content', 'textContent', 'html', 'fullContent', 'body', 'readableContent'];
                    const contentMatch=contentFields.some(field=> article[field] && typeof article[field]==='string' && article[field].toLowerCase().includes(searchTerm));

                    // Search in author (if exists)
                    const authorMatch=article.author && article.author.toLowerCase().includes(searchTerm);

                    // Search in domain
                    const domainMatch=this.getDomain(article.url).toLowerCase().includes(searchTerm);

                    // Search in URL
                    const urlMatch=article.url && article.url.toLowerCase().includes(searchTerm);

                    // Search in tags or categories (if they exist)
                    const tagsMatch=article.tags && Array.isArray(article.tags) && article.tags.some(tag=> tag.toLowerCase().includes(searchTerm));

                    // IMPROVED: Search in category and category keywords
                    if ( !article.category) {
                        this.categorizeArticle(article);
                    }

                    const categoryMatch=article.category && article.category.toLowerCase().includes(searchTerm);

                    // Smart category keyword matching
                    let categoryKeywordMatch=false;

                    if (article.category && this.improvedCategorizer.categoryKeywords[article.category]) {
                        const categoryData=this.improvedCategorizer.categoryKeywords[article.category];
                        const allKeywords=[...(categoryData.primary || []), ...(categoryData.secondary || [])];
                        categoryKeywordMatch=allKeywords.some(keyword=> keyword.toLowerCase().includes(searchTerm) || searchTerm.includes(keyword.toLowerCase()));
                    }

                    return titleMatch || excerptMatch || contentMatch || authorMatch || domainMatch || urlMatch || tagsMatch || categoryMatch || categoryKeywordMatch;
                });

            console.log(`üéØ Improved AI search results: $ {
                    filtered.length
                }

                /$ {
                    this.articles.length
                }

                articles`);

            // FIXED: Store the filtered articles and display them
            this.currentDisplayedArticles=filtered;
            this.displayArticles(filtered);

            if (filtered.length===0) {
                this.updateStatus(`ü§ñ No articles found matching "${query}" . Try different keywords or categories.`, 'error');
            }

            else if (filtered.length===1) {
                this.updateStatus(`üîç Found 1 article matching "${query}" `, 'success');
            }

            else {
                this.updateStatus(`üîç Found $ {
                        filtered.length
                    }

                    articles matching "${query}" `, 'success');
            }
        }

        // FIXED: New functions that work with display indices
        openReaderByDisplayIndex(displayIndex) {
            const article=this.currentDisplayedArticles[displayIndex];

            if ( !article) {
                console.error('Article not found at display index:', displayIndex);
                return;
            }

            this.currentArticle=article;
            const overlay=document.getElementById('readerOverlay');

            // Set title and meta info
            document.getElementById('readerTitle').textContent=article.title;
            document.getElementById('readerDate').textContent=this.formatDate(article.dateAdded);
            document.getElementById('readerDomain').textContent=this.getDomain(article.url);

            document.getElementById('readerTime').textContent=`$ {
                article.readTime || 1
            }

            min read`;

            // Show loading state first
            document.getElementById('readerContent').innerHTML=` <div style="text-align: center; padding: 40px;"><div class="loading-spinner" style="margin: 0 auto 20px;"></div><p>Checking for article content...</p></div>`;

            overlay.classList.add('active');
            document.body.style.overflow='hidden';

            // Try to get content, fetch if needed
            setTimeout(()=> this.loadArticleContent(article), 100);
        }

        exportArticleByDisplayIndex(displayIndex) {
            const article=this.currentDisplayedArticles[displayIndex];

            if ( !article) {
                console.error('Article not found at display index:', displayIndex);
                return;
            }

            try {
                const html=this.createArticleHTML(article);

                const filename=`$ {
                    this.sanitizeFilename(article.title)
                }

                .html`;
                this.downloadFile(html, filename, 'text/html');
                this.updateStatus(`üì§ Article "${article.title}" exported successfully !`, 'success');
            }

            catch (error) {
                console.error('Error exporting article:', error);

                this.updateStatus(`‚ùå Failed to export article: $ {
                        error.message
                    }

                    `, 'error');
            }
        }

        async deleteArticleByDisplayIndex(displayIndex) {
            const article=this.currentDisplayedArticles[displayIndex];

            if ( !article) {
                console.error('Article not found at display index:', displayIndex);
                return;
            }

            if (confirm(`Delete "${article.title}" ?\n\nThis will permanently remove the article from your OneDrive backup.`)) {
                try {
                    // Find the original index in the main articles array
                    const originalIndex=this.articles.findIndex(a=> a.url===article.url && a.title===article.title);

                    if (originalIndex===-1) {
                        throw new Error('Could not find article in main collection');
                    }

                    // Remove from cache
                    const cacheKey=this.getCacheKey(article);
                    this.imageCache.delete(cacheKey);
                    this.saveImageCache();

                    // Remove from main articles array
                    this.articles.splice(originalIndex, 1);

                    // Remove from currently displayed articles
                    this.currentDisplayedArticles.splice(displayIndex, 1);

                    if (this.accessToken) {
                        this.updateStatus('Updating OneDrive backup...', 'loading');
                        await this.updateOneDriveBackup();

                        this.updateStatus(`‚úÖ Article deleted and backup updated. $ {
                                this.articles.length
                            }

                            articles remaining.`, 'success');
                    }

                    else {
                        this.updateStatus(`‚ùå Article deleted locally but OneDrive backup not updated (not connected).`, 'error');
                    }

                    // Refresh the display with current articles
                    this.displayArticles(this.currentDisplayedArticles);

                }

                catch (error) {
                    console.error('Error deleting article:', error);

                    this.updateStatus(`‚ùå Failed to delete article: $ {
                            error.message
                        }

                        `, 'error');
                }
            }
        }

        // NEW: Refresh a single image that's working but wrong
        async refreshSingleImage(originalIndex, displayIndex) {
            const article=this.currentDisplayedArticles[displayIndex];

            if ( !article) {
                console.error('Article not found at display index:', displayIndex);
                return;
            }

            const imageElement=document.getElementById(`image-$ {
                    originalIndex
                }

                `);

            if ( !imageElement) {
                console.error('Image element not found for index:', originalIndex);
                return;
            }

            // Confirm the action
            const proceed=confirm(`Refresh image for "${article.title.substring(0, 50)}..." ?\n\nThis will:\n‚Ä¢ Clear the current image\n‚Ä¢ Try to find a better image from the original source\n‚Ä¢ Use alternative sources if needed\n\nProceed?`);

            if ( !proceed) return;

            console.log(`üîÑ Refreshing single image for: $ {
                    article.title.substring(0, 30)
                }

                ...`);

            // Update status immediately
            const cacheIndicator=imageElement.querySelector('.cache-indicator');

            if (cacheIndicator) {
                cacheIndicator.textContent='üîÑ Refreshing...';
                cacheIndicator.className='cache-indicator loading';
            }

            // Show loading placeholder
            imageElement.innerHTML=` $ {
                this.createPlaceholderHTML()
            }

            <div class="cache-indicator loading">üîÑ Refreshing... </div>`;

            try {
                // Clear any existing cache for this article
                const cacheKey=this.getCacheKey(article);
                this.imageCache.delete(cacheKey);

                // Clear stored image from article
                const mainArticleIndex=this.articles.findIndex(a=> a.url===article.url && a.title===article.title);

                if (mainArticleIndex !==-1 && this.articles[mainArticleIndex].cachedImage) {
                    delete this.articles[mainArticleIndex].cachedImage;
                }

                // Try multiple strategies to get a fresh, correct image
                let success=false;

                // Strategy 1: Try to extract fresh from the original website
                try {
                    console.log(`üåê Attempting fresh extraction from: $ {
                            this.getDomain(article.url)
                        }

                        `);
                    const extractedImage=await this.fetchRealImageFromWebsite(article.url);

                    if (extractedImage) {
                        console.log(`‚úÖ Fresh extraction successful: $ {
                                article.title.substring(0, 30)
                            }

                            ...`);
                        await this.setArticleImageAndCache(article, originalIndex, extractedImage, 'refreshed');
                        success=true;
                    }
                }

                catch (error) {
                    console.log(`‚ö†Ô∏è Fresh extraction failed: $ {
                            error.message
                        }

                        `);
                }

                // Strategy 2: Try alternative extraction methods
                if ( !success) {
                    try {
                        console.log(`üîÑ Trying alternative methods...`);
                        success=await this.tryAlternativeImageStrategies(article, originalIndex);
                    }

                    catch (error) {
                        console.log(`‚ö†Ô∏è Alternative methods failed: $ {
                                error.message
                            }

                            `);
                    }
                }

                // Strategy 3: Use a new category-based image (last resort)
                if ( !success) {
                    console.log(`üé® Using refreshed category image...`);
                    const fallbackImage=this.getCategoryBasedImage(article, originalIndex + Date.now()); // Add timestamp for variation
                    await this.setArticleImageAndCache(article, originalIndex, fallbackImage, 'refreshed');
                    success=true;
                }

                if (success) {
                    this.updateStatus(`‚úÖ Image refreshed successfully for "${article.title.substring(0, 40)}..." `, 'success');

                    // Update backup if connected
                    if (this.accessToken) {
                        try {
                            await this.updateOneDriveBackup();
                            console.log('‚úÖ Updated backup with refreshed image');
                        }

                        catch (error) {
                            console.error('‚ö†Ô∏è Failed to update backup:', error);
                        }
                    }
                }

                else {
                    throw new Error('All refresh strategies failed');
                }

            }

            catch (error) {
                console.error('Single image refresh error:', error);

                this.updateStatus(`‚ùå Failed to refresh image: $ {
                        error.message
                    }

                    `, 'error');

                // Show error state
                const errorCacheIndicator=imageElement.querySelector('.cache-indicator');

                if (errorCacheIndicator) {
                    errorCacheIndicator.textContent='‚ùå Refresh Failed';
                    errorCacheIndicator.className='cache-indicator error';
                }
            }
        }

        async retryFailedImages() {
            if ( !this.accessToken) {
                this.updateStatus('‚ùå Please connect to OneDrive first', 'error');
                return;
            }

            // MUCH MORE CONSERVATIVE: Only target explicitly failed images
            const articlesWithFailedImages=this.articles.filter((article, index)=> {
                    // Only consider images that are explicitly in our failed set
                    // OR have explicit "Failed" indicator - nothing else
                    const isExplicitlyFailed=this.failedImages.has(index);

                    const imageElement=document.getElementById(`image-$ {
                            index
                        }

                        `);
                    const cacheIndicator=imageElement?.querySelector('.cache-indicator');
                    const hasFailedIndicator=cacheIndicator && cacheIndicator.textContent.includes('‚ùå Failed');

                    // ONLY process if explicitly marked as failed - be very conservative
                    return isExplicitlyFailed || hasFailedIndicator;
                });

            if (articlesWithFailedImages.length===0) {
                this.updateStatus('‚úÖ No explicitly failed images found. Use "Sync Images" for broader updates.', 'success');
                return;
            }

            // Show confirmation with exact count
            const proceed=confirm(`Retry $ {
                    articlesWithFailedImages.length
                }

                explicitly failed images?\n\nThis will ONLY affect images marked with "‚ùå Failed" status.\nWorking images will NOT be touched.\n\nProceed?`);

            if ( !proceed) {
                this.updateStatus('Retry cancelled by user', 'error');
                return;
            }

            this.updateStatus(`üîÑ Retrying ONLY $ {
                    articlesWithFailedImages.length
                }

                explicitly failed images...`, 'loading');

            let retriedCount=0;
            let successCount=0;

            for (const article of articlesWithFailedImages) {
                const originalIndex=this.articles.findIndex(a=> a===article);
                if (originalIndex===-1) continue;

                try {
                    retriedCount++;

                    console.log(`üîÑ Retrying FAILED image $ {
                            retriedCount
                        }

                        /$ {
                            articlesWithFailedImages.length
                        }

                        : $ {
                            article.title.substring(0, 30)
                        }

                        ...`);

                    // Clear from failed set
                    this.failedImages.delete(originalIndex);

                    // Try to recover the failed image
                    const success=await this.tryAlternativeImageStrategies(article, originalIndex);

                    if (success) {
                        successCount++;

                        console.log(`‚úÖ Successfully recovered image: $ {
                                article.title.substring(0, 30)
                            }

                            ...`);
                    }

                    // Update progress
                    this.updateStatus(`üîÑ Retrying failed images... $ {
                            retriedCount
                        }

                        /$ {
                            articlesWithFailedImages.length
                        }

                        ($ {
                                successCount
                            }

                            recovered)`, 'loading');

                    // Small delay to prevent overwhelming
                    await new Promise(resolve=> setTimeout(resolve, 300));

                }

                catch (error) {
                    console.error(`Failed to retry image for $ {
                            article.title
                        }

                        :`, error);
                    this.failedImages.add(originalIndex);
                }
            }

            const message=successCount>0 ? `‚úÖ Retry complete ! Recovered $ {
                successCount
            }

            /$ {
                articlesWithFailedImages.length
            }

            failed images. Working images were untouched.` : `‚ö†Ô∏è Could not recover the failed images - they may be permanently unavailable.`;

            this.updateStatus(message, successCount > 0 ? 'success' : 'error');

            // Only update backup if we actually recovered images
            if (successCount > 0 && this.accessToken) {
                try {
                    await this.updateOneDriveBackup();
                    console.log('‚úÖ OneDrive backup updated with recovered images');
                }

                catch (error) {
                    console.error('‚ö†Ô∏è Failed to save recovered images to backup:', error);
                }
            }
        }

        // Show help for enhanced image features
        showImageHelp() {
            const helpText=` MyPocket Enhanced Image System Help:
                ===================================üñºÔ∏è IMAGE STATUS INDICATORS: ‚Ä¢ üåê Synced - Stored across all devices ‚Ä¢ üíæ Cached - Stored locally on this device ‚Ä¢ üîÑ Refreshed - Recently updated image ‚Ä¢ üé® Smart - AI-selected relevant image ‚Ä¢ ‚ùå Failed - Could not load image üéØ ENHANCED IMAGE EXTRACTION: Our system now tries much harder to get REAL images: 1Ô∏è‚É£ PLATFORM-SPECIFIC EXTRACTION: ‚Ä¢ YouTube: Real video thumbnails ‚Ä¢ GitHub: Repository social images ‚Ä¢ Dev.to: Article preview images ‚Ä¢ Much more accurate than generic images 2Ô∏è‚É£ ADVANCED WEB SCRAPING: ‚Ä¢ Open Graph and Twitter Card images ‚Ä¢ JSON-LD structured data parsing ‚Ä¢ Multiple proxy services for reliability ‚Ä¢ Enhanced HTML parsing with better selectors 3Ô∏è‚É£ SMART CONTENT MATCHING: ‚Ä¢ Keyword-specific images (JavaScript articles get JS images) ‚Ä¢ Domain-specific fallbacks (GitHub articles get GitHub-style images) ‚Ä¢ Context-aware category selection üîß AVAILABLE ACTIONS: 1Ô∏è‚É£ INDIVIDUAL IMAGE REFRESH (üñºÔ∏è button): ‚Ä¢ Now tries much harder to find the REAL image ‚Ä¢ Uses platform APIs when possible ‚Ä¢ Falls back to smart, relevant images 2Ô∏è‚É£ RETRY FAILED IMAGES (Retry Failed button): ‚Ä¢ Only processes images marked "‚ùå Failed"
                ‚Ä¢ Uses enhanced extraction methods ‚Ä¢ Much higher success rate than before 3Ô∏è‚É£ SYNC ALL IMAGES (Sync Images button): ‚Ä¢ Forces refresh with enhanced extraction ‚Ä¢ Stores high-quality images for cross-device access ‚Ä¢ Now gets much more relevant images üéØ WHAT'S IMPROVED:
 ‚úÖ Real YouTube thumbnails instead of random images ‚úÖ Actual GitHub repository previews ‚úÖ Platform-specific social preview images ‚úÖ Smart keyword matching (Python articles get Python images) ‚úÖ Much more relevant category fallbacks ‚úÖ Better extraction success rate üí° TIP: The system now prioritizes REAL images from the actual websites, with smart, relevant fallbacks only when necessary. Images should now match your content much better ! `;

            alert(helpText);
        }

        // ENHANCED: Try much harder to get real images before falling back
        async tryAlternativeImageStrategies(article, index) {
            console.log(`üéØ Advanced image recovery for: $ {
                    article.title.substring(0, 30)
                }

                ...`);

            // Strategy 1: Try platform-specific APIs first (most reliable)
            try {
                const platformImage=await this.tryPlatformSpecificImageExtraction(article.url);

                if (platformImage) {
                    console.log(`‚úÖ Platform-specific image found: $ {
                            article.title.substring(0, 30)
                        }

                        ...`);
                    this.setArticleImageAndCache(article, index, platformImage, 'platform');
                    return true;
                }
            }

            catch (error) {
                console.log(`‚ö†Ô∏è Platform extraction failed: $ {
                        error.message
                    }

                    `);
            }

            // Strategy 2: Try multiple proxy services with enhanced parsing
            try {
                const proxyImage=await this.tryEnhancedProxyExtraction(article.url);

                if (proxyImage) {
                    console.log(`‚úÖ Enhanced proxy extraction successful: $ {
                            article.title.substring(0, 30)
                        }

                        ...`);
                    this.setArticleImageAndCache(article, index, proxyImage, 'proxy');
                    return true;
                }
            }

            catch (error) {
                console.log(`‚ö†Ô∏è Enhanced proxy extraction failed: $ {
                        error.message
                    }

                    `);
            }

            // Strategy 3: Try to construct social media preview URLs
            try {
                const socialImage=this.constructSocialPreviewUrl(article.url);

                if (socialImage) {

                    // Test if the social image actually exists
                    const response=await fetch(socialImage, {
                        method: 'HEAD'
                    });

                if (response.ok) {
                    console.log(`‚úÖ Social preview image found: $ {
                            article.title.substring(0, 30)
                        }

                        ...`);
                    this.setArticleImageAndCache(article, index, socialImage, 'social');
                    return true;
                }
            }
        }

        catch (error) {
            console.log(`‚ö†Ô∏è Social preview construction failed: $ {
                    error.message
                }

                `);
        }

        // Strategy 4: Intelligent keyword-based image search
        try {
            const keywordImage=await this.getIntelligentKeywordImage(article);

            if (keywordImage) {
                console.log(`‚úÖ Keyword-based image found: $ {
                        article.title.substring(0, 30)
                    }

                    ...`);
                this.setArticleImageAndCache(article, index, keywordImage, 'keyword');
                return true;
            }
        }

        catch (error) {
            console.log(`‚ö†Ô∏è Keyword-based search failed: $ {
                    error.message
                }

                `);
        }

        // Strategy 5: Smart category-based fallback (last resort, but much better than before)
        console.log(`üé® Using smart category fallback for: $ {
                article.title.substring(0, 30)
            }

            ...`);
        const smartFallback=this.getCategoryBasedImage(article, index);
        this.setArticleImageAndCache(article, index, smartFallback, 'smart_fallback');

        // Update cache indicator to show it's a smart fallback
        const imageElement=document.getElementById(`image-$ {
                index
            }

            `);
        const cacheIndicator=imageElement?.querySelector('.cache-indicator');

        if (cacheIndicator) {
            cacheIndicator.textContent='üé® Smart';
            cacheIndicator.className='cache-indicator smart-categorized';
        }

        return true; // Always return true since we provide a smart fallback
        }

        // NEW: Enhanced proxy extraction with better parsing
        async tryEnhancedProxyExtraction(url) {
            const proxies=[ {
                name: 'AllOrigins',
                url: `https: //api.allorigins.win/get?url=${encodeURIComponent(url)}`, type: 'json' },

                    {
                    name: 'CorsProxy',
                    url: `https: //corsproxy.io/?${encodeURIComponent(url)}`, type: 'text' },

                        {
                        name: 'CodeTabs',
                        url: `https: //api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`, type: 'text' }
                        ];

                        for (const proxy of proxies) {
                            try {
                                console.log(`üîÑ Trying $ {
                                        proxy.name
                                    }

                                    with enhanced parsing...`);
                                const response=await fetch(proxy.url);

                                if (response.ok) {
                                    let html;

                                    if (proxy.type==='json') {
                                        const data=await response.json();
                                        html=data.contents;
                                    }

                                    else {
                                        html=await response.text();
                                    }

                                    if (html && html.length > 1000) {
                                        // Use enhanced parsing
                                        const extractedImage=this.parseHTMLForBestImage(html, url);

                                        if (extractedImage && !this.isIconOrLogo(extractedImage)) {
                                            return extractedImage;
                                        }
                                    }
                                }
                            }

                            catch (error) {
                                console.log(`$ {
                                        proxy.name
                                    }

                                    failed: $ {
                                        error.message
                                    }

                                    `);
                                continue;
                            }
                        }

                        return null;
                    }

                    // NEW: Construct social preview URLs for various platforms
                    constructSocialPreviewUrl(url){
                    const domain=this.getDomain(url).toLowerCase();

                    // GitHub repositories and issues
                    if (domain.includes('github.com')) {
                        const githubMatch=url.match(/github\.com\/([^\/]+)\/([^\/]+)/);

                        if (githubMatch) {
                            return `https: //opengraph.githubassets.com/1/${githubMatch[1]}/${githubMatch[2]}`;
                        }
                    }

                    // Dev.to articles
                    if (domain.includes('dev.to')) {
                        const devMatch=url.match(/dev\.to\/([^\/]+)\/([^\/\?#]+)/);

                        if (devMatch) {
                            const slug=devMatch[2].split('-').slice(0, -1).join('-'); // Remove the ID suffix
                            return `https: //dev.to/social_previews/article/${slug}.png`;
                        }
                    }

                    // Medium articles
                    if (domain.includes('medium.com')) {
                        // Medium has social preview images, but they're harder to construct
                        // We'll rely on the HTML parsing for these
                        return null;
                    }

                    // Reddit posts (some have preview images)
                    if (domain.includes('reddit.com')) {
                        const redditMatch=url.match(/reddit\.com\/r\/([^\/]+)\/comments\/([^\/]+)/);

                        if (redditMatch) {
                            // Reddit sometimes has preview images, but they're not consistently accessible
                            return null;
                        }
                    }

                    return null;
                }

                // NEW: Intelligent keyword-based image selection (much smarter than before)
                async getIntelligentKeywordImage(article) {
                    const title=article.title.toLowerCase();
                    const domain=this.getDomain(article.url).toLowerCase();

                    // Extract meaningful keywords and create highly specific image mappings
                    const keywordMappings= {
                        // Programming languages (very specific)
                        'javascript': 'https://images.unsplash.com/photo-1627398242454-45a1465c2479?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'python': 'https://images.unsplash.com/photo-1526379879527-8559ecfcaec0?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'react': 'https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'vue': 'https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'angular': 'https://images.unsplash.com/photo-1633356122544-f134324a6cee?w=400&h=250&fit=crop&crop=center&q=80&auto=format',

                            // Technology concepts
                            'artificial intelligence': 'https://images.unsplash.com/photo-1555255707-c07966088b7b?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'machine learning': 'https://images.unsplash.com/photo-1555255707-c07966088b7b?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'blockchain': 'https://images.unsplash.com/photo-1639762681485-074b7f938ba0?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'cryptocurrency': 'https://images.unsplash.com/photo-1639762681485-074b7f938ba0?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'docker': 'https://images.unsplash.com/photo-1605745341112-85968b19335b?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'kubernetes': 'https://images.unsplash.com/photo-1605745341112-85968b19335b?w=400&h=250&fit=crop&crop=center&q=80&auto=format',

                            // Health and medicine
                            'covid': 'https://images.unsplash.com/photo-1584811979203-46b67057c1a3?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'vaccine': 'https://images.unsplash.com/photo-1584811979203-46b67057c1a3?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'pandemic': 'https://images.unsplash.com/photo-1584811979203-46b67057c1a3?w=400&h=250&fit=crop&crop=center&q=80&auto=format',

                            // Climate and environment
                            'climate change': 'https://images.unsplash.com/photo-1569163139394-de4e5f43e4e3?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'global warming': 'https://images.unsplash.com/photo-1569163139394-de4e5f43e4e3?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'sustainability': 'https://images.unsplash.com/photo-1611273426858-450d8e3c9fce?w=400&h=250&fit=crop&crop=center&q=80&auto=format',

                            // Space and science
                            'space': 'https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'nasa': 'https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'mars': 'https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'astronomy': 'https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400&h=250&fit=crop&crop=center&q=80&auto=format',

                            // Business and finance
                            'startup': 'https://images.unsplash.com/photo-1664475450424-2645cd1d4b21?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'entrepreneur': 'https://images.unsplash.com/photo-1664475450424-2645cd1d4b21?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'investment': 'https://images.unsplash.com/photo-1611974789855-9c2a0a7236a3?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'stock market': 'https://images.unsplash.com/photo-1611974789855-9c2a0a7236a3?w=400&h=250&fit=crop&crop=center&q=80&auto=format',

                            // Politics
                            'election': 'https://images.unsplash.com/photo-1586002415569-8f3c737b7e5e?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'voting': 'https://images.unsplash.com/photo-1586002415569-8f3c737b7e5e?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'democracy': 'https://images.unsplash.com/photo-1586002415569-8f3c737b7e5e?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    }

                    ;

                    // Check for exact keyword matches first
                    for (const [keyword, imageUrl] of Object.entries(keywordMappings)) {
                        if (title.includes(keyword)) {
                            console.log(`üéØ Found keyword match: "${keyword}" ‚Üí $ {
                                    imageUrl
                                }

                                `);
                            return imageUrl;
                        }
                    }

                    return null;
                }

                // NEW: Try alternative proxy services
                async tryAlternativeProxies(url) {
                    const proxies=[ `https: //corsproxy.io/?${encodeURIComponent(url)}`,
                    `https: //api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
                    `https: //thingproxy.freeboard.io/fetch/${encodeURIComponent(url)}`
                    ];

                    for (const proxyUrl of proxies) {
                        try {
                            console.log(`Trying proxy: $ {
                                    proxyUrl.substring(0, 50)
                                }

                                ...`);
                            const response=await fetch(proxyUrl);

                            if (response.ok) {
                                const html=await response.text();

                                if (html && html.length > 1000) {
                                    const extractedImage=this.parseHTMLForBestImage(html, url);

                                    if (extractedImage) {
                                        return extractedImage;
                                    }
                                }
                            }
                        }

                        catch (error) {
                            console.log(`Proxy failed: $ {
                                    error.message
                                }

                                `);
                            continue;
                        }
                    }

                    return null;
                }

                // NEW: Get image based on title keywords using search services
                async getImageFromTitleKeywords(article) {
                    // Extract meaningful keywords from title
                    const title=article.title.toLowerCase();
                    const commonWords=['the',
                    'a',
                    'an',
                    'and',
                    'or',
                    'but',
                    'in',
                    'on',
                    'at',
                    'to',
                    'for',
                    'of',
                    'with',
                    'by',
                    'how',
                    'what',
                    'why',
                    'when',
                    'where'];
                    const keywords=title .split(/[^\w]+/) .filter(word=> word.length > 3 && !commonWords.includes(word)) .slice(0, 3) // Take first 3 meaningful words
                    .join(' ');

                    if ( !keywords) return null;

                    // Use Unsplash search API for relevant images
                    try {
                        const searchQuery=encodeURIComponent(keywords);
                        const unsplashUrl=`https: //images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format`;

                            // For now, return a themed image based on keywords
                            // (In a real implementation, you'd use Unsplash API with a key)
                            if (keywords.includes('tech') || keywords.includes('code') || keywords.includes('software')) {
                            return 'https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                        }

                        if (keywords.includes('business') || keywords.includes('work') || keywords.includes('office')) {
                            return 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                        }

                        if (keywords.includes('design') || keywords.includes('art') || keywords.includes('creative')) {
                            return 'https://images.unsplash.com/photo-1561070791-2526d30994b5?w=400&h=250&fit=crop&crop=center&q=80&auto=format';
                        }

                        return unsplashUrl;
                    }

                    catch (error) {
                        console.log(`Keyword-based search failed: $ {
                                error.message
                            }

                            `);
                        return null;
                    }
                }

                // NEW: Get domain-specific images for known sites
                getDomainSpecificImage(article) {
                    const domain=this.getDomain(article.url).toLowerCase();

                    // Site-specific default images for when original images fail
                    const siteDefaults= {
                        'github.com': 'https://images.unsplash.com/photo-1618401471353-b98afee0b2eb?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'medium.com': 'https://images.unsplash.com/photo-1481627834876-b7833e8f5570?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'youtube.com': 'https://images.unsplash.com/photo-1611162617474-5b21e879e113?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'stackoverflow.com': 'https://images.unsplash.com/photo-1516116216624-53e697fedbea?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'dev.to': 'https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'reddit.com': 'https://images.unsplash.com/photo-1611224923853-80b023f02d71?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'news': 'https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                            'blog': 'https://images.unsplash.com/photo-1486312338219-ce68e2c6b9d6?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    }

                    ;

                    // Check for exact domain matches
                    for (const [siteDomain, image] of Object.entries(siteDefaults)) {
                        if (domain.includes(siteDomain)) {
                            return image;
                        }
                    }

                    return null;
                }

                async forceSyncImages() {
                    if ( !this.accessToken) {
                        this.updateStatus('‚ùå Please connect to OneDrive first', 'error');
                        return;
                    }

                    this.updateStatus('üîÑ Force syncing all images to OneDrive...', 'loading');

                    try {
                        let syncedCount=0;
                        const totalArticles=this.articles.length;

                        for (let i=0; i < this.articles.length; i++) {
                            const article=this.articles[i];

                            // If article doesn't have cached image, try to get it from local cache or extract
                            if ( !article.cachedImage) {
                                let imageUrl=this.getCachedImage(article);

                                if ( !imageUrl) {
                                    imageUrl=this.getBestArticleImage(article);
                                }

                                if ( !imageUrl) {
                                    imageUrl=this.getCategoryBasedImage(article, i);
                                }

                                if (imageUrl) {
                                    try {
                                        const imageData=await this.convertImageToBase64(imageUrl);

                                        if (imageData.stored) {
                                            article.cachedImage= {
                                                base64: imageData.base64,
                                                    url: imageData.url,
                                                    timestamp: Date.now(),
                                                    size: imageData.size,
                                                    source: 'force_sync'
                                            }

                                            ;
                                            syncedCount++;
                                        }
                                    }

                                    catch (error) {
                                        console.error(`Failed to sync image for $ {
                                                article.title
                                            }

                                            :`, error);
                                    }
                                }
                            }

                            else {
                                syncedCount++; // Already has cached image
                            }

                            // Update progress
                            if (i % 5===0) {
                                this.updateStatus(`üîÑ Syncing images... $ {
                                        i + 1
                                    }

                                    /$ {
                                        totalArticles
                                    }

                                    `, 'loading');
                            }
                        }

                        // Save to OneDrive
                        await this.updateOneDriveBackup();

                        this.updateStatus(`‚úÖ Force sync complete ! $ {
                                syncedCount
                            }

                            /$ {
                                totalArticles
                            }

                            images synced to OneDrive`, 'success');

                        // Refresh display to show synced status
                        this.displayArticles(this.articles);

                    }

                    catch (error) {
                        console.error('Force sync error:', error);

                        this.updateStatus(`‚ùå Force sync failed: $ {
                                error.message
                            }

                            `, 'error');
                    }
                }

                updateStatus(message, type='') {
                    const status=document.getElementById('status');
                    status.textContent=message;

                    status.className=`status $ {
                        type
                    }

                    `;
                }

                // ===== PKCE IMPLEMENTATION =====

                // Generate a cryptographically secure random string for PKCE
                generateCodeVerifier() {
                    const array=new Uint8Array(32);
                    crypto.getRandomValues(array);
                    return this.base64URLEncode(array);
                }

                // Create SHA256 hash and base64url encode it
                async generateCodeChallenge(codeVerifier) {
                    const encoder=new TextEncoder();
                    const data=encoder.encode(codeVerifier);
                    const digest=await crypto.subtle.digest('SHA-256', data);
                    return this.base64URLEncode(new Uint8Array(digest));
                }

                // Base64URL encoding (different from regular base64)
                base64URLEncode(array) {
                    return btoa(String.fromCharCode.apply(null, array)) .replace(/\+/g, '-') .replace(/\//g, '_') .replace(/=/g, '');
                }

                // Generate cryptographically secure state parameter
                generateState() {
                    const array=new Uint8Array(16);
                    crypto.getRandomValues(array);
                    return this.base64URLEncode(array);
                }

                // Store PKCE parameters securely
                storePKCEParameters(codeVerifier, state) {
                    // Use sessionStorage for security (cleared when tab closes)
                    sessionStorage.setItem('mypocket_code_verifier', codeVerifier);
                    sessionStorage.setItem('mypocket_state', state);
                    console.log('üîê PKCE parameters stored securely');
                }

                // Retrieve PKCE parameters
                retrievePKCEParameters() {
                    const codeVerifier=sessionStorage.getItem('mypocket_code_verifier');
                    const state=sessionStorage.getItem('mypocket_state');

                    return {
                        codeVerifier,
                        state
                    }

                    ;
                }

                // Clear PKCE parameters after use
                clearPKCEParameters() {
                    sessionStorage.removeItem('mypocket_code_verifier');
                    sessionStorage.removeItem('mypocket_state');
                    console.log('üóëÔ∏è PKCE parameters cleared');
                }

                // ENHANCED: Secure authentication with PKCE
                async authenticate() {
                    console.log('üîê Starting authentication process...');

                    if ( !this.redirectUri || ( !this.redirectUri.startsWith ('http://') && !this.redirectUri.startsWith ('https://'))) {
                        const errorMsg='Invalid redirect URI. Please open this page via HTTP/HTTPS.';
                        console.error('üî¥', errorMsg, 'Current URI:', this.redirectUri);

                        this.updateStatus(`‚ùå $ {
                                errorMsg
                            }

                            `, 'error');

                        alert(`Redirect URI Error:\n\nCurrent URI: $ {
                                this.redirectUri
                            }

                            \n\nPlease:\n1. Open this page via HTTP/HTTPS (not file: //)\n2. Register this exact URI in Azure AD\n3. Use a web server to serve this file`);
                                return;
                            }

                            try {
                                this.updateStatus('üîê Generating secure authentication parameters...', 'loading');
                                console.log('üîß Generating PKCE parameters...');

                                // Generate PKCE parameters
                                this.codeVerifier=this.generateCodeVerifier();
                                this.codeChallenge=await this.generateCodeChallenge(this.codeVerifier);
                                this.state=this.generateState();

                                console.log('‚úÖ PKCE parameters generated successfully');

                                // Store parameters securely
                                this.storePKCEParameters(this.codeVerifier, this.state);

                                // Build authorization URL with PKCE
                                const authUrl=`https: //login.microsoftonline.com/consumers/oauth2/v2.0/authorize?` +

                                `client_id=$ {
                                    this.clientId
                                }

                                &` + `response_type=code&` + // Use code instead of token

                                `redirect_uri=$ {
                                    encodeURIComponent(this.redirectUri)
                                }

                                &` + `scope=$ {
                                    encodeURIComponent('Files.ReadWrite User.Read')
                                }

                                &` + `state=$ {
                                    this.state
                                }

                                &` + // Anti-CSRF protection

                                `code_challenge=$ {
                                    this.codeChallenge
                                }

                                &` + // PKCE challenge
                                `code_challenge_method=S256&` + // SHA256 method
                                `response_mode=query`; // Use query instead of fragment

                                console.log('üîê PKCE Auth URL generated');
                                console.log('üîê Code Challenge:', this.codeChallenge.substring(0, 20) + '...');
                                console.log('üîê State:', this.state.substring(0, 20) + '...');

                                this.updateStatus('üîÑ Redirecting to secure Microsoft login...', 'loading');

                                setTimeout(()=> {
                                        console.log('üåê Redirecting to Microsoft login...');
                                        window.location.href=authUrl;
                                    }

                                    , 1000);

                            }

                            catch (error) {
                                console.error('‚ùå PKCE generation error:', error);
                                this.updateStatus('‚ùå Error generating secure authentication. Please try again.', 'error');
                            }
                        }

                        // ENHANCED: Handle authorization code from redirect
                        async checkAuthFromURL() {
                            const urlParams=new URLSearchParams(window.location.search);
                            const code=urlParams.get('code');
                            const state=urlParams.get('state');
                            const error=urlParams.get('error');
                            const errorDescription=urlParams.get('error_description');

                            // Check for errors first
                            if (error) {
                                this.updateStatus(`‚ùå Authentication error: $ {
                                        error
                                    }

                                    - $ {
                                        errorDescription || 'Unknown error'
                                    }

                                    `, 'error');
                                this.clearPKCEParameters();

                                // Clean URL
                                window.history.replaceState({}

                                , document.title, window.location.pathname);
                            return;
                        }

                        // If we have an authorization code, exchange it for tokens
                        if (code && state) {
                            try {
                                this.updateStatus('üîê Exchanging authorization code for tokens...', 'loading');

                                // Retrieve stored PKCE parameters
                                const {
                                    codeVerifier, state: storedState
                                }

                                =this.retrievePKCEParameters();

                                // Verify state parameter (anti-CSRF protection)
                                if ( !storedState || state !==storedState) {
                                    throw new Error('State parameter mismatch. Possible CSRF attack.');
                                }

                                if ( !codeVerifier) {
                                    throw new Error('Code verifier not found. Please try authenticating again.');
                                }

                                // Exchange authorization code for access token
                                const tokenResponse=await this.exchangeCodeForTokens(code, codeVerifier);

                                if (tokenResponse.access_token) {
                                    console.log('‚úÖ Token exchange successful');
                                    this.accessToken=tokenResponse.access_token;
                                    this.saveToken(tokenResponse.access_token);

                                    // Save refresh token if provided
                                    if (tokenResponse.refresh_token) {
                                        this.saveRefreshToken(tokenResponse.refresh_token);
                                    }

                                    console.log('üîÑ Updating connection status...');
                                    this.updateConnectionStatus(true);

                                    console.log('üìö Loading articles...');
                                    this.loadArticles();

                                    // Clear PKCE parameters and URL
                                    this.clearPKCEParameters();

                                    window.history.replaceState({}

                                    , document.title, window.location.pathname);

                                this.updateStatus('‚úÖ Secure authentication successful!', 'success');
                            }

                            else {
                                throw new Error('No access token received from authorization server');
                            }

                        }

                        catch (error) {
                            console.error('‚ùå Token exchange error:', error);

                            this.updateStatus(`‚ùå Token exchange failed: $ {
                                    error.message
                                }

                                `, 'error');
                            this.clearPKCEParameters();

                            window.history.replaceState({}

                            , document.title, window.location.pathname);
                    }
                }
            }

            // NEW: Exchange authorization code for access token using PKCE
            async exchangeCodeForTokens(authorizationCode, codeVerifier) {
                const tokenEndpoint='https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                const tokenRequest= {

                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    }

                    ,
                    body: new URLSearchParams({
                        client_id: this.clientId,
                        scope: 'Files.ReadWrite User.Read',
                        code: authorizationCode,
                        redirect_uri: this.redirectUri,
                        grant_type: 'authorization_code',
                        code_verifier: codeVerifier // PKCE verification
                    })
            }

            ;

            console.log('üîê Exchanging authorization code for tokens...');

            const response=await fetch(tokenEndpoint, tokenRequest);

            if ( !response.ok) {
                const errorData=await response.json();

                throw new Error(`Token exchange failed: $ {
                        errorData.error
                    }

                    - $ {
                        errorData.error_description
                    }

                    `);
            }

            const tokenData=await response.json();
            console.log('‚úÖ Token exchange successful');

            return tokenData;
        }

        // NEW: Enhanced token management
        saveToken(token) {
            localStorage.setItem('mypocket_access_token', token);
            // Also store timestamp for expiration tracking
            localStorage.setItem('mypocket_token_timestamp', Date.now().toString());
        }

        saveRefreshToken(refreshToken) {
            localStorage.setItem('mypocket_refresh_token', refreshToken);
        }

        getRefreshToken() {
            return localStorage.getItem('mypocket_refresh_token');
        }

        clearTokens() {
            localStorage.removeItem('mypocket_access_token');
            localStorage.removeItem('mypocket_refresh_token');
            localStorage.removeItem('mypocket_token_timestamp');
            this.accessToken=null;
        }

        // NEW: Check if token is expired and refresh if needed
        async ensureValidToken() {
            if ( !this.accessToken) {
                return false;
            }

            // Check if token is expired (Microsoft tokens typically last 1 hour)
            const tokenTimestamp=localStorage.getItem('mypocket_token_timestamp');

            if (tokenTimestamp) {
                const tokenAge=Date.now() - parseInt(tokenTimestamp);
                const oneHour=60 * 60 * 1000;

                if (tokenAge > oneHour) {
                    console.log('üîÑ Token expired, attempting refresh...');
                    const refreshSuccess=await this.refreshAccessToken();

                    if ( !refreshSuccess) {
                        console.log('‚ùå Token refresh failed, need to re-authenticate');
                        return false;
                    }
                }
            }

            return true;
        }

        // NEW: Refresh access token using refresh token
        async refreshAccessToken() {
            const refreshToken=this.getRefreshToken();

            if ( !refreshToken) {
                console.log('No refresh token available');
                return false;
            }

            try {
                const tokenEndpoint='https://login.microsoftonline.com/consumers/oauth2/v2.0/token';

                const refreshRequest= {

                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    }

                    ,
                    body: new URLSearchParams({
                        client_id: this.clientId,
                        scope: 'Files.ReadWrite User.Read',
                        refresh_token: refreshToken,
                        grant_type: 'refresh_token'
                    })
            }

            ;

            const response=await fetch(tokenEndpoint, refreshRequest);

            if ( !response.ok) {
                console.log('Refresh token request failed');
                return false;
            }

            const tokenData=await response.json();

            if (tokenData.access_token) {
                this.accessToken=tokenData.access_token;
                this.saveToken(tokenData.access_token);

                // Update refresh token if a new one was provided
                if (tokenData.refresh_token) {
                    this.saveRefreshToken(tokenData.refresh_token);
                }

                console.log('‚úÖ Token refreshed successfully');
                return true;
            }

            return false;

        }

        catch (error) {
            console.error('Token refresh error:', error);
            return false;
        }
        }

        loadStoredToken() {
            console.log('üîç Loading stored token...');
            this.accessToken=localStorage.getItem('mypocket_access_token');

            if (this.accessToken) {
                console.log('‚úÖ Found stored token, updating connection status...');
                this.updateConnectionStatus(true);

                // Check token validity and load articles
                this.ensureValidToken().then(isValid=> {
                        if (isValid) {
                            console.log('‚úÖ Token is valid, loading articles...');
                            this.loadArticles();
                        }

                        else {
                            console.log('‚ùå Token is invalid, updating connection status...');
                            this.updateConnectionStatus(false);
                            this.updateStatus('Stored token expired. Please reconnect.', 'error');
                        }
                    });
            }

            else {
                console.log('‚ÑπÔ∏è No stored token found');
            }
        }
        }

        /* Cache indicator */
        .cache-indicator {
            position: absolute;
            bottom: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            z-index: 5;
        }

        .cache-indicator.cached {
            background: rgba(39, 174, 96, 0.8);
        }

        .cache-indicator.fresh {
            background: rgba(52, 152, 219, 0.8);
        }

        /* NEW: Enhanced cache indicator styles */
        .cache-indicator.synced {
            background: rgba(76, 175, 80, 0.8);
            color: white;
        }

        .cache-indicator.fallback {
            background: rgba(255, 152, 0, 0.8);
            color: white;
        }

        .cache-indicator.metadata {
            background: rgba(103, 58, 183, 0.8);
            color: white;
        }

        .cache-indicator.error {
            background: rgba(244, 67, 54, 0.8);
            color: white;
        }

        .cache-indicator.ai-categorized {
            background: rgba(156, 39, 176, 0.9);
            color: white;
        }

        .cache-indicator.smart-categorized {
            background: rgba(103, 58, 183, 0.9);
            color: white;
        }

        /* Modal styles for category correction */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--surface);
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .modal h3 {
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .category-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin: 16px 0;
        }

        .category-btn {
            padding: 8px 12px;
            border: 1px solid var(--border);
            background: var(--background);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9em;
        }

        .category-btn:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 16px;
        }

        .modal-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .modal-btn.primary {
            background: var(--primary-color);
            color: white;
        }

        .modal-btn.secondary {
            background: var(--border);
            color: var(--text-primary);
        }

        /* Enhanced Mobile Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 0 12px;
            }

            /* Mobile Sidebar */
            .sidebar {
                transform: translateX(-100%);
                width: 100%;
                max-width: 280px;
                z-index: 105;
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .sidebar.collapsed {
                transform: translateX(-100%);
            }

            .sidebar-toggle {
                display: none;
            }

            /* Mobile Header */
            .header {
                padding: 15px 0;
                position: fixed;
                width: 100%;
                top: 0;
                z-index: 104;
            }

            .header-content {
                padding-left: 20px;
                padding-right: 20px;
            }

            .mobile-menu-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                background: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 6px;
                color: white;
                padding: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .mobile-menu-btn:hover {
                background: rgba(255, 255, 255, 0.3);
            }

            /* Main Content Mobile */
            .main-content {
                margin-left: 0;
                padding-top: 80px;
                /* Account for fixed header */
            }

            .main-content.sidebar-collapsed {
                margin-left: 0;
            }

            /* Mobile Overlay */
            .sidebar-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 103;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s ease;
            }

            .sidebar-overlay.active {
                opacity: 1;
                visibility: visible;
            }

            /* Header improvements for mobile */
            .logo {
                font-size: 1.4em;
            }

            .header-right {
                gap: 10px;
            }

            .mobile-menu-btn {
                display: none;
                align-items: center;
                justify-content: center;
                background: rgba(255, 255, 255, 0.2);
                border: none;
                border-radius: 6px;
                color: white;
                padding: 8px;
                cursor: pointer;
                transition: all 0.2s ease;
                font-size: 18px;
                width: 36px;
                height: 36px;
            }

            .mobile-menu-btn:hover {
                background: rgba(255, 255, 255, 0.3);
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
                border-radius: 20px;
            }

            /* Search improvements */
            .search-container {
                padding: 20px 0;
                top: 80px;
                /* Account for fixed header */
            }

            .search-input {
                font-size: 16px !important;
                /* Prevent zoom */
                padding: 12px 45px 12px 16px;
                border-radius: 20px;
            }

            .search-close-btn {
                right: 12px;
                width: 28px;
                height: 28px;
                font-size: 16px;
            }

            /* Category Filter Mobile */
            .category-container {
                padding: 15px 0;
                top: 80px;
                /* Account for fixed header */
            }

            .category-header h3 {
                font-size: 1.1em;
            }

            .category-chips {
                gap: 8px;
            }

            .category-chip {
                padding: 6px 12px;
                font-size: 0.8em;
                border-radius: 16px;
            }

            .category-count {
                font-size: 0.7em;
                padding: 1px 4px;
            }

            /* Status bar */
            .status {
                padding: 15px 0;
                font-size: 14px;
                line-height: 1.4;
            }

            /* MAJOR MOBILE GRID FIX */
            .articles-section {
                padding: 20px 0;
            }

            .articles-grid {
                display: block;
                /* Use block layout instead of grid for better mobile performance */
                margin-top: 15px;
            }

            /* COMPLETELY REDESIGNED MOBILE CARDS */
            .article-card {
                display: block !important;
                width: 100% !important;
                margin-bottom: 20px !important;
                border-radius: 20px !important;
                overflow: hidden;
                background: var(--surface);
                border: 1px solid var(--border);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                transform: none !important;
                animation: none !important;
            }

            .article-card:hover {
                transform: none !important;
                box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
            }

            /* LARGER MOBILE IMAGE */
            .article-image {
                width: 100% !important;
                height: 140px !important;
                /* Increased from 100px */
                border-radius: 20px 20px 0 0 !important;
                position: relative;
            }

            /* MUCH LARGER TEXT ON MOBILE */
            .article-content {
                padding: 20px !important;
                cursor: pointer;
            }

            .article-title {
                font-size: 1.25em !important;
                /* Much larger - was 1em */
                font-weight: 600;
                margin-bottom: 10px !important;
                line-height: 1.4 !important;
                color: var(--text-primary);
                display: block !important;
                /* Remove text clamping on mobile */
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-excerpt {
                font-size: 1em !important;
                /* Much larger - was 0.8em */
                line-height: 1.5 !important;
                margin-bottom: 15px !important;
                color: var(--text-secondary);
                display: block !important;
                /* Remove text clamping on mobile */
                -webkit-line-clamp: unset !important;
                -webkit-box-orient: unset !important;
                overflow: visible !important;
            }

            .article-meta {
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-wrap: wrap;
                gap: 8px;
                color: var(--text-secondary);
                font-size: 0.9em !important;
                /* Larger - was 0.75em */
                margin-bottom: 10px;
            }

            .article-stats {
                display: flex;
                gap: 15px;
                font-size: 0.85em !important;
                /* Larger - was 0.7em */
                color: var(--text-secondary);
                margin-bottom: 10px;
            }

            /* Mobile category badge */
            .article-category {
                font-size: 0.8em !important;
                padding: 4px 10px;
                margin-bottom: 10px;
            }

            /* MOBILE-OPTIMIZED ACTION BUTTONS */
            .article-actions {
                position: static !important;
                opacity: 1 !important;
                visibility: visible !important;
                display: flex !important;
                justify-content: center;
                gap: 12px;
                padding: 15px 20px;
                background: var(--background);
                border-radius: 0;
                margin: 0;
                border-top: 1px solid var(--border);
            }

            .action-btn {
                min-width: 45px !important;
                height: 45px !important;
                font-size: 18px !important;
                border-radius: 50% !important;
                padding: 0;
                background: var(--surface);
                border: 2px solid var(--border);
                display: flex;
                align-items: center;
                justify-content: center;
                transition: all 0.2s ease;
            }

            .action-btn:hover,
            .action-btn:active {
                border-radius: 50% !important;
                transform: scale(1.05);
                background: var(--primary-color);
                color: white;
                border-color: var(--primary-color);
            }

            /* MOBILE READER IMPROVEMENTS */
            .reader-overlay {
                padding: 0;
                z-index: 106;
            }

            .reader-container {
                margin: 0 !important;
                border-radius: 0 !important;
                height: 100vh;
                max-width: none;
                display: flex;
                flex-direction: column;
            }

            .reader-header {
                padding: 20px;
                border-radius: 0;
                flex-shrink: 0;
            }

            .reader-title {
                font-size: 1.4em !important;
                line-height: 1.3;
                margin-bottom: 15px;
            }

            .reader-meta {
                font-size: 0.9em;
                gap: 15px;
            }

            .reader-content {
                padding: 20px;
                font-size: 1.1em !important;
                /* Larger reading text */
                line-height: 1.7 !important;
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                /* Smooth scrolling on iOS */
            }

            .close-reader {
                top: 15px;
                right: 15px;
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            /* MOBILE SEARCH */
            .search-input {
                font-size: 16px !important;
                /* Prevent zoom */
                padding: 14px 50px 14px 18px;
            }

            /* EMPTY STATE */
            .empty-state {
                padding: 40px 20px;
            }

            .empty-state-icon {
                font-size: 3em;
                margin-bottom: 15px;
            }

            .empty-state h3 {
                font-size: 1.3em;
                margin-bottom: 8px;
            }

            .empty-state p {
                font-size: 1em;
                line-height: 1.5;
            }
        }

        /* Extra small screens (very small phones) */
        @media (max-width: 480px) {
            .article-title {
                font-size: 1.15em !important;
            }

            .article-excerpt {
                font-size: 0.95em !important;
            }

            .article-content {
                padding: 16px !important;
            }

            .header-actions {
                gap: 6px;
            }

            .btn {
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        /* Firefox Mobile Specific Fixes */
        @-moz-document url-prefix() {
            @media (max-width: 768px) {
                .article-card {
                    will-change: auto;
                    /* Improve performance on Firefox mobile */
                }

                .articles-grid {
                    transform: translateZ(0);
                    /* Force hardware acceleration */
                }

                .search-input {
                    -moz-appearance: none;
                    /* Remove Firefox mobile styling */
                }

                .btn {
                    -moz-appearance: none;
                }
            }
        }

        /* Connection Status */
        .connection-status {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 15px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .connection-status.connected {
            border-color: #27ae60;
            background: #d4edda;
        }

        .connection-status.disconnected {
            border-color: #e74c3c;
            background: #f8d7da;
        }

        /* Additional organic elements */
        @keyframes float {

            0%,
            100% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-6px);
            }
        }

        /* Background pattern animation for generated placeholders */
        @keyframes floatPattern {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        /* Shimmer animation for loading placeholders */
        @keyframes shimmer {
            0% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.6;
            }
        }

        .article-card:nth-child(7n+1) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 0s;
        }

        .article-card:nth-child(7n+2) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 0.5s;
        }

        .article-card:nth-child(7n+3) {
            animation: float 6s ease-in-out infinite;
            animation-delay: 1s;
        }

        /* Organic gradient backgrounds for images */
        .article-image:nth-child(odd) {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .article-image:nth-child(3n+1) {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .article-image:nth-child(3n+2) {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .article-image:nth-child(3n+3) {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
        }

        .article-image:nth-child(5n+1) {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }
    </style>
</head>

<body>
    <!-- Left Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-brand">
                <span>ü§ñ</span>
                <span>MyPocket AI</span>
            </div>
        </div>

        <!-- Connection Status -->
        <div class="connection-panel">
            <div class="connection-status-sidebar" id="connectionStatusSidebar">
                <span id="connectionIcon">üîê</span>
                <span id="connectionText">Not Connected</span>
            </div>
            <button id="connectBtnSidebar" class="connect-btn-sidebar">
                Secure Connect
            </button>
        </div>

        <!-- Navigation -->
        <nav class="sidebar-nav">
            <!-- Main Actions -->
            <div class="nav-section">
                <div class="nav-section-title">Library</div>
                <button class="nav-item" id="allArticlesNav" onclick="webReader.showAllArticles()">
                    <span class="icon">üìñ</span>
                    <span class="text">All Articles</span>
                    <span class="badge" id="allArticlesBadge">0</span>
                </button>
                <button class="nav-item" id="searchNavBtn" onclick="webReader.toggleSearch()">
                    <span class="icon">üîç</span>
                    <span class="text">Search</span>
                </button>
                <button class="nav-item" id="categoriesNavBtn" onclick="webReader.toggleCategoryFilter()">
                    <span class="icon">ü§ñ</span>
                    <span class="text">AI Categories</span>
                    <span class="badge" id="categoryBadge">0</span>
                </button>
            </div>

            <!-- Tools -->
            <div class="nav-section">
                <div class="nav-section-title">Tools</div>
                <button class="nav-item" id="refreshNavBtn" onclick="webReader.loadArticles()">
                    <span class="icon">üîÑ</span>
                    <span class="text">Refresh</span>
                </button>
                <button class="nav-item" id="syncNavBtn" onclick="webReader.forceSyncImages()">
                    <span class="icon">üåê</span>
                    <span class="text">Sync Images</span>
                </button>
                <button class="nav-item" id="retryNavBtn" onclick="webReader.retryFailedImages()">
                    <span class="icon">üîÅ</span>
                    <span class="text">Retry Failed</span>
                </button>
                <button class="nav-item" onclick="webReader.clearImageCache()">
                    <span class="icon">üóëÔ∏è</span>
                    <span class="text">Clear Cache</span>
                </button>
                <button class="nav-item" onclick="webReader.recategorizeAllWithAI()">
                    <span class="icon">üß†</span>
                    <span class="text">AI Re-categorize</span>
                </button>
            </div>

            <!-- Settings -->
            <div class="nav-section">
                <div class="nav-section-title">Settings</div>
                <button class="nav-item" onclick="webReader.toggleDarkMode()">
                    <span class="icon" id="darkModeIcon">üåô</span>
                    <span class="text" id="darkModeText">Dark Mode</span>
                </button>
                <button class="nav-item" onclick="webReader.toggleTestMode()">
                    <span class="icon">üëÅÔ∏è</span>
                    <span class="text">Show Buttons</span>
                </button>
                <button class="nav-item" onclick="webReader.showImageHelp()">
                    <span class="icon">‚ùì</span>
                    <span class="text">Image Help</span>
                </button>
                <button class="nav-item" onclick="webReader.showAIHelp()">
                    <span class="icon">ü§ñ</span>
                    <span class="text">AI Categories Help</span>
                </button>
                <button class="nav-item" onclick="webReader.showDebugInfo()">
                    <span class="icon">üîß</span>
                    <span class="text">Debug Info</span>
                </button>
            </div>
        </nav>

        <!-- Sidebar Toggle -->
        <button class="sidebar-toggle" id="sidebarToggle" onclick="webReader.toggleSidebar()">
            <span id="sidebarToggleIcon">‚óÄ</span>
        </button>
    </div>

    <!-- Sidebar Overlay for Mobile -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="webReader.closeMobileSidebar()"></div>

    <!-- Category Correction Modal -->
    <div class="modal-overlay" id="categoryModal">
        <div class="modal">
            <h3>Correct Category</h3>
            <p id="modalArticleTitle">Article title will appear here</p>
            <p><strong>Current:</strong> <span id="modalCurrentCategory">Category</span></p>
            <div class="category-buttons" id="modalCategoryButtons">
                <!-- Category buttons will be populated here -->
            </div>
            <div class="modal-actions">
                <button class="modal-btn secondary" onclick="webReader.closeCategoryModal()">Cancel</button>
                <button class="modal-btn primary" onclick="webReader.applyCategoryCorrection()">Save</button>
            </div>
        </div>
    </div>

    <!-- Main Content Area -->
    <div class="main-content" id="mainContent">
        <!-- Header -->
        <header class="header">
            <div class="container">
                <div class="header-content">
                    <!-- Mobile Menu Button -->
                    <button class="mobile-menu-btn" id="mobileMenuBtn" onclick="webReader.openMobileSidebar()"
                        style="display: none;">
                        <span>‚ò∞</span>
                    </button>

                    <div class="logo">
                        MyPocket AI Reader
                    </div>

                    <div class="header-right">
                        <!-- Keep minimal actions in header -->
                        <span id="headerStatus" class="header-status">ü§ñ AI Enhanced</span>
                    </div>
                </div>
            </div>
        </header>

        <!-- Search (Initially Hidden) -->
        <section class="search-container" id="searchContainer" style="display: none;">
            <div class="container">
                <div class="search-box">
                    <input type="text" id="searchInput" class="search-input"
                        placeholder="Search your saved articles... (ü§ñ AI-powered)" autocomplete="off">
                    <button class="search-close-btn" onclick="webReader.toggleSearch()" title="Close search">‚úï</button>
                </div>
            </div>
        </section>

        <!-- Category Filter (Initially Hidden) -->
        <section class="category-container" id="categoryContainer" style="display: none;">
            <div class="container">
                <div class="category-filter">
                    <div class="category-header">
                        <h3>ü§ñ AI-Enhanced Categories</h3>
                        <button class="category-close-btn" onclick="webReader.toggleCategoryFilter()"
                            title="Close categories">‚úï</button>
                    </div>
                    <div class="category-chips" id="categoryChips">
                        <!-- Categories will be populated here -->
                    </div>
                </div>
            </div>
        </section>

        <!-- Status -->
        <div class="status" id="status">
            Connect to OneDrive to view your saved articles with AI-enhanced categorization
        </div>

        <!-- Articles -->
        <section class="articles-section">
            <div class="container">
                <div id="articlesContainer">
                    <div class="empty-state">
                        <div class="empty-state-icon">ü§ñ</div>
                        <h3>Welcome to MyPocket AI Reader</h3>
                        <p>Connect to OneDrive to access your saved articles with intelligent AI categorization!</p>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <!-- Reader Overlay -->
    <div class="reader-overlay" id="readerOverlay">
        <div class="reader-container">
            <button class="close-reader" id="closeReader">‚úï</button>
            <div class="reader-header">
                <h1 class="reader-title" id="readerTitle">Article Title</h1>
                <div class="reader-meta" id="readerMeta">
                    <span>üìÖ <span id="readerDate">Date</span></span>
                    <span>üåê <span id="readerDomain">Domain</span></span>
                    <span>‚è±Ô∏è <span id="readerTime">5 min read</span></span>
                </div>
                <div class="reader-actions">
                    <button class="btn btn-secondary" id="openOriginal">
                        üîó Open Original
                    </button>
                </div>
            </div>
            <div class="reader-content" id="readerContent">
                Article content will appear here...
            </div>
        </div>
    </div>

    <script>
        console.log('üöÄ MyPocket AI-Enhanced Web Reader script starting...');

        // Debug function available immediately
        window.debugMyPocket = function () {
            console.log('üîß DEBUG: Checking all elements...');
            const elements = {
                'sidebar': document.getElementById('sidebar'),
                'connectBtnSidebar': document.getElementById('connectBtnSidebar'),
                'connectionStatusSidebar': document.getElementById('connectionStatusSidebar'),
                'connectionIcon': document.getElementById('connectionIcon'),
                'connectionText': document.getElementById('connectionText'),
                'refreshNavBtn': document.getElementById('refreshNavBtn'),
                'syncNavBtn': document.getElementById('syncNavBtn'),
                'retryNavBtn': document.getElementById('retryNavBtn'),
                'allArticlesNav': document.getElementById('allArticlesNav'),
                'searchNavBtn': document.getElementById('searchNavBtn'),
                'categoriesNavBtn': document.getElementById('categoriesNavBtn'),
                'status': document.getElementById('status'),
                'mainContent': document.getElementById('mainContent')
            };

            console.log('üîç Element check results:');
            for (const [name, element] of Object.entries(elements)) {
                if (element) {
                    console.log(`‚úÖ ${name}: Found`);
                } else {
                    console.log(`‚ùå ${name}: NOT FOUND`);
                }
            }

            // Check if webReader exists
            if (window.webReader) {
                console.log('‚úÖ webReader: Initialized');
                console.log('üìä webReader properties:', {
                    accessToken: !!window.webReader.accessToken,
                    articles: window.webReader.articles ? window.webReader.articles.length : 0,
                    redirectUri: window.webReader.redirectUri,
                    aiCategoriesEnabled: window.webReader.aiCategoriesEnabled
                });
            } else {
                console.log('‚ùå webReader: NOT INITIALIZED');
            }

            return elements;
        };

        // IMPROVED AI CATEGORIZATION SYSTEM
        class ImprovedCategorizer {
            constructor() {
                this.categoryKeywords = this.initializeImprovedCategoryKeywords();
                this.categoryExclusions = this.initializeCategoryExclusions();
                this.semanticPatterns = this.initializeSemanticPatterns();
                this.userCorrections = new Map(); // Learn from user corrections
                this.debugMode = false;
            }

            // IMPROVED: More specific and exclusive keyword sets
            initializeImprovedCategoryKeywords() {
                return {
                    'Technology': {
                        icon: 'üíª',
                        confidence: 'high',
                        primary: ['programming', 'software', 'developer', 'coding', 'javascript', 'python', 'react', 'api', 'database', 'algorithm', 'framework', 'debugging', 'github', 'stackoverflow'],
                        secondary: ['tech', 'digital', 'computer', 'web development', 'mobile app', 'artificial intelligence', 'machine learning', 'blockchain', 'cybersecurity'],
                        domains: ['github.com', 'stackoverflow.com', 'dev.to', 'techcrunch.com', 'medium.com', 'hackernoon.com'],
                        weight: 1.0
                    },
                    'Science': {
                        icon: 'üî¨',
                        confidence: 'high',
                        primary: ['research', 'study', 'experiment', 'discovery', 'scientific', 'medical', 'clinical trial', 'peer review', 'hypothesis', 'methodology'],
                        secondary: ['biology', 'chemistry', 'physics', 'medicine', 'health', 'vaccine', 'genome', 'climate science'],
                        domains: ['arxiv.org', 'nature.com', 'science.org', 'pubmed.ncbi.nlm.nih.gov', 'nih.gov'],
                        excludeKeywords: ['science fiction', 'data science'], // Avoid sci-fi and data science
                        weight: 1.2
                    },
                    'Business': {
                        icon: 'üíº',
                        confidence: 'high',
                        primary: ['startup', 'entrepreneur', 'investment', 'funding', 'revenue', 'profit', 'business model', 'market analysis', 'strategy'],
                        secondary: ['finance', 'marketing', 'sales', 'management', 'corporate', 'ipo', 'venture capital'],
                        domains: ['bloomberg.com', 'forbes.com', 'businessinsider.com', 'harvard.business.review'],
                        weight: 1.0
                    },
                    'Politics': {
                        icon: 'üèõÔ∏è',
                        confidence: 'medium',
                        primary: ['election', 'government', 'policy', 'congress', 'senate', 'parliament', 'vote', 'legislation', 'political'],
                        secondary: ['democracy', 'republican', 'democrat', 'conservative', 'liberal', 'campaign', 'candidate'],
                        domains: ['politico.com', 'washingtonpost.com', 'nytimes.com'],
                        weight: 0.9
                    },
                    'Philosophy': {
                        icon: 'ü§î',
                        confidence: 'medium',
                        primary: ['philosophy', 'philosophical', 'ethics', 'moral', 'morality', 'epistemology', 'metaphysics', 'logic', 'reasoning'],
                        secondary: ['consciousness', 'existentialism', 'stoicism', 'buddhism', 'mindfulness', 'meditation', 'wisdom', 'truth'],
                        domains: ['plato.stanford.edu', 'philpapers.org', 'philosophynow.org', 'aeon.co'],
                        weight: 0.8
                    },
                    'Psychology': {
                        icon: 'üß†',
                        confidence: 'medium',
                        primary: ['psychology', 'psychological', 'mental health', 'therapy', 'counseling', 'behavior', 'cognitive', 'emotion'],
                        secondary: ['personality', 'depression', 'anxiety', 'stress', 'trauma', 'ptsd', 'mindfulness', 'self-help'],
                        domains: ['psychologytoday.com', 'apa.org', 'psych.org', 'mindful.org'],
                        weight: 0.9
                    },
                    'News': {
                        icon: 'üì∞',
                        confidence: 'medium',
                        primary: ['breaking news', 'reporting', 'journalist', 'investigation', 'headline', 'press release'],
                        secondary: ['current events', 'news', 'media', 'breaking', 'urgent', 'live coverage'],
                        domains: ['bbc.com', 'cnn.com', 'reuters.com', 'ap.org'],
                        weight: 0.8
                    },
                    'Health': {
                        icon: 'üè•',
                        confidence: 'high',
                        primary: ['medical', 'healthcare', 'treatment', 'diagnosis', 'patient', 'clinical', 'therapeutic', 'wellness'],
                        secondary: ['fitness', 'nutrition', 'exercise', 'mental health', 'therapy', 'diet'],
                        domains: ['mayoclinic.org', 'webmd.com', 'healthline.com'],
                        excludeKeywords: ['health insurance'], // Business-related health topics
                        weight: 1.1
                    },
                    'Education': {
                        icon: 'üéì',
                        confidence: 'high',
                        primary: ['learning', 'education', 'course', 'curriculum', 'academic', 'university', 'school', 'teaching'],
                        secondary: ['tutorial', 'lesson', 'training', 'certification', 'degree', 'student'],
                        domains: ['coursera.org', 'edx.org', 'khanacademy.org', 'mit.edu', 'stanford.edu'],
                        weight: 1.0
                    },
                    'Design': {
                        icon: 'üé®',
                        confidence: 'high',
                        primary: ['design', 'designer', 'ui', 'ux', 'user experience', 'user interface', 'visual', 'graphic'],
                        secondary: ['creative', 'art', 'illustration', 'typography', 'color', 'layout', 'prototype'],
                        domains: ['dribbble.com', 'behance.net', 'medium.com', 'uxdesign.cc'],
                        weight: 1.0
                    },
                    'Entertainment': {
                        icon: 'üé¨',
                        confidence: 'medium',
                        primary: ['movie', 'film', 'tv show', 'series', 'music', 'game', 'gaming', 'entertainment'],
                        secondary: ['cinema', 'television', 'streaming', 'netflix', 'spotify', 'celebrity', 'hollywood'],
                        domains: ['youtube.com', 'netflix.com', 'imdb.com', 'ign.com', 'variety.com'],
                        weight: 0.8
                    },
                    'Sports': {
                        icon: '‚öΩ',
                        confidence: 'medium',
                        primary: ['sports', 'sport', 'football', 'soccer', 'basketball', 'baseball', 'tennis', 'olympics'],
                        secondary: ['athlete', 'team', 'game', 'match', 'tournament', 'championship', 'league'],
                        domains: ['espn.com', 'sports.yahoo.com', 'bleacherreport.com'],
                        weight: 0.8
                    },
                    'Travel': {
                        icon: '‚úàÔ∏è',
                        confidence: 'medium',
                        primary: ['travel', 'traveling', 'trip', 'vacation', 'holiday', 'tourism', 'destination'],
                        secondary: ['flight', 'hotel', 'adventure', 'explore', 'backpacking', 'hiking'],
                        domains: ['tripadvisor.com', 'booking.com', 'airbnb.com', 'lonelyplanet.com'],
                        weight: 0.8
                    },
                    'Food': {
                        icon: 'üç≥',
                        confidence: 'medium',
                        primary: ['recipe', 'cooking', 'chef', 'cuisine', 'restaurant', 'food'],
                        secondary: ['meal', 'dish', 'baking', 'nutrition', 'diet', 'ingredient'],
                        domains: ['allrecipes.com', 'foodnetwork.com', 'epicurious.com'],
                        weight: 0.8
                    },
                    'Environment': {
                        icon: 'üå±',
                        confidence: 'medium',
                        primary: ['environment', 'climate change', 'global warming', 'sustainability', 'renewable energy'],
                        secondary: ['ecology', 'conservation', 'pollution', 'carbon', 'emissions', 'green'],
                        domains: ['greenpeace.org', 'wwf.org', 'epa.gov'],
                        weight: 0.9
                    },
                    'Lifestyle': {
                        icon: 'üè†',
                        confidence: 'low',
                        primary: ['lifestyle', 'personal development', 'self-improvement', 'productivity', 'habits'],
                        secondary: ['home', 'family', 'relationships', 'fashion', 'beauty', 'shopping'],
                        domains: ['pinterest.com', 'instagram.com', 'buzzfeed.com'],
                        weight: 0.7
                    }
                };
            }

            // NEW: Category exclusions to prevent misclassification
            initializeCategoryExclusions() {
                return {
                    'Technology': ['science fiction', 'tech news', 'tech stocks'], // Don't categorize sci-fi or business news as tech
                    'Science': ['computer science', 'data science'], // These should go to Technology
                    'Business': ['business intelligence'], // This should go to Technology
                    'Health': ['health policy', 'healthcare reform'], // These should go to Politics
                    'Education': ['educational technology'], // This should go to Technology
                };
            }

            // NEW: Semantic patterns for better context understanding
            initializeSemanticPatterns() {
                return {
                    'howto_pattern': /how\s+to\s+[\w\s]+/gi,
                    'tutorial_pattern': /(tutorial|guide|step-by-step|walkthrough)/gi,
                    'review_pattern': /(review|comparison|vs\.?|versus)/gi,
                    'news_pattern': /(breaking|urgent|just\s+in|developing)/gi,
                    'research_pattern': /(study\s+shows|research\s+finds|according\s+to\s+study)/gi,
                    'opinion_pattern': /(opinion|editorial|commentary|my\s+thoughts)/gi
                };
            }

            // IMPROVED: Much more sophisticated categorization
            categorizeArticle(article) {
                const title = (article.title || '').toLowerCase();
                const excerpt = (article.excerpt || '').toLowerCase();
                const content = this.getArticleContentForAnalysis(article).toLowerCase();
                const domain = this.getDomain(article.url).toLowerCase();
                const url = article.url.toLowerCase();

                // Combined text for analysis
                const fullText = `${title} ${title} ${excerpt} ${content}`.substring(0, 3000);

                if (this.debugMode) {
                    console.log(`üîç Analyzing: "${title.substring(0, 50)}..."`);
                    console.log(`üìù Content length: ${fullText.length} chars`);
                }

                const categoryScores = new Map();
                let analysisDetails = {};

                // STEP 1: Check for exclusions first
                const excludedCategories = this.checkExclusions(fullText);

                // STEP 2: Score each category with improved logic
                for (const [categoryName, categoryData] of Object.entries(this.categoryKeywords)) {
                    if (excludedCategories.has(categoryName)) {
                        if (this.debugMode) console.log(`‚ùå ${categoryName} excluded`);
                        continue;
                    }

                    let score = 0;
                    let details = { reasons: [], confidence: categoryData.confidence };

                    // A. DOMAIN ANALYSIS (Reduced weight, more specific)
                    score += this.analyzeDomain(domain, categoryData, details);

                    // B. TITLE ANALYSIS (Most important - improved)
                    score += this.analyzeTitle(title, categoryData, details);

                    // C. CONTENT ANALYSIS (Improved semantic analysis)
                    score += this.analyzeContent(fullText, categoryData, details);

                    // D. SEMANTIC PATTERN MATCHING (NEW)
                    score += this.analyzeSemanticPatterns(fullText, categoryName, details);

                    // E. CONTEXTUAL BONUSES (NEW)
                    score += this.applyContextualBonuses(article, categoryName, details);

                    // F. USER CORRECTION LEARNING (NEW)
                    score += this.applyUserLearning(article, categoryName, details);

                    // Apply category weight
                    score *= categoryData.weight || 1.0;

                    categoryScores.set(categoryName, score);
                    analysisDetails[categoryName] = details;

                    if (this.debugMode && score > 0) {
                        console.log(`üìä ${categoryName}: ${score.toFixed(1)} points - ${details.reasons.join(', ')}`);
                    }
                }

                // STEP 3: Advanced decision making
                return this.makeSmartCategoryDecision(categoryScores, analysisDetails, article);
            }

            // IMPROVED: More specific domain analysis
            analyzeDomain(domain, categoryData, details) {
                let score = 0;

                // Exact domain matches (high confidence)
                if (categoryData.domains) {
                    for (const targetDomain of categoryData.domains) {
                        if (domain === targetDomain || domain.endsWith(targetDomain)) {
                            score += 150; // Reduced from 300
                            details.reasons.push(`exact-domain:${targetDomain}`);
                            break;
                        }
                    }
                }

                // Partial domain matches (lower confidence)
                if (score === 0 && categoryData.domains) {
                    for (const targetDomain of categoryData.domains) {
                        const domainKey = targetDomain.split('.')[0];
                        if (domain.includes(domainKey) && domainKey.length > 3) {
                            score += 50;
                            details.reasons.push(`partial-domain:${domainKey}`);
                            break;
                        }
                    }
                }

                return score;
            }

            // IMPROVED: Better title analysis with position weighting
            analyzeTitle(title, categoryData, details) {
                let score = 0;
                const titleWords = title.split(/\s+/);

                // Primary keywords (most important)
                if (categoryData.primary) {
                    for (const keyword of categoryData.primary) {
                        const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                        const matches = title.match(regex);
                        if (matches) {
                            // Weight by position (beginning of title is more important)
                            const position = title.indexOf(keyword.toLowerCase());
                            const positionWeight = position < 20 ? 1.5 : position < 50 ? 1.2 : 1.0;

                            score += matches.length * 80 * positionWeight;
                            details.reasons.push(`primary-title:${keyword}(${matches.length}x)`);
                        }
                    }
                }

                // Secondary keywords (less important)
                if (categoryData.secondary) {
                    for (const keyword of categoryData.secondary) {
                        const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                        const matches = title.match(regex);
                        if (matches) {
                            score += matches.length * 40;
                            details.reasons.push(`secondary-title:${keyword}(${matches.length}x)`);
                        }
                    }
                }

                return score;
            }

            // IMPROVED: Better content analysis with density consideration
            analyzeContent(content, categoryData, details) {
                let score = 0;
                const contentLength = content.length;

                if (contentLength < 100) return 0; // Skip if too little content

                // Primary keywords in content
                if (categoryData.primary) {
                    for (const keyword of categoryData.primary) {
                        const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                        const matches = content.match(regex);
                        if (matches) {
                            // Consider keyword density
                            const density = matches.length / (contentLength / 100);
                            const densityScore = Math.min(density * 20, 60);
                            score += densityScore;

                            if (matches.length > 2) {
                                details.reasons.push(`primary-content:${keyword}(${matches.length}x)`);
                            }
                        }
                    }
                }

                // Secondary keywords in content
                if (categoryData.secondary) {
                    for (const keyword of categoryData.secondary) {
                        const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                        const matches = content.match(regex);
                        if (matches) {
                            const density = matches.length / (contentLength / 100);
                            const densityScore = Math.min(density * 10, 30);
                            score += densityScore;
                        }
                    }
                }

                return score;
            }

            // NEW: Semantic pattern analysis
            analyzeSemanticPatterns(text, categoryName, details) {
                let score = 0;

                // How-to articles often belong to Education
                if (this.semanticPatterns.howto_pattern.test(text) && categoryName === 'Education') {
                    score += 30;
                    details.reasons.push('howto-pattern');
                }

                // Reviews often belong to Technology or Entertainment
                if (this.semanticPatterns.review_pattern.test(text) &&
                    ['Technology', 'Entertainment'].includes(categoryName)) {
                    score += 20;
                    details.reasons.push('review-pattern');
                }

                // Research patterns for Science
                if (this.semanticPatterns.research_pattern.test(text) && categoryName === 'Science') {
                    score += 40;
                    details.reasons.push('research-pattern');
                }

                // News patterns
                if (this.semanticPatterns.news_pattern.test(text) && categoryName === 'News') {
                    score += 50;
                    details.reasons.push('news-pattern');
                }

                return score;
            }

            // NEW: Contextual bonuses based on article characteristics
            applyContextualBonuses(article, categoryName, details) {
                let score = 0;

                // Length-based bonuses
                const contentLength = this.getArticleContentForAnalysis(article).length;

                // Long-form content often indicates educational or scientific content
                if (contentLength > 3000 && ['Education', 'Science'].includes(categoryName)) {
                    score += 15;
                    details.reasons.push('long-form-content');
                }

                // Short content might be news
                if (contentLength < 1000 && categoryName === 'News') {
                    score += 10;
                    details.reasons.push('short-form-news');
                }

                // Check for technical indicators
                const technicalIndicators = ['function', 'class', 'import', 'const', 'var', 'def ', 'return', '{', '}'];
                const techCount = technicalIndicators.filter(indicator =>
                    article.content && article.content.includes(indicator)
                ).length;

                if (techCount >= 3 && categoryName === 'Technology') {
                    score += 25;
                    details.reasons.push('code-detected');
                }

                return score;
            }

            // NEW: Learn from user corrections
            applyUserLearning(article, categoryName, details) {
                // This would be populated when users correct categorizations
                const correctionKey = this.generateCorrectionKey(article);
                if (this.userCorrections.has(correctionKey)) {
                    const correction = this.userCorrections.get(correctionKey);
                    if (correction.category === categoryName) {
                        details.reasons.push('user-learned');
                        return 100; // Strong bonus for learned corrections
                    } else if (correction.rejected && correction.rejected.includes(categoryName)) {
                        details.reasons.push('user-rejected');
                        return -50; // Penalty for rejected categories
                    }
                }
                return 0;
            }

            // NEW: Check for exclusion patterns
            checkExclusions(text) {
                const excluded = new Set();

                for (const [category, exclusions] of Object.entries(this.categoryExclusions)) {
                    for (const exclusion of exclusions) {
                        if (text.includes(exclusion.toLowerCase())) {
                            excluded.add(category);
                            if (this.debugMode) {
                                console.log(`‚ùå Excluding ${category} due to: ${exclusion}`);
                            }
                        }
                    }
                }

                return excluded;
            }

            // IMPROVED: Smarter decision making
            makeSmartCategoryDecision(categoryScores, analysisDetails, article) {
                // Sort scores
                const sortedScores = Array.from(categoryScores.entries())
                    .sort((a, b) => b[1] - a[1])
                    .filter(([_, score]) => score > 0);

                if (sortedScores.length === 0) {
                    return this.handleNoCategory(article);
                }

                const [bestCategory, bestScore] = sortedScores[0];
                const secondBestScore = sortedScores.length > 1 ? sortedScores[1][1] : 0;
                const confidenceGap = bestScore - secondBestScore;

                if (this.debugMode) {
                    console.log(`üèÜ Best: ${bestCategory} (${bestScore.toFixed(1)})`);
                    console.log(`ü•à Second: ${sortedScores[1] ? `${sortedScores[1][0]} (${sortedScores[1][1].toFixed(1)})` : 'None'}`);
                    console.log(`üìä Confidence gap: ${confidenceGap.toFixed(1)}`);
                }

                // IMPROVED: Dynamic thresholds based on content availability
                const hasRichContent = this.getArticleContentForAnalysis(article).length > 500;
                const minThreshold = hasRichContent ? 60 : 40;
                const minConfidenceGap = hasRichContent ? 15 : 10;

                // High confidence decision
                if (bestScore >= minThreshold && confidenceGap >= minConfidenceGap) {
                    article.categoryScore = Math.round(bestScore);
                    article.categoryConfidence = Math.round(confidenceGap);
                    article.categoryAnalysis = analysisDetails[bestCategory];
                    article.aiEnhanced = false;

                    if (this.debugMode) {
                        console.log(`‚úÖ High confidence: ${bestCategory}`);
                    }

                    return bestCategory;
                }

                // Low confidence - use improved fallback
                const fallbackCategory = this.improvedFallback(article, sortedScores);
                article.categoryScore = Math.round(bestScore);
                article.categoryConfidence = Math.round(confidenceGap);
                article.aiEnhanced = true;

                if (this.debugMode) {
                    console.log(`ü§ñ AI fallback: ${fallbackCategory}`);
                }

                return fallbackCategory;
            }

            // IMPROVED: Better fallback logic
            improvedFallback(article, sortedScores) {
                const title = article.title.toLowerCase();
                const domain = this.getDomain(article.url).toLowerCase();

                // Pattern-based fallbacks
                if (title.includes('how to') || title.includes('tutorial') || title.includes('guide')) {
                    return 'Education';
                }

                if (title.includes('review') || title.includes('vs') || title.includes('comparison')) {
                    // Context-aware review categorization
                    if (domain.includes('tech') || title.includes('software') || title.includes('app')) {
                        return 'Technology';
                    }
                    if (title.includes('movie') || title.includes('game') || title.includes('show')) {
                        return 'Entertainment';
                    }
                    return 'Lifestyle';
                }

                // Use the best scoring category if it's reasonable
                if (sortedScores.length > 0 && sortedScores[0][1] > 20) {
                    return sortedScores[0][0];
                }

                return 'Lifestyle'; // Final fallback
            }

            // Handle articles that don't fit any category well
            handleNoCategory(article) {
                article.categoryScore = 0;
                article.categoryConfidence = 0;
                article.aiEnhanced = true;

                // Try to guess based on domain
                const domain = this.getDomain(article.url).toLowerCase();

                if (domain.includes('github') || domain.includes('stackoverflow')) return 'Technology';
                if (domain.includes('news') || domain.includes('bbc') || domain.includes('cnn')) return 'News';
                if (domain.includes('edu') || domain.includes('coursera')) return 'Education';

                return 'Lifestyle';
            }

            // Utility functions
            getDomain(url) {
                try {
                    return new URL(url).hostname.replace('www.', '');
                } catch (e) {
                    return url;
                }
            }

            getArticleContentForAnalysis(article) {
                const contentFields = ['content', 'textContent', 'excerpt', 'description', 'summary'];
                let combinedContent = '';

                for (const field of contentFields) {
                    if (article[field] && typeof article[field] === 'string') {
                        combinedContent += ' ' + article[field];
                    }
                }

                return combinedContent.trim() || article.title || '';
            }

            generateCorrectionKey(article) {
                // Generate a key for tracking user corrections
                return `${this.getDomain(article.url)}_${article.title.substring(0, 30).replace(/[^a-zA-Z0-9]/g, '_')}`;
            }

            // NEW: Allow users to correct categorizations
            correctCategorization(article, correctCategory, wrongCategory = null) {
                const key = this.generateCorrectionKey(article);

                if (!this.userCorrections.has(key)) {
                    this.userCorrections.set(key, {
                        category: correctCategory,
                        rejected: []
                    });
                } else {
                    this.userCorrections.get(key).category = correctCategory;
                }

                if (wrongCategory) {
                    const correction = this.userCorrections.get(key);
                    if (!correction.rejected.includes(wrongCategory)) {
                        correction.rejected.push(wrongCategory);
                    }
                }

                console.log(`üìö Learned: "${article.title.substring(0, 30)}..." should be ${correctCategory}`);
            }

            // Enable debug mode for troubleshooting
            enableDebugMode() {
                this.debugMode = true;
                console.log('üîç Categorization debug mode enabled');
            }

            disableDebugMode() {
                this.debugMode = false;
            }
        }

        class MyPocketWebReader {
            constructor() {
                console.log('üèóÔ∏è Creating AI-Enhanced MyPocketWebReader instance...');

                this.clientId = '436e8796-8c40-47c3-9ad5-b8882f3ef7f7';
                this.redirectUri = this.getRedirectUri();
                console.log('üîµ Redirect URI:', this.redirectUri);

                this.accessToken = null;
                this.articles = [];
                this.currentArticle = null;
                this.currentDisplayedArticles = []; // Track what's currently displayed
                this.failedImages = new Set(); // Track articles with failed images

                // IMPROVED AI categorization system
                this.improvedCategorizer = new ImprovedCategorizer();
                this.categories = new Map(); // Store category counts
                this.activeCategory = null; // Currently selected category filter
                this.aiCategoriesEnabled = true; // Enable AI categorization features
                this.categoryAnalytics = new Map(); // Track categorization confidence

                // Category correction system
                this.currentCorrectionArticle = null;
                this.selectedCorrectionCategory = null;

                // Image cache system
                this.imageCache = new Map();
                this.cacheKey = 'mypocket_image_cache';
                this.cacheExpiryDays = 7; // Cache images for 7 days

                // Cross-device image storage
                this.storeImagesInBackup = true; // Enable cross-device image storage
                this.maxImageSizeKB = 500; // Limit to prevent huge backups
                this.cacheSaveTimeout = null; // For debounced saves

                // PKCE-specific properties
                this.codeVerifier = null;
                this.codeChallenge = null;
                this.state = null;

                console.log('‚úÖ AI-Enhanced MyPocketWebReader constructor complete');
                this.init();
            }

            getRedirectUri() {
                const currentUrl = window.location.href;
                const baseUrl = currentUrl.split('#')[0].split('?')[0]; // Remove both fragment and query

                if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {
                    return baseUrl;
                } else {
                    return window.location.origin + window.location.pathname;
                }
            }

            init() {
                console.log('üöÄ Initializing AI-Enhanced MyPocket Web Reader...');
                this.setupEventListeners();
                this.checkAuthFromURL();
                this.loadStoredToken();
                this.loadThemePreference();
                this.loadImageCache();
                this.initializeSidebar();
                console.log('‚úÖ AI-Enhanced initialization complete');
            }

            setupEventListeners() {
                console.log('üîß Setting up event listeners...');

                // Sidebar connect button
                const connectBtnSidebar = document.getElementById('connectBtnSidebar');
                if (connectBtnSidebar) {
                    connectBtnSidebar.addEventListener('click', () => {
                        console.log('üîê Connect button clicked');
                        this.authenticate();
                    });
                    console.log('‚úÖ Connect button event listener added');
                } else {
                    console.error('‚ùå Connect button not found!');
                }

                // Navigation buttons - these exist in the HTML
                const refreshNavBtn = document.getElementById('refreshNavBtn');
                if (refreshNavBtn) {
                    refreshNavBtn.addEventListener('click', () => this.loadArticles());
                }

                const syncNavBtn = document.getElementById('syncNavBtn');
                if (syncNavBtn) {
                    syncNavBtn.addEventListener('click', () => this.forceSyncImages());
                }

                const retryNavBtn = document.getElementById('retryNavBtn');
                if (retryNavBtn) {
                    retryNavBtn.addEventListener('click', () => this.retryFailedImages());
                }

                const searchInput = document.getElementById('searchInput');
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => this.searchArticles(e.target.value));
                }

                const closeReader = document.getElementById('closeReader');
                if (closeReader) {
                    closeReader.addEventListener('click', () => this.closeReader());
                }

                const openOriginal = document.getElementById('openOriginal');
                if (openOriginal) {
                    openOriginal.addEventListener('click', () => this.openOriginal());
                }

                // Search toggle keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ctrl/Cmd + K or / to open search
                    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                        e.preventDefault();
                        this.toggleSearch(true);
                    } else if (e.key === '/' && !this.isInputFocused()) {
                        e.preventDefault();
                        this.toggleSearch(true);
                    } else if (e.key === 'Escape') {
                        this.toggleSearch(false);
                        this.toggleCategoryFilter(false);
                        this.closeMobileSidebar();
                        this.closeCategoryModal();
                    }
                });

                // Close search when clicking outside
                document.addEventListener('click', (e) => {
                    const searchContainer = document.getElementById('searchContainer');
                    const searchNavBtn = document.getElementById('searchNavBtn');

                    if (searchContainer && searchNavBtn &&
                        searchContainer.style.display !== 'none' &&
                        !searchContainer.contains(e.target) &&
                        !searchNavBtn.contains(e.target)) {
                        this.toggleSearch(false);
                    }
                });

                // Close category filter when clicking outside
                document.addEventListener('click', (e) => {
                    const categoryContainer = document.getElementById('categoryContainer');
                    const categoriesNavBtn = document.getElementById('categoriesNavBtn');

                    if (categoryContainer && categoriesNavBtn &&
                        categoryContainer.style.display !== 'none' &&
                        !categoryContainer.contains(e.target) &&
                        !categoriesNavBtn.contains(e.target)) {
                        this.toggleCategoryFilter(false);
                    }
                });

                // Mobile menu setup
                this.setupMobileMenu();
                console.log('‚úÖ Event listeners setup complete');
            }

            // NEW: Category correction methods
            openCategoryCorrection(article, currentDisplayIndex) {
                this.currentCorrectionArticle = article;
                this.currentCorrectionDisplayIndex = currentDisplayIndex;

                const modal = document.getElementById('categoryModal');
                const titleElement = document.getElementById('modalArticleTitle');
                const currentCategoryElement = document.getElementById('modalCurrentCategory');
                const buttonsContainer = document.getElementById('modalCategoryButtons');

                titleElement.textContent = article.title.substring(0, 80) + (article.title.length > 80 ? '...' : '');
                currentCategoryElement.textContent = article.category || 'None';

                // Populate category buttons
                const categories = Object.keys(this.improvedCategorizer.categoryKeywords);
                buttonsContainer.innerHTML = categories.map(category => {
                    const categoryData = this.improvedCategorizer.categoryKeywords[category];
                    return `
                        <button class="category-btn" data-category="${category}">
                            ${categoryData.icon} ${category}
                        </button>
                    `;
                }).join('');

                // Add event listeners to category buttons
                buttonsContainer.querySelectorAll('.category-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        // Remove active class from all buttons
                        buttonsContainer.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
                        // Add active class to clicked button
                        btn.classList.add('active');
                        this.selectedCorrectionCategory = btn.dataset.category;
                    });
                });

                modal.classList.add('active');
            }

            closeCategoryModal() {
                const modal = document.getElementById('categoryModal');
                modal.classList.remove('active');
                this.currentCorrectionArticle = null;
                this.selectedCorrectionCategory = null;
            }

            applyCategoryCorrection() {
                if (!this.currentCorrectionArticle || !this.selectedCorrectionCategory) {
                    return;
                }

                const oldCategory = this.currentCorrectionArticle.category;
                this.currentCorrectionArticle.category = this.selectedCorrectionCategory;

                // Learn from this correction
                this.improvedCategorizer.correctCategorization(
                    this.currentCorrectionArticle,
                    this.selectedCorrectionCategory,
                    oldCategory
                );

                // Update category counts
                if (oldCategory && this.categories.has(oldCategory)) {
                    const oldCount = this.categories.get(oldCategory) - 1;
                    if (oldCount <= 0) {
                        this.categories.delete(oldCategory);
                    } else {
                        this.categories.set(oldCategory, oldCount);
                    }
                }

                this.categories.set(this.selectedCorrectionCategory,
                    (this.categories.get(this.selectedCorrectionCategory) || 0) + 1);

                // Update UI
                this.updateCategoryUI();
                this.displayArticles(this.currentDisplayedArticles);
                this.updateArticleCounts();

                this.updateStatus(`‚úÖ Corrected "${this.currentCorrectionArticle.title.substring(0, 30)}..." to ${this.selectedCorrectionCategory}`, 'success');

                this.closeCategoryModal();

                // Save correction to backup if connected
                if (this.accessToken) {
                    setTimeout(() => this.updateOneDriveBackup(), 1000);
                }
            }

            // IMPROVED: Use the new categorization system
            categorizeArticle(article) {
                return this.improvedCategorizer.categorizeArticle(article);
            }

            // Initialize sidebar functionality
            initializeSidebar() {
                this.sidebarCollapsed = false;
                this.updateSidebarState();
                this.updateMobileMenu();
                this.updateArticleCounts(); // Initialize counts
            }

            // Update article counts in sidebar
            updateArticleCounts() {
                const allArticlesBadge = document.getElementById('allArticlesBadge');
                const categoryBadge = document.getElementById('categoryBadge');

                if (allArticlesBadge) {
                    allArticlesBadge.textContent = this.articles.length;
                }

                if (categoryBadge) {
                    categoryBadge.textContent = this.categories.size;
                }
            }

            // Setup mobile menu
            setupMobileMenu() {
                const mobileMenuBtn = document.getElementById('mobileMenuBtn');
                const isMobile = window.innerWidth <= 768;

                if (mobileMenuBtn) {
                    if (isMobile) {
                        mobileMenuBtn.style.display = 'flex';
                    } else {
                        mobileMenuBtn.style.display = 'none';
                    }
                }

                // Update on resize
                window.addEventListener('resize', () => {
                    this.updateMobileMenu();
                });
            }

            updateMobileMenu() {
                const mobileMenuBtn = document.getElementById('mobileMenuBtn');
                const isMobile = window.innerWidth <= 768;

                if (mobileMenuBtn) {
                    if (isMobile) {
                        mobileMenuBtn.style.display = 'flex';
                    } else {
                        mobileMenuBtn.style.display = 'none';
                        this.closeMobileSidebar(); // Close mobile sidebar when switching to desktop
                    }
                }
            }

            // Sidebar toggle functionality
            toggleSidebar() {
                this.sidebarCollapsed = !this.sidebarCollapsed;
                this.updateSidebarState();
            }

            updateSidebarState() {
                const sidebar = document.getElementById('sidebar');
                const mainContent = document.getElementById('mainContent');
                const toggleIcon = document.getElementById('sidebarToggleIcon');

                if (sidebar && mainContent && toggleIcon) {
                    if (this.sidebarCollapsed) {
                        sidebar.classList.add('collapsed');
                        mainContent.classList.add('sidebar-collapsed');
                        toggleIcon.textContent = '‚ñ∂';
                    } else {
                        sidebar.classList.remove('collapsed');
                        mainContent.classList.remove('sidebar-collapsed');
                        toggleIcon.textContent = '‚óÄ';
                    }
                }
            }

            // Mobile sidebar functionality
            openMobileSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebarOverlay');

                if (sidebar) sidebar.classList.add('open');
                if (overlay) overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            }

            closeMobileSidebar() {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.getElementById('sidebarOverlay');

                if (sidebar) sidebar.classList.remove('open');
                if (overlay) overlay.classList.remove('active');
                document.body.style.overflow = 'auto';
            }

            // Show all articles (navigation function)
            showAllArticles() {
                // Clear any active filters
                this.activeCategory = null;

                // Clear search
                const searchInput = document.getElementById('searchInput');
                if (searchInput && searchInput.value) {
                    searchInput.value = '';
                }

                // Hide any open panels
                this.toggleSearch(false);
                this.toggleCategoryFilter(false);

                // Show all articles
                this.currentDisplayedArticles = this.articles;
                this.displayArticles(this.articles);

                // Update navigation
                this.updateNavigation();

                this.updateStatus(`üìñ Showing all ${this.articles.length} articles`, 'success');
            }

            // Update navigation active states
            updateNavigation() {
                // Remove active class from all nav items
                document.querySelectorAll('.nav-item').forEach(item => {
                    if (item) item.classList.remove('active');
                });

                // Set active based on current state
                const searchContainer = document.getElementById('searchContainer');
                const categoryContainer = document.getElementById('categoryContainer');
                const allArticlesNav = document.getElementById('allArticlesNav');
                const searchNavBtn = document.getElementById('searchNavBtn');
                const categoriesNavBtn = document.getElementById('categoriesNavBtn');

                if (!this.activeCategory && (!searchContainer || !searchContainer.classList.contains('visible'))) {
                    if (allArticlesNav) allArticlesNav.classList.add('active');
                } else if (searchContainer && searchContainer.classList.contains('visible')) {
                    if (searchNavBtn) searchNavBtn.classList.add('active');
                } else if (categoryContainer && categoryContainer.classList.contains('visible')) {
                    if (categoriesNavBtn) categoriesNavBtn.classList.add('active');
                }
            }

            isInputFocused() {
                const activeElement = document.activeElement;
                return activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA');
            }

            // IMPROVED: Re-categorization with better AI
            async recategorizeAllWithAI() {
                if (this.articles.length === 0) {
                    this.updateStatus('‚ùå No articles to categorize. Load articles first.', 'error');
                    return;
                }

                console.log('ü§ñ Starting improved AI categorization...');
                this.updateStatus('ü§ñ AI is analyzing and categorizing your articles...', 'loading');

                // Clear existing categories and analytics
                this.categories.clear();
                this.categoryAnalytics.clear();

                let categorizedCount = 0;
                let aiEnhancedCount = 0;

                // Process in small batches for better UX
                const batchSize = 10;
                for (let i = 0; i < this.articles.length; i += batchSize) {
                    const batch = this.articles.slice(i, i + batchSize);

                    for (const article of batch) {
                        const category = this.categorizeArticle(article);
                        this.categories.set(category, (this.categories.get(category) || 0) + 1);
                        categorizedCount++;

                        if (article.aiEnhanced) {
                            aiEnhancedCount++;
                        }

                        // Update analytics
                        if (!this.categoryAnalytics.has(category)) {
                            this.categoryAnalytics.set(category, {
                                count: 0,
                                totalScore: 0,
                                aiEnhanced: 0,
                                avgScore: 0
                            });
                        }

                        const analytics = this.categoryAnalytics.get(category);
                        analytics.count++;
                        analytics.totalScore += article.categoryScore || 0;
                        analytics.avgScore = Math.round(analytics.totalScore / analytics.count);
                        if (article.aiEnhanced) analytics.aiEnhanced++;
                    }

                    // Update progress
                    const progress = Math.round((categorizedCount / this.articles.length) * 100);
                    this.updateStatus(`ü§ñ AI categorizing... ${categorizedCount}/${this.articles.length} (${progress}%)`, 'loading');

                    // Small delay to prevent UI blocking
                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                console.log(`üéØ Improved AI categorization complete: ${this.categories.size} categories, ${aiEnhancedCount} AI-enhanced`);

                // Update UI
                this.updateCategoryUI();
                this.displayArticles(this.currentDisplayedArticles);
                this.updateArticleCounts();

                const message = `ü§ñ Improved AI categorization complete! ${categorizedCount} articles in ${this.categories.size} categories (${aiEnhancedCount} AI-enhanced)`;
                this.updateStatus(message, 'success');

                // Save to backup if connected
                if (this.accessToken) {
                    try {
                        await this.updateOneDriveBackup();
                        console.log('‚úÖ Updated backup with improved AI categories');
                    } catch (error) {
                        console.error('‚ö†Ô∏è Failed to update backup:', error);
                    }
                }
            }

            // Enhanced category UI with AI indicators and correction buttons
            updateCategoryUI() {
                const categoryChips = document.getElementById('categoryChips');
                if (!categoryChips) return;

                const sortedCategories = Array.from(this.categories.entries())
                    .sort((a, b) => b[1] - a[1]); // Sort by count descending

                const totalArticles = this.articles.length;
                const aiEnhancedTotal = this.articles.filter(a => a.aiEnhanced).length;

                console.log(`üé® Updating improved AI category UI with ${sortedCategories.length} categories (${aiEnhancedTotal} AI-enhanced)`);

                categoryChips.innerHTML = `
                    <div class="category-chip show-all ${!this.activeCategory ? 'active' : ''}" 
                         data-category="null">
                        <span>ü§ñ</span>
                        <span>All Articles</span>
                        <span class="category-count">${totalArticles}</span>
                    </div>
                    ${sortedCategories.map(([category, count]) => {
                    const categoryData = this.improvedCategorizer.categoryKeywords[category] || { icon: 'üìÑ' };
                    const isActive = this.activeCategory === category;
                    const analytics = this.categoryAnalytics.get(category);
                    const aiEnhancedCount = analytics ? analytics.aiEnhanced : 0;
                    const avgScore = analytics ? analytics.avgScore : 0;
                    const isAiEnhanced = aiEnhancedCount > 0;

                    return `
                            <div class="category-chip ${isActive ? 'active' : ''} ${isAiEnhanced ? 'ai-enhanced' : ''}" 
                                 data-category="${category}"
                                 title="Show ${count} ${category.toLowerCase()} articles (${aiEnhancedCount} AI-enhanced, avg score: ${avgScore})">
                                <span>${categoryData.icon}</span>
                                <span>${category}</span>
                                <span class="category-count">${count}</span>
                            </div>
                        `;
                }).join('')}
                `;

                // Add event listeners after HTML is created
                categoryChips.querySelectorAll('.category-chip').forEach(chip => {
                    chip.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const category = chip.getAttribute('data-category');
                        console.log(`üñ±Ô∏è Category chip clicked: "${category}"`);
                        this.filterByCategory(category === 'null' ? null : category);
                    });
                });

                console.log(`‚úÖ Improved AI category UI updated with event listeners`);
            }

            // Toggle category filter visibility
            toggleCategoryFilter(forceState = null) {
                const categoryContainer = document.getElementById('categoryContainer');
                const categoriesNavBtn = document.getElementById('categoriesNavBtn');

                if (!categoryContainer || !categoriesNavBtn) {
                    console.error('Category filter elements not found');
                    return;
                }

                const isCurrentlyVisible = categoryContainer.style.display !== 'none';
                const shouldShow = forceState !== null ? forceState : !isCurrentlyVisible;

                if (shouldShow) {
                    console.log('üè∑Ô∏è Opening improved AI category filter...');

                    // Ensure categories are up to date
                    if (this.categories.size === 0 && this.articles.length > 0) {
                        this.recategorizeAllWithAI();
                    }

                    // Show category filter
                    categoryContainer.style.display = 'block';
                    setTimeout(() => {
                        categoryContainer.classList.add('visible');
                    }, 10);

                    // Update navigation
                    this.updateNavigation();

                    this.updateStatus('ü§ñ Improved AI category filter active - Click a category to filter articles', 'success');
                } else {
                    console.log('üè∑Ô∏è Closing category filter...');

                    // Hide category filter
                    categoryContainer.classList.remove('visible');
                    setTimeout(() => {
                        if (!categoryContainer.classList.contains('visible')) {
                            categoryContainer.style.display = 'none';
                        }
                    }, 300);

                    // Clear any active category filter if closing
                    if (this.activeCategory) {
                        console.log('üè∑Ô∏è Clearing active category filter');
                        this.filterByCategory(null);
                    }

                    // Update navigation
                    this.updateNavigation();
                }
            }

            // Filter articles by category (enhanced)
            filterByCategory(category) {
                console.log(`üéØ FILTERING BY CATEGORY: "${category}"`);
                this.activeCategory = category;

                let filtered;
                if (!category) {
                    // Show all articles
                    filtered = this.articles;
                    console.log(`üìÇ Showing all ${filtered.length} articles`);
                } else {
                    // ENSURE ALL ARTICLES ARE CATEGORIZED FIRST
                    console.log(`üîç Ensuring all articles are categorized before filtering...`);
                    this.articles.forEach((article, index) => {
                        if (!article.category) {
                            this.categorizeArticle(article);
                            console.log(`üìÇ Article ${index}: "${article.title.substring(0, 30)}..." categorized as "${article.category}"`);
                        }
                    });

                    // Filter by specific category
                    filtered = this.articles.filter(article => {
                        const matches = article.category === category;
                        if (matches) {
                            console.log(`‚úÖ MATCH: "${article.title.substring(0, 30)}..." is in category "${category}"`);
                        }
                        return matches;
                    });

                    console.log(`üéØ Found ${filtered.length} articles in category "${category}"`);

                    // Debug: Show what categories we actually have
                    const categoryCounts = {};
                    this.articles.forEach(article => {
                        const cat = article.category || 'Uncategorized';
                        categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
                    });
                    console.log(`üìä Available categories:`, categoryCounts);
                }

                this.currentDisplayedArticles = filtered;
                this.displayArticles(filtered);

                // Update category UI to show active state
                this.updateCategoryUI();

                // Update navigation
                this.updateNavigation();

                // Update status
                if (!category) {
                    this.updateStatus(`üìÇ Showing all ${filtered.length} articles`, 'success');
                } else {
                    const categoryData = this.improvedCategorizer.categoryKeywords[category] || { icon: 'üìÑ' };
                    const analytics = this.categoryAnalytics.get(category);
                    const aiCount = analytics ? analytics.aiEnhanced : 0;

                    if (filtered.length === 0) {
                        this.updateStatus(`‚ùå No articles found in "${category}" category. Try a different category.`, 'error');
                    } else {
                        const aiText = aiCount > 0 ? ` (${aiCount} AI-enhanced)` : '';
                        this.updateStatus(`${categoryData.icon} Showing ${filtered.length} ${category.toLowerCase()} articles${aiText}`, 'success');
                    }
                }

                console.log(`üìÇ Filter complete: ${filtered.length} articles displayed`);
            }

            // Show AI categories help
            showAIHelp() {
                const helpText = `
MyPocket Improved AI Categories Help:
====================================

ü§ñ IMPROVED AI CATEGORIZATION FEATURES:

1Ô∏è‚É£ SMARTER ANALYSIS:
   ‚Ä¢ Content-aware keyword analysis (not just simple matching)
   ‚Ä¢ Position-based scoring (title beginning matters more)
   ‚Ä¢ Keyword density analysis for better accuracy
   ‚Ä¢ Semantic pattern recognition

2Ô∏è‚É£ ENHANCED DECISION MAKING:
   ‚Ä¢ Dynamic thresholds based on content quality
   ‚Ä¢ Confidence gap analysis for better decisions
   ‚Ä¢ Smart fallback patterns for ambiguous content
   ‚Ä¢ Category-specific scoring weights

3Ô∏è‚É£ EXCLUSION LOGIC:
   ‚Ä¢ Prevents "Data Science" from going to Science
   ‚Ä¢ Avoids "Science Fiction" categorized as Science
   ‚Ä¢ Context-aware disambiguation

4Ô∏è‚É£ LEARNING SYSTEM:
   ‚Ä¢ Click category badges to correct wrong categories
   ‚Ä¢ System learns from your corrections
   ‚Ä¢ Applies learned patterns to similar articles
   ‚Ä¢ Tracks and avoids rejected categories

5Ô∏è‚É£ AVAILABLE CATEGORIES:
   üìÇ Core: Technology, Business, Science, Design, News, Education
   üß† Enhanced: Politics, Philosophy, Psychology, Environment
   üéØ Lifestyle: Health, Sports, Travel, Food, Entertainment

6Ô∏è‚É£ CATEGORIZATION IMPROVEMENTS:
   ‚Ä¢ Reduced domain over-weighting (was 300pts, now 150pts)
   ‚Ä¢ Better content analysis with density consideration
   ‚Ä¢ Semantic patterns: "how-to" ‚Üí Education, reviews ‚Üí contextual
   ‚Ä¢ Technical code detection ‚Üí Technology

üîß CORRECTION FEATURES:

‚Ä¢ Click any category badge on an article to correct it
‚Ä¢ Use "üß† AI Re-categorize" to refresh all with improvements  
‚Ä¢ System learns and applies corrections to similar content
‚Ä¢ Debug mode available: webReader.improvedCategorizer.enableDebugMode()

üí° TIPS:
- The system now understands context, not just keywords
- Category corrections teach the AI for future articles
- Higher confidence scores = more accurate categorizations
- Low confidence articles get "AI Enhanced" flag

üéØ MUCH MORE ACCURATE:
The new system should provide significantly better categorization by understanding context and learning from corrections!
                `;

                alert(helpText);
            }

            // NEW: Toggle search functionality
            toggleSearch(forceState = null) {
                const searchContainer = document.getElementById('searchContainer');
                const searchInput = document.getElementById('searchInput');
                const searchNavBtn = document.getElementById('searchNavBtn');

                if (!searchContainer || !searchInput || !searchNavBtn) {
                    console.error('Search elements not found');
                    return;
                }

                const isCurrentlyVisible = searchContainer.style.display !== 'none';
                const shouldShow = forceState !== null ? forceState : !isCurrentlyVisible;

                if (shouldShow) {
                    // Show search
                    searchContainer.style.display = 'block';
                    setTimeout(() => {
                        searchContainer.classList.add('visible');
                        searchInput.focus();
                    }, 10);

                    // Update navigation
                    this.updateNavigation();

                    this.updateStatus('üîç AI-powered search active - Type to search or press Escape to close', 'success');
                } else {
                    // Hide search
                    searchContainer.classList.remove('visible');
                    setTimeout(() => {
                        if (!searchContainer.classList.contains('visible')) {
                            searchContainer.style.display = 'none';
                        }
                    }, 300);

                    // Clear search if closing
                    if (searchInput.value) {
                        searchInput.value = '';
                        this.searchArticles('');
                    }

                    // Remove focus
                    searchInput.blur();

                    // Update navigation
                    this.updateNavigation();
                }
            }
        }

            // Enhanced theme management
            toggleDarkMode() {
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('mypocket_theme', newTheme);

                const darkModeIcon = document.getElementById('darkModeIcon');
                const darkModeText = document.getElementById('darkModeText');

                if (darkModeIcon && darkModeText) {
                    if (newTheme === 'dark') {
                        darkModeIcon.textContent = '‚òÄÔ∏è';
                        darkModeText.textContent = 'Light Mode';
                    } else {
                        darkModeIcon.textContent = 'üåô';
                        darkModeText.textContent = 'Dark Mode';
                    }
                }

                this.updateStatus(`üé® Switched to ${newTheme} mode`, 'success');
            }

            loadThemePreference() {
                const savedTheme = localStorage.getItem('mypocket_theme') || 'light';
                document.documentElement.setAttribute('data-theme', savedTheme);

                const darkModeIcon = document.getElementById('darkModeIcon');
                const darkModeText = document.getElementById('darkModeText');

                if (darkModeIcon && darkModeText) {
                    if (savedTheme === 'dark') {
                        darkModeIcon.textContent = '‚òÄÔ∏è';
                        darkModeText.textContent = 'Light Mode';
                    } else {
                        darkModeIcon.textContent = 'üåô';
                        darkModeText.textContent = 'Dark Mode';
                    }
                }
            }

            // Toggle test mode for debugging
            toggleTestMode() {
                document.body.classList.toggle('test-mode');
                const isTestMode = document.body.classList.contains('test-mode');
                this.updateStatus(`${isTestMode ? 'üëÅÔ∏è Test mode ON - buttons always visible' : 'üëÅÔ∏è Test mode OFF - normal hover behavior'}`, 'success');
            }

            // Enhanced debug info
            showDebugInfo() {
                const cacheStats = this.getCacheStats();
                const categorizedCount = this.articles.filter(a => a.category).length;
                const aiEnhancedCount = this.articles.filter(a => a.aiEnhanced).length;
                const imagesWithCache = this.articles.filter(a => a.cachedImage).length;

                const debugInfo = `
MyPocket Debug Information:
==========================

üìä ARTICLES:
‚Ä¢ Total: ${this.articles.length}
‚Ä¢ Categorized: ${categorizedCount}/${this.articles.length}
‚Ä¢ AI Enhanced: ${aiEnhancedCount}/${this.articles.length}
‚Ä¢ With Images: ${imagesWithCache}/${this.articles.length}

üè∑Ô∏è CATEGORIES:
‚Ä¢ Total Categories: ${this.categories.size}
‚Ä¢ Active Filter: ${this.activeCategory || 'None'}
‚Ä¢ Category Analytics: ${this.categoryAnalytics.size} tracked

üíæ CACHE SYSTEM:
‚Ä¢ Local Images: ${cacheStats.total}
‚Ä¢ Memory Usage: ~${Math.round(cacheStats.memoryUsage / 1024)}KB
‚Ä¢ Failed Images: ${this.failedImages.size}

üîê CONNECTION:
‚Ä¢ Access Token: ${this.accessToken ? '‚úÖ Present' : '‚ùå Missing'}
‚Ä¢ Redirect URI: ${this.redirectUri}
‚Ä¢ Client ID: ${this.clientId.substring(0, 8)}...

ü§ñ AI CATEGORIZER:
‚Ä¢ Categories Available: ${Object.keys(this.improvedCategorizer.categoryKeywords).length}
‚Ä¢ User Corrections: ${this.improvedCategorizer.userCorrections.size}
‚Ä¢ Debug Mode: ${this.improvedCategorizer.debugMode ? 'ON' : 'OFF'}

üñºÔ∏è IMAGE SYSTEM:
‚Ä¢ Store in Backup: ${this.storeImagesInBackup ? 'YES' : 'NO'}
‚Ä¢ Max Size: ${this.maxImageSizeKB}KB
‚Ä¢ Cache Expiry: ${this.cacheExpiryDays} days

üì± UI STATE:
‚Ä¢ Sidebar Collapsed: ${this.sidebarCollapsed}
‚Ä¢ Search Visible: ${document.getElementById('searchContainer')?.style.display !== 'none'}
‚Ä¢ Categories Visible: ${document.getElementById('categoryContainer')?.style.display !== 'none'}

üß™ DEBUGGING COMMANDS:
‚Ä¢ webReader.improvedCategorizer.enableDebugMode() - Enable AI debug
‚Ä¢ webReader.recategorizeAllWithAI() - Refresh AI categories
‚Ä¢ window.debugMyPocket() - Check elements
    `;

                alert(debugInfo);
            }

            // Article content management
            loadArticleContent(article) {
                const readerContent = document.getElementById('readerContent');
                if (!readerContent) return;

                // Try multiple content fields
                const contentFields = ['content', 'readableContent', 'fullContent', 'textContent', 'html', 'body'];
                let content = null;

                for (const field of contentFields) {
                    if (article[field] && typeof article[field] === 'string' && article[field].trim().length > 100) {
                        content = article[field];
                        break;
                    }
                }

                if (content) {
                    // Clean and format content
                    const cleanContent = this.cleanArticleContent(content);
                    readerContent.innerHTML = cleanContent;
                    console.log(`‚úÖ Content loaded from article data (${content.length} chars)`);
                } else {
                    // Show fallback content
                    readerContent.innerHTML = `
            <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                <h3>üìÑ Content Preview</h3>
                <p><strong>Title:</strong> ${this.escapeHtml(article.title)}</p>
                ${article.excerpt ? `<p><strong>Excerpt:</strong> ${this.escapeHtml(article.excerpt)}</p>` : ''}
                <hr style="margin: 20px 0; border: 1px solid var(--border);">
                <p>Full content not available in backup.</p>
                <p>Click "Open Original" below to read the complete article.</p>
                <div style="margin-top: 20px;">
                    <button onclick="webReader.openOriginal()" style="
                        background: var(--primary-color);
                        color: white;
                        border: none;
                        padding: 12px 24px;
                        border-radius: 8px;
                        cursor: pointer;
                        font-size: 16px;
                    ">üîó Open Original Article</button>
                </div>
            </div>
        `;
                    console.log(`‚ö†Ô∏è Using fallback content preview`);
                }
            }

            cleanArticleContent(content) {
                // Remove script tags and other potentially harmful elements
                let cleanContent = content
                    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
                    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
                    .replace(/<iframe[^>]*>[\s\S]*?<\/iframe>/gi, '')
                    .replace(/on\w+="[^"]*"/gi, '') // Remove event handlers
                    .replace(/javascript:[^"']*/gi, ''); // Remove javascript: links

                // Ensure external links open in new tab
                cleanContent = cleanContent.replace(/<a\s+href="([^"]*)"([^>]*)>/gi, '<a href="$1" target="_blank" rel="noopener noreferrer"$2>');

                return cleanContent;
            }

            closeReader() {
                const overlay = document.getElementById('readerOverlay');
                if (overlay) {
                    overlay.classList.remove('active');
                    document.body.style.overflow = 'auto';
                }
                this.currentArticle = null;
            }

            openOriginal() {
                if (this.currentArticle && this.currentArticle.url) {
                    window.open(this.currentArticle.url, '_blank', 'noopener,noreferrer');
                }
            }

// Enhanced backup management
async updateOneDriveBackup() {
                if (!this.accessToken) {
                    console.error('No access token for backup update');
                    return;
                }

                try {
                    console.log('üíæ Updating OneDrive backup with enhanced data...');

                    const backup = {
                        version: '2.1', // Updated version for AI features
                        timestamp: new Date().toISOString(),
                        articleCount: this.articles.length,
                        articles: this.articles,
                        categoryStats: Object.fromEntries(this.categories),
                        aiStats: {
                            totalCategories: this.categories.size,
                            aiEnhancedCount: this.articles.filter(a => a.aiEnhanced).length,
                            categorizedCount: this.articles.filter(a => a.category).length,
                            imagesStored: this.articles.filter(a => a.cachedImage).length
                        }
                    };

                    const filename = `mypocket-backup-${new Date().toISOString().split('T')[0]}.json`;
                    const content = JSON.stringify(backup, null, 2);

                    // Create or update file in OneDrive
                    const uploadUrl = `https://graph.microsoft.com/v1.0/me/drive/root:/MyPocket/${filename}:/content`;

                    const response = await fetch(uploadUrl, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: content
                    });

                    if (!response.ok) {
                        throw new Error(`Backup failed: ${response.status}`);
                    }

                    const result = await response.json();
                    const sizeMB = Math.round(result.size / 1024 / 1024 * 100) / 100;

                    console.log(`‚úÖ Backup updated: ${sizeMB}MB with enhanced AI data`);

                } catch (error) {
                    console.error('Backup error:', error);
                    throw error;
                }
            }

            // Enhanced utility functions
            getDomain(url) {
                try {
                    return new URL(url).hostname.replace('www.', '');
                } catch (e) {
                    return url;
                }
            }

            formatDate(dateString) {
                try {
                    const date = new Date(dateString);
                    return date.toLocaleDateString('en-US', {
                        month: 'short',
                        day: 'numeric',
                        year: 'numeric'
                    });
                } catch (e) {
                    return dateString;
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Get best image from article metadata
            getBestArticleImage(article) {
                const imageFields = ['image', 'leadImage', 'featuredImage', 'socialImage', 'ogImage', 'twitterImage'];

                for (const field of imageFields) {
                    if (article[field] && typeof article[field] === 'string' && article[field].length > 10) {
                        const imageUrl = article[field];
                        if (this.isValidImageUrl(imageUrl) && !this.isIconOrLogo(imageUrl)) {
                            return imageUrl;
                        }
                    }
                }

                return null;
            }

            isValidImageUrl(url) {
                if (!url || typeof url !== 'string') return false;
                return /\.(jpg|jpeg|png|gif|webp|bmp|svg)(\?|$|#)/i.test(url) ||
                    url.includes('image') ||
                    url.includes('photo') ||
                    url.includes('unsplash') ||
                    url.includes('imgur');
            }

            isIconOrLogo(url) {
                const iconKeywords = ['favicon', 'icon', 'logo', 'avatar', 'profile'];
                return iconKeywords.some(keyword => url.toLowerCase().includes(keyword));
            }

// Enhanced image extraction
async fetchRealImageFromWebsite(url) {
                try {
                    console.log(`üåê Extracting real image from: ${this.getDomain(url)}`);

                    // Try direct URL extraction first
                    const directImage = await this.tryDirectImageExtraction(url);
                    if (directImage) return directImage;

                    // Try proxy services
                    const proxyImage = await this.tryProxyExtraction(url);
                    if (proxyImage) return proxyImage;

                    return null;

                } catch (error) {
                    console.log(`‚ö†Ô∏è Image extraction failed: ${error.message}`);
                    return null;
                }
            }

async tryDirectImageExtraction(url) {
                try {
                    const response = await fetch(url, {
                        method: 'HEAD',
                        timeout: 5000
                    });

                    if (response.ok) {
                        const contentType = response.headers.get('content-type') || '';
                        if (contentType.startsWith('image/')) {
                            return url;
                        }
                    }
                } catch (error) {
                    // Silently continue to other methods
                }
                return null;
            }

async tryProxyExtraction(url) {
                const proxies = [
                    `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`,
                    `https://corsproxy.io/?${encodeURIComponent(url)}`
                ];

                for (const proxyUrl of proxies) {
                    try {
                        const response = await fetch(proxyUrl);
                        if (response.ok) {
                            const data = await response.json();
                            const html = data.contents || data;

                            if (html && html.length > 1000) {
                                const extractedImage = this.parseHTMLForBestImage(html, url);
                                if (extractedImage) return extractedImage;
                            }
                        }
                    } catch (error) {
                        continue;
                    }
                }
                return null;
            }

            parseHTMLForBestImage(html, baseUrl) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');

                    // Priority order for image extraction
                    const selectors = [
                        'meta[property="og:image"]',
                        'meta[name="twitter:image"]',
                        'meta[property="twitter:image"]',
                        'link[rel="image_src"]',
                        'img[class*="featured"]',
                        'img[class*="hero"]',
                        'img[class*="lead"]'
                    ];

                    for (const selector of selectors) {
                        const element = doc.querySelector(selector);
                        if (element) {
                            const imageUrl = element.getAttribute('content') || element.getAttribute('href') || element.getAttribute('src');
                            if (imageUrl && this.isValidImageUrl(imageUrl) && !this.isIconOrLogo(imageUrl)) {
                                return this.resolveImageUrl(imageUrl, baseUrl);
                            }
                        }
                    }

                    return null;

                } catch (error) {
                    console.log(`HTML parsing error: ${error.message}`);
                    return null;
                }
            }

            resolveImageUrl(imageUrl, baseUrl) {
                try {
                    if (imageUrl.startsWith('http')) {
                        return imageUrl;
                    } else if (imageUrl.startsWith('//')) {
                        return 'https:' + imageUrl;
                    } else if (imageUrl.startsWith('/')) {
                        const base = new URL(baseUrl);
                        return base.origin + imageUrl;
                    }
                    return imageUrl;
                } catch (error) {
                    return imageUrl;
                }
            }

            // Category-based fallback images
            getCategoryBasedImage(article, index) {
                const category = article.category || this.categorizeArticle(article);
                const domain = this.getDomain(article.url).toLowerCase();

                // Enhanced category-specific images
                const categoryImages = {
                    'Technology': [
                        'https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1627398242454-45a1465c2479?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'Science': [
                        'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1532094349884-543bc11b234d?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'Business': [
                        'https://images.unsplash.com/photo-1664475450424-2645cd1d4b21?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1611974789855-9c2a0a7236a3?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'News': [
                        'https://images.unsplash.com/photo-1504711434969-e33886168f5c?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1495020689067-958852a7765e?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'Health': [
                        'https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1571019613454-1cb2f99b2d8b?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ],
                    'default': [
                        'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=400&h=250&fit=crop&crop=center&q=80&auto=format',
                        'https://images.unsplash.com/photo-1481627834876-b7833e8f5570?w=400&h=250&fit=crop&crop=center&q=80&auto=format'
                    ]
                };

                const images = categoryImages[category] || categoryImages['default'];
                const imageIndex = (index + article.title.length) % images.length;

                return images[imageIndex];
            }

            // File export functionality
            createArticleHTML(article) {
                return `
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>${this.escapeHtml(article.title)}</title>
<style>
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; }
.header { border-bottom: 2px solid #eee; margin-bottom: 30px; padding-bottom: 20px; }
.title { font-size: 2em; margin-bottom: 10px; }
.meta { color: #666; font-size: 0.9em; }
.content { font-size: 1.1em; line-height: 1.8; }
.content img { max-width: 100%; height: auto; }
.footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee; color: #666; font-size: 0.9em; }
</style>
</head>
<body>
<div class="header">
<h1 class="title">${this.escapeHtml(article.title)}</h1>
<div class="meta">
<p>üåê Source: <a href="${article.url}" target="_blank">${this.getDomain(article.url)}</a></p>
<p>üìÖ Saved: ${this.formatDate(article.dateAdded)}</p>
${article.category ? `<p>üè∑Ô∏è Category: ${article.category}</p>` : ''}
${article.readTime ? `<p>‚è±Ô∏è Read time: ${article.readTime} minutes</p>` : ''}
</div>
</div>
<div class="content">
${article.content || article.textContent || `
<p><strong>Excerpt:</strong> ${this.escapeHtml(article.excerpt || 'No content available.')}</p>
<p><em>Full content was not saved. Visit the original link above to read the complete article.</em></p>
`}
</div>
<div class="footer">
<p>üìÅ Exported from MyPocket AI Reader on ${new Date().toLocaleDateString()}</p>
<p>üîó Original: <a href="${article.url}" target="_blank">${article.url}</a></p>
</div>
</body>
</html>
    `;
            }

            sanitizeFilename(filename) {
                return filename.replace(/[^a-z0-9]/gi, '_').toLowerCase().substring(0, 50);
            }

            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

// Enhanced authentication and API functionality
async tryPlatformSpecificImageExtraction(url) {
                const domain = this.getDomain(url).toLowerCase();

                // YouTube video thumbnails
                if (domain.includes('youtube.com') || domain.includes('youtu.be')) {
                    const videoId = this.extractYouTubeId(url);
                    if (videoId) {
                        return `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
                    }
                }

                // GitHub repositories
                if (domain.includes('github.com')) {
                    const match = url.match(/github\.com\/([^\/]+)\/([^\/]+)/);
                    if (match) {
                        return `https://opengraph.githubassets.com/1/${match[1]}/${match[2]}`;
                    }
                }

                return null;
            }

            extractYouTubeId(url) {
                const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]+)/;
                const match = url.match(regex);
                return match ? match[1] : null;
            }

            // Debug function to check elements
            debugElements() {
                console.log('üîß DEBUG: Checking sidebar elements...');

                const elements = {
                    'connectionStatusSidebar': document.getElementById('connectionStatusSidebar'),
                    'connectionIcon': document.getElementById('connectionIcon'),
                    'connectionText': document.getElementById('connectionText'),
                    'connectBtnSidebar': document.getElementById('connectBtnSidebar'),
                    'refreshNavBtn': document.getElementById('refreshNavBtn'),
                    'syncNavBtn': document.getElementById('syncNavBtn'),
                    'retryNavBtn': document.getElementById('retryNavBtn'),
                };

                for (const [name, element] of Object.entries(elements)) {
                    if (element) {
                        console.log(`‚úÖ ${name}: Found`);
                    } else {
                        console.log(`‚ùå ${name}: NOT FOUND`);
                    }
                }

                return elements;
            }

            // Test authentication method
            testAuth() {
                console.log('üß™ Testing authentication...');
                console.log('üìç Redirect URI:', this.redirectUri);
                console.log('üîë Client ID:', this.clientId);

                // Test if we can generate PKCE parameters
                try {
                    const testVerifier = this.generateCodeVerifier();
                    console.log('‚úÖ Code verifier generation: OK');
                    console.log('‚úÖ Authentication setup: Ready');
                } catch (error) {
                    console.error('‚ùå Authentication setup failed:', error);
                }
            }

            updateConnectionStatus(connected) {
                // Use the correct IDs that actually exist in the HTML
                const connectBtn = document.getElementById('connectBtnSidebar');
                const connectIcon = document.getElementById('connectionIcon');
                const connectText = document.getElementById('connectionText');
                const connectionStatusSidebar = document.getElementById('connectionStatusSidebar');

                if (connected) {
                    if (connectIcon) connectIcon.textContent = '‚úÖ';
                    if (connectText) connectText.textContent = 'Connected (PKCE+AI)';

                    if (connectBtn) {
                        connectBtn.style.background = '#27ae60';
                        connectBtn.textContent = 'Connected ‚úÖ';
                    }

                    if (connectionStatusSidebar) {
                        connectionStatusSidebar.className = 'connection-status-sidebar connected';
                    }
                } else {
                    if (connectIcon) connectIcon.textContent = 'üîê';
                    if (connectText) connectText.textContent = 'Not Connected';

                    if (connectBtn) {
                        connectBtn.style.background = '';
                        connectBtn.textContent = 'Secure Connect';
                    }

                    if (connectionStatusSidebar) {
                        connectionStatusSidebar.className = 'connection-status-sidebar disconnected';
                    }
                }
            }

            // ===== IMAGE CACHE SYSTEM =====

            loadImageCache() {
                try {
                    const cachedData = localStorage.getItem(this.cacheKey);
                    if (cachedData) {
                        const cache = JSON.parse(cachedData);

                        // Clean expired cache entries
                        const now = Date.now();
                        const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                        for (const [key, entry] of Object.entries(cache)) {
                            if (now - entry.timestamp < expiryTime) {
                                this.imageCache.set(key, entry);
                            }
                        }

                        console.log(`üì¶ Loaded ${this.imageCache.size} cached images`);
                    }
                } catch (error) {
                    console.error('Error loading image cache:', error);
                    this.imageCache.clear();
                }
            }

            saveImageCache() {
                try {
                    const cacheObject = {};
                    for (const [key, value] of this.imageCache.entries()) {
                        cacheObject[key] = value;
                    }

                    localStorage.setItem(this.cacheKey, JSON.stringify(cacheObject));
                    console.log(`üíæ Saved ${this.imageCache.size} images to cache`);
                } catch (error) {
                    console.error('Error saving image cache:', error);
                }
            }

            getCacheKey(article) {
                // Create a unique cache key based on article URL and title
                return `${this.getDomain(article.url)}_${article.url.substring(article.url.length - 20)}_${article.title.substring(0, 30)}`.replace(/[^a-zA-Z0-9]/g, '_');
            }

            getCachedImage(article) {
                const key = this.getCacheKey(article);
                const cached = this.imageCache.get(key);

                if (cached) {
                    const now = Date.now();
                    const expiryTime = this.cacheExpiryDays * 24 * 60 * 60 * 1000;

                    if (now - cached.timestamp < expiryTime) {
                        console.log(`‚úÖ Using cached image for: ${article.title.substring(0, 30)}...`);
                        return cached.imageUrl;
                    } else {
                        // Remove expired cache entry
                        this.imageCache.delete(key);
                        console.log(`‚è∞ Cache expired for: ${article.title.substring(0, 30)}...`);
                    }
                }

                return null;
            }

            setCachedImage(article, imageUrl) {
                const key = this.getCacheKey(article);

                this.imageCache.set(key, {
                    imageUrl: imageUrl,
                    timestamp: Date.now(),
                    domain: this.getDomain(article.url),
                    title: article.title.substring(0, 50)
                });

                // Save to localStorage (debounced)
                clearTimeout(this.cacheSaveTimeout);
                this.cacheSaveTimeout = setTimeout(() => this.saveImageCache(), 1000);

                console.log(`üíæ Cached image for: ${article.title.substring(0, 30)}...`);
            }

            clearImageCache() {
                if (confirm('Clear all cached images?\n\nThis will:\n- Clear local cache\n- Remove stored images from articles\n- Force re-downloading images next time')) {
                    // Clear local cache
                    this.imageCache.clear();
                    localStorage.removeItem(this.cacheKey);

                    // Clear stored images from articles
                    this.articles.forEach(article => {
                        if (article.cachedImage) {
                            delete article.cachedImage;
                        }
                    });

                    this.updateStatus('üóëÔ∏è All image data cleared. Images will be re-downloaded and stored for cross-device access.', 'success');
                    console.log('üóëÔ∏è All image data cleared');

                    // Refresh display
                    this.displayArticles(this.articles);
                }
            }

            getCacheStats() {
                const timestamps = Array.from(this.imageCache.values()).map(entry => entry.timestamp);

                return {
                    total: this.imageCache.size,
                    memoryUsage: JSON.stringify(Object.fromEntries(this.imageCache)).length,
                    oldestEntry: timestamps.length > 0 ? Math.min(...timestamps) : null,
                    newestEntry: timestamps.length > 0 ? Math.max(...timestamps) : null
                };
            }

// ===== CROSS-DEVICE IMAGE STORAGE =====

// Convert image URL to base64 data for storage
async convertImageToBase64(imageUrl) {
                try {
                    console.log(`üì∏ Converting image to base64: ${imageUrl.substring(0, 50)}...`);

                    // Create a canvas to convert image to base64
                    const img = new Image();
                    img.crossOrigin = 'anonymous'; // Handle CORS

                    return new Promise((resolve, reject) => {
                        img.onload = () => {
                            try {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');

                                // Set canvas size (optimize for web display)
                                const maxWidth = 400;
                                const maxHeight = 250;

                                let { width, height } = img;

                                // Maintain aspect ratio while limiting size
                                if (width > maxWidth) {
                                    height = (height * maxWidth) / width;
                                    width = maxWidth;
                                }

                                if (height > maxHeight) {
                                    width = (width * maxHeight) / height;
                                    height = maxHeight;
                                }

                                canvas.width = width;
                                canvas.height = height;

                                // Draw and convert to base64
                                ctx.drawImage(img, 0, 0, width, height);
                                const base64 = canvas.toDataURL('image/jpeg', 0.8); // Compress to 80% quality

                                // Check size limit
                                const sizeKB = Math.round(base64.length * 0.75 / 1024); // Rough base64 size calculation

                                if (sizeKB > this.maxImageSizeKB) {
                                    console.log(`‚ö†Ô∏è Image too large (${sizeKB}KB), using URL only`);
                                    resolve({ url: imageUrl, size: sizeKB, stored: false });
                                } else {
                                    console.log(`‚úÖ Image converted (${sizeKB}KB): ${imageUrl.substring(0, 30)}...`);
                                    resolve({ base64: base64, url: imageUrl, size: sizeKB, stored: true });
                                }
                            } catch (error) {
                                console.log(`‚ùå Canvas conversion failed: ${error.message}`);
                                resolve({ url: imageUrl, stored: false });
                            }
                        };

                        img.onerror = () => {
                            console.log(`‚ùå Image load failed: ${imageUrl}`);
                            resolve({ url: imageUrl, stored: false });
                        };

                        img.src = imageUrl;
                    });
                } catch (error) {
                    console.error('Image conversion error:', error);
                    return { url: imageUrl, stored: false };
                }
            }
}

            // Initialize the application
            console.log('üéØ Creating MyPocket AI-Enhanced Web Reader...');
            window.webReader = new MyPocketWebReader();

            // Make debug function available globally
            window.debugMyPocket = function () {
                return window.webReader ? window.webReader.debugElements() : 'WebReader not initialized';
            };

            console.log('üöÄ MyPocket AI-Enhanced Web Reader initialized successfully!');
            console.log('üìù Available commands:');
            console.log('   ‚Ä¢ webReader.recategorizeAllWithAI() - Refresh AI categories');
            console.log('   ‚Ä¢ webReader.improvedCategorizer.enableDebugMode() - Enable AI debug');
            console.log('   ‚Ä¢ webReader.showDebugInfo() - Show system info');
            console.log('   ‚Ä¢ window.debugMyPocket() - Check element availability');
        </script>
</body>

</html>
    
